---
title: Unterschlüssel Ableitung und authentifizierte Verschlüsselung in ASP.net Core
author: rick-anderson
description: Erfahren Sie mehr über die Implementierungsdetails ASP.net Core Unterschlüssel Ableitung von Datenschutz und authentifizierte Verschlüsselung.
ms.author: riande
ms.date: 10/14/2016
uid: security/data-protection/implementation/subkeyderivation
ms.openlocfilehash: bbfde378755b09cd5b1217b8cf66249b9fa1d6ad
ms.sourcegitcommit: 9a129f5f3e31cc449742b164d5004894bfca90aa
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 03/06/2020
ms.locfileid: "78652243"
---
# <a name="subkey-derivation-and-authenticated-encryption-in-aspnet-core"></a><span data-ttu-id="b888e-103">Unterschlüssel Ableitung und authentifizierte Verschlüsselung in ASP.net Core</span><span class="sxs-lookup"><span data-stu-id="b888e-103">Subkey derivation and authenticated encryption in ASP.NET Core</span></span>

<a name="data-protection-implementation-subkey-derivation"></a>

<span data-ttu-id="b888e-104">Die meisten Schlüssel im Schlüsselbund enthalten eine Form der Entropie und enthalten algorithmische Informationen, die "CBC-modusverschlüsselung + HMAC-Validierung" oder "GCM-Verschlüsselung + Validierung" angeben.</span><span class="sxs-lookup"><span data-stu-id="b888e-104">Most keys in the key ring will contain some form of entropy and will have algorithmic information stating "CBC-mode encryption + HMAC validation" or "GCM encryption + validation".</span></span> <span data-ttu-id="b888e-105">In diesen Fällen verweisen wir auf die eingebettete Entropie als Hauptschlüssel Material (oder km) für diesen Schlüssel und führen eine Schlüssel Ableitungen Funktion aus, um die Schlüssel abzuleiten, die für die eigentlichen Kryptografievorgänge verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="b888e-105">In these cases, we refer to the embedded entropy as the master keying material (or KM) for this key, and we perform a key derivation function to derive the keys that will be used for the actual cryptographic operations.</span></span>

> [!NOTE]
> <span data-ttu-id="b888e-106">Schlüssel sind abstrakt, und eine benutzerdefinierte Implementierung verhält sich möglicherweise nicht wie unten beschrieben.</span><span class="sxs-lookup"><span data-stu-id="b888e-106">Keys are abstract, and a custom implementation might not behave as below.</span></span> <span data-ttu-id="b888e-107">Wenn der Schlüssel seine eigene Implementierung von `IAuthenticatedEncryptor` bereitstellt, anstatt eine unserer integrierten Factorys zu verwenden, gilt der in diesem Abschnitt beschriebene Mechanismus nicht mehr.</span><span class="sxs-lookup"><span data-stu-id="b888e-107">If the key provides its own implementation of `IAuthenticatedEncryptor` rather than using one of our built-in factories, the mechanism described in this section no longer applies.</span></span>

<a name="data-protection-implementation-subkey-derivation-aad"></a>

## <a name="additional-authenticated-data-and-subkey-derivation"></a><span data-ttu-id="b888e-108">Zusätzliche authentifizierte Daten und Unterschlüssel Ableitung</span><span class="sxs-lookup"><span data-stu-id="b888e-108">Additional authenticated data and subkey derivation</span></span>

<span data-ttu-id="b888e-109">Die `IAuthenticatedEncryptor`-Schnittstelle fungiert als Kernschnittstelle für alle authentifizierten Verschlüsselungs Vorgänge.</span><span class="sxs-lookup"><span data-stu-id="b888e-109">The `IAuthenticatedEncryptor` interface serves as the core interface for all authenticated encryption operations.</span></span> <span data-ttu-id="b888e-110">Die `Encrypt`-Methode nimmt zwei Puffer an: "nur" und "additionalauthentitoreddata" (AAD).</span><span class="sxs-lookup"><span data-stu-id="b888e-110">Its `Encrypt` method takes two buffers: plaintext and additionalAuthenticatedData (AAD).</span></span> <span data-ttu-id="b888e-111">Der nur-Text-Inhalt fließt unverändert zum Aufrufen von `IDataProtector.Protect`, aber der Aad wird vom System generiert und besteht aus drei Komponenten:</span><span class="sxs-lookup"><span data-stu-id="b888e-111">The plaintext contents flow unchanged the call to `IDataProtector.Protect`, but the AAD is generated by the system and consists of three components:</span></span>

1. <span data-ttu-id="b888e-112">Der 32-Bit Magic Header 09 F0 C9 F0, der diese Version des Datenschutzsystems identifiziert.</span><span class="sxs-lookup"><span data-stu-id="b888e-112">The 32-bit magic header 09 F0 C9 F0 that identifies this version of the data protection system.</span></span>

2. <span data-ttu-id="b888e-113">Die 128-Bit-Schlüssel-ID.</span><span class="sxs-lookup"><span data-stu-id="b888e-113">The 128-bit key id.</span></span>

3. <span data-ttu-id="b888e-114">Eine Zeichenfolge mit variabler Länge, die aus der Zweck Kette gebildet wird, die den `IDataProtector` erstellt, der diesen Vorgang ausführt.</span><span class="sxs-lookup"><span data-stu-id="b888e-114">A variable-length string formed from the purpose chain that created the `IDataProtector` that's performing this operation.</span></span>

<span data-ttu-id="b888e-115">Da Aad für das Tupel aller drei Komponenten eindeutig ist, kann es verwendet werden, um neue Schlüssel von km zu ableiten, anstatt km selbst in allen kryptografischen Vorgängen zu verwenden.</span><span class="sxs-lookup"><span data-stu-id="b888e-115">Because the AAD is unique for the tuple of all three components, we can use it to derive new keys from KM instead of using KM itself in all of our cryptographic operations.</span></span> <span data-ttu-id="b888e-116">Für jeden `IAuthenticatedEncryptor.Encrypt`-Aufrufe findet der folgende Schlüssel abderivationsprozess statt:</span><span class="sxs-lookup"><span data-stu-id="b888e-116">For every call to `IAuthenticatedEncryptor.Encrypt`, the following key derivation process takes place:</span></span>

<span data-ttu-id="b888e-117">( K_E, K_H ) = SP800_108_CTR_HMACSHA512(K_M, AAD, contextHeader || keyModifier)</span><span class="sxs-lookup"><span data-stu-id="b888e-117">( K_E, K_H ) = SP800_108_CTR_HMACSHA512(K_M, AAD, contextHeader || keyModifier)</span></span>

<span data-ttu-id="b888e-118">Hier rufen wir die NIST SP800-108 KDF im Counter-Modus (siehe [NIST SP800-108](https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-108.pdf), sec. 5,1) mit den folgenden Parametern auf:</span><span class="sxs-lookup"><span data-stu-id="b888e-118">Here, we're calling the NIST SP800-108 KDF in Counter Mode (see [NIST SP800-108](https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-108.pdf), Sec. 5.1) with the following parameters:</span></span>

* <span data-ttu-id="b888e-119">Key derivations Schlüssel (KDK) = K_M</span><span class="sxs-lookup"><span data-stu-id="b888e-119">Key derivation key (KDK) = K_M</span></span>

* <span data-ttu-id="b888e-120">PRF = HMACSHA512</span><span class="sxs-lookup"><span data-stu-id="b888e-120">PRF = HMACSHA512</span></span>

* <span data-ttu-id="b888e-121">Bezeichnung = additionalauthentiereddata</span><span class="sxs-lookup"><span data-stu-id="b888e-121">label = additionalAuthenticatedData</span></span>

* <span data-ttu-id="b888e-122">Context = contexteader | | keymodifier</span><span class="sxs-lookup"><span data-stu-id="b888e-122">context = contextHeader || keyModifier</span></span>

<span data-ttu-id="b888e-123">Der Kontext Header weist eine Variable Länge auf und fungiert im Wesentlichen als Fingerabdruck der Algorithmen, für die K_E und K_H abgeleitet werden.</span><span class="sxs-lookup"><span data-stu-id="b888e-123">The context header is of variable length and essentially serves as a thumbprint of the algorithms for which we're deriving K_E and K_H.</span></span> <span data-ttu-id="b888e-124">Beim schlüsselmodifizierer handelt es sich um eine 128-Bit-Zeichenfolge, die nach dem Zufallsprinzip für jeden `Encrypt` aufgerufen wird. er stellt sicher, dass der Wert für "KE" und "KH" für diesen spezifischen Authentifizierungs Verschlüsselungs Vorgang eindeutig ist.</span><span class="sxs-lookup"><span data-stu-id="b888e-124">The key modifier is a 128-bit string randomly generated for each call to `Encrypt` and serves to ensure with overwhelming probability that KE and KH are unique for this specific authentication encryption operation, even if all other input to the KDF is constant.</span></span>

<span data-ttu-id="b888e-125">Für CBC-modusverschlüsselung + HMAC-Validierungs Vorgänge | K_E | die Länge des symmetrischen Blockchiffre Schlüssels und | K_H | Die Hashgröße der HMAC-Routine.</span><span class="sxs-lookup"><span data-stu-id="b888e-125">For CBC-mode encryption + HMAC validation operations, | K_E | is the length of the symmetric block cipher key, and | K_H | is the digest size of the HMAC routine.</span></span> <span data-ttu-id="b888e-126">Für GCM-Verschlüsselung und Validierungs Vorgänge | K_H | = 0.</span><span class="sxs-lookup"><span data-stu-id="b888e-126">For GCM encryption + validation operations, | K_H | = 0.</span></span>

## <a name="cbc-mode-encryption--hmac-validation"></a><span data-ttu-id="b888e-127">Verschlüsselung im CBC-Modus + HMAC-Validierung</span><span class="sxs-lookup"><span data-stu-id="b888e-127">CBC-mode encryption + HMAC validation</span></span>

<span data-ttu-id="b888e-128">Nachdem K_E über den obigen Mechanismus generiert wurde, generieren wir einen zufälligen Initialisierungs Vektor und führen den symmetrischen Blockchiffre Algorithmus aus, um den Klartext zu entschlüsseln.</span><span class="sxs-lookup"><span data-stu-id="b888e-128">Once K_E is generated via the above mechanism, we generate a random initialization vector and run the symmetric block cipher algorithm to encipher the plaintext.</span></span> <span data-ttu-id="b888e-129">Der Initialisierungs Vektor und der Chiffre Text werden dann über die HMAC-Routine ausgeführt, die mit dem Schlüssel K_H initialisiert wurde, um den Mac zu entwickeln.</span><span class="sxs-lookup"><span data-stu-id="b888e-129">The initialization vector and ciphertext are then run through the HMAC routine initialized with the key K_H to produce the MAC.</span></span> <span data-ttu-id="b888e-130">Dieser Prozess und der Rückgabewert werden im folgenden grafisch dargestellt.</span><span class="sxs-lookup"><span data-stu-id="b888e-130">This process and the return value is represented graphically below.</span></span>

![CBC-Modus-Prozess und-Rückgabe](subkeyderivation/_static/cbcprocess.png)

<span data-ttu-id="b888e-132">*Output: = keymodifier | | IV | | E_cbc (K_E, IV, Daten) | | HMAC (K_H, IV | | E_cbc (K_E, IV, Daten))*</span><span class="sxs-lookup"><span data-stu-id="b888e-132">*output:= keyModifier || iv || E_cbc (K_E,iv,data) || HMAC(K_H, iv || E_cbc (K_E,iv,data))*</span></span>

> [!NOTE]
> <span data-ttu-id="b888e-133">Die `IDataProtector.Protect`-Implementierung stellt [den Magic-Header und die Schlüssel-ID](xref:security/data-protection/implementation/authenticated-encryption-details) vor der Rückgabe an den Aufrufer voran.</span><span class="sxs-lookup"><span data-stu-id="b888e-133">The `IDataProtector.Protect` implementation will [prepend the magic header and key id](xref:security/data-protection/implementation/authenticated-encryption-details) to output before returning it to the caller.</span></span> <span data-ttu-id="b888e-134">Da der Magic-Header und die Schlüssel-ID implizit zu [Aad](xref:security/data-protection/implementation/subkeyderivation#data-protection-implementation-subkey-derivation-aad)gehören und der schlüsselmodifizierer als Eingabe für die KDF ausgegeben wird, bedeutet dies, dass jedes einzelne Byte der letzten zurückgegebenen Nutzlast vom Mac authentifiziert wird.</span><span class="sxs-lookup"><span data-stu-id="b888e-134">Because the magic header and key id are implicitly part of [AAD](xref:security/data-protection/implementation/subkeyderivation#data-protection-implementation-subkey-derivation-aad), and because the key modifier is fed as input to the KDF, this means that every single byte of the final returned payload is authenticated by the MAC.</span></span>

## <a name="galoiscounter-mode-encryption--validation"></a><span data-ttu-id="b888e-135">Galois/Counter-modusverschlüsselung + Validierung</span><span class="sxs-lookup"><span data-stu-id="b888e-135">Galois/Counter Mode encryption + validation</span></span>

<span data-ttu-id="b888e-136">Nachdem K_E über den obigen Mechanismus generiert wurde, generieren wir eine zufällige 96-Bit-Nonce und führen den symmetrischen Blockchiffre Algorithmus aus, um den Klartext zu entschlüsseln und das 128-Bit-authentifizierungstag zu erzeugen.</span><span class="sxs-lookup"><span data-stu-id="b888e-136">Once K_E is generated via the above mechanism, we generate a random 96-bit nonce and run the symmetric block cipher algorithm to encipher the plaintext and produce the 128-bit authentication tag.</span></span>

![GCM-Modus-Prozess und-Rückgabe](subkeyderivation/_static/galoisprocess.png)

<span data-ttu-id="b888e-138">*Output: = keymodifier | | Nonce | | E_gcm (K_E, Nonce, Daten) | | authtag*</span><span class="sxs-lookup"><span data-stu-id="b888e-138">*output := keyModifier || nonce || E_gcm (K_E,nonce,data) || authTag*</span></span>

> [!NOTE]
> <span data-ttu-id="b888e-139">Auch wenn GCM das Konzept von Aad nativ unterstützt, wird Aad immer noch mit der ursprünglichen KDF-Datei versorgt, sodass für den Aad-Parameter eine leere Zeichenfolge an GCM übergeben werden kann.</span><span class="sxs-lookup"><span data-stu-id="b888e-139">Even though GCM natively supports the concept of AAD, we're still feeding AAD only to the original KDF, opting to pass an empty string into GCM for its AAD parameter.</span></span> <span data-ttu-id="b888e-140">Der Grund dafür ist zwei fache.</span><span class="sxs-lookup"><span data-stu-id="b888e-140">The reason for this is two-fold.</span></span> <span data-ttu-id="b888e-141">[Zur Unterstützung von Agilität](xref:security/data-protection/implementation/context-headers#data-protection-implementation-context-headers) möchten wir K_M nicht direkt als Verschlüsselungsschlüssel verwenden.</span><span class="sxs-lookup"><span data-stu-id="b888e-141">First, [to support agility](xref:security/data-protection/implementation/context-headers#data-protection-implementation-context-headers) we never want to use K_M directly as the encryption key.</span></span> <span data-ttu-id="b888e-142">Darüber hinaus erzwingt GCM sehr strenge Eindeutigkeits Anforderungen für die Eingaben.</span><span class="sxs-lookup"><span data-stu-id="b888e-142">Additionally, GCM imposes very strict uniqueness requirements on its inputs.</span></span> <span data-ttu-id="b888e-143">Die Wahrscheinlichkeit, dass die GCM-Verschlüsselungsroutine für zwei oder mehr unterschiedliche Sätze von Eingabedaten mit dem gleichen (Key, Nonce)-Paar aufgerufen wird, darf nicht größer als 2 ^ 32 sein.</span><span class="sxs-lookup"><span data-stu-id="b888e-143">The probability that the GCM encryption routine is ever invoked on two or more distinct sets of input data with the same (key, nonce) pair must not exceed 2^32.</span></span> <span data-ttu-id="b888e-144">Wenn wir den K_E korrigieren, dürfen nicht mehr als 2 ^ 32-Verschlüsselungs Vorgänge ausgeführt werden, bevor das Limit von 2 ^-32 erreicht wird.</span><span class="sxs-lookup"><span data-stu-id="b888e-144">If we fix K_E we cannot perform more than 2^32 encryption operations before we run afoul of the 2^-32 limit.</span></span> <span data-ttu-id="b888e-145">Dies mag eine sehr große Anzahl von Vorgängen sein, aber ein Webserver mit hohem Datenverkehr kann 4 Milliarden Anforderungen in nur wenigen Tagen durchlaufen, und zwar innerhalb der normalen Lebensdauer für diese Schlüssel.</span><span class="sxs-lookup"><span data-stu-id="b888e-145">This might seem like a very large number of operations, but a high-traffic web server can go through 4 billion requests in mere days, well within the normal lifetime for these keys.</span></span> <span data-ttu-id="b888e-146">Um die Einhaltung der Wahrscheinlichkeits Grenze von 2 ^-32 einzuhalten, verwenden wir weiterhin einen 128-Bit-schlüsselmodifizierer und 96-Bit Nonce, wodurch die nutzbare Vorgangs Anzahl für jede angegebene K_M radikal erweitert wird.</span><span class="sxs-lookup"><span data-stu-id="b888e-146">To stay compliant of the 2^-32 probability limit, we continue to use a 128-bit key modifier and 96-bit nonce, which radically extends the usable operation count for any given K_M.</span></span> <span data-ttu-id="b888e-147">Aus Gründen der Einfachheit des Entwurfs wird der KDF-Codepfad zwischen CBC-und GCM-Vorgängen gemeinsam genutzt, und da Aad bereits in der KDF berücksichtigt wird, ist es nicht erforderlich, ihn an die GCM-Routine weiterzuleiten.</span><span class="sxs-lookup"><span data-stu-id="b888e-147">For simplicity of design we share the KDF code path between CBC and GCM operations, and since AAD is already considered in the KDF there's no need to forward it to the GCM routine.</span></span>
