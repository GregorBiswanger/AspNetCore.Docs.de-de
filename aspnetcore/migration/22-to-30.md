---
title: Migrieren von ASP.NET Core 2.2 auf 3.0
author: rick-anderson
description: Erfahren Sie, wie Sie ein ASP.NET Core 2.2-Projekt zu ASP.NET Core 3.0 migrieren.
ms.author: riande
ms.custom: mvc
ms.date: 01/21/2020
no-loc:
- SignalR
uid: migration/22-to-30
ms.openlocfilehash: 84ef0cfd7e2d785ed4c107dcfc30434f2aa9bfa0
ms.sourcegitcommit: 77c046331f3d633d7cc247ba77e58b89e254f487
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 04/16/2020
ms.locfileid: "81488786"
---
# <a name="migrate-from-aspnet-core-22-to-30"></a>Migrieren von ASP.NET Core 2.2 auf 3.0

Von [Scott Addie](https://github.com/scottaddie) und [Rick Anderson](https://twitter.com/RickAndMSFT)

In diesem Artikel wird erläutert, wie Sie ein vorhandenes ASP.NET Core 2.2-Projekt auf ASP.NET Core 3.0 aktualisieren. Es kann hilfreich sein, ein neues ASP.NET Core 3.0-Projekt zu erstellen, um:

* Vergleichen Sie mit dem ASP.NET Core 2.2-Code.
* Kopieren Sie die relevanten Änderungen in Ihr ASP.NET Core 3.0-Projekt.

## <a name="prerequisites"></a>Voraussetzungen

# <a name="visual-studio"></a>[Visual Studio](#tab/visual-studio)

[!INCLUDE[](~/includes/net-core-prereqs-vs-3.0.md)]

# <a name="visual-studio-code"></a>[Visual Studio Code](#tab/visual-studio-code)

[!INCLUDE[](~/includes/net-core-prereqs-vsc-3.0.md)]

# <a name="visual-studio-for-mac"></a>[Visual Studio für Mac](#tab/visual-studio-mac)

[!INCLUDE[](~/includes/net-core-prereqs-mac-3.0.md)]

---

## <a name="update-net-core-sdk-version-in-globaljson"></a>Aktualisieren der .NET Core SDK-Version in „global.json“

Wenn Ihre Lösung auf einer [global.json-Datei](/dotnet/core/tools/global-json) basiert, die auf `version` eine bestimmte .NET Core SDK-Version ausgerichtet ist, aktualisieren Sie ihre Eigenschaft auf die auf Ihrem Computer installierte Version 3.0:

```json
{
  "sdk": {
    "version": "3.0.100"
  }
}
```

## <a name="update-the-project-file"></a>Aktualisieren der Projektdatei

### <a name="update-the-target-framework"></a>Aktualisieren des Zielframeworks

ASP.NET Core 3.0 und höher nur auf .NET Core ausgeführt werden. Legen Sie den [Target Framework Moniker (TFM)](/dotnet/standard/frameworks) auf `netcoreapp3.0`:

[!code-xml[](22-to-30/samples/Web1.csproj?highlight=4)]

### <a name="remove-obsolete-package-references"></a>Entfernen veralteter Paketverweise

Eine große Anzahl von NuGet-Paketen wird nicht für ASP.NET Core 3.0 produziert. Solche Paketverweise sollten aus der Projektdatei entfernt werden. Betrachten Sie die folgende Projektdatei für eine ASP.NET Core 2.2-Web-App:

```xml
<Project Sdk="Microsoft.NET.Sdk.Web">

  <PropertyGroup>
    <TargetFramework>netcoreapp2.2</TargetFramework>
    <AspNetCoreHostingModel>InProcess</AspNetCoreHostingModel>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.AspNetCore.App"/>
    <PackageReference Include="Microsoft.AspNetCore.Razor.Design" Version="2.2.0" PrivateAssets="All" />
  </ItemGroup>

</Project>
```

Die aktualisierte Projektdatei für ASP.NET Core 3.0:

[!code-xml[](22-to-30/samples/Web1.csproj?highlight=4)]

Die aktualisierte ASP.NET Core 3.0-Projektdatei:

* In `<PropertyGroup>`:
  * Aktualisiert den TFM auf`netcoreapp3.0`
  * Entfernt das `<AspNetCoreHostingModel>` Element. Weitere Informationen finden Sie unter [In-Process-Hostingmodell](#in-process-hosting-model) in diesem Dokument.

* In `<ItemGroup>`:
  * `Microsoft.AspNetCore.App`entfernt wird. Weitere Informationen finden Sie unter [Rahmenverweis](#framework-reference) in diesem Dokument.
  * `Microsoft.AspNetCore.Razor.Design`wird entfernt und in der folgenden Liste der Pakete, die nicht mehr produziert werden.

Um die vollständige Liste der nicht mehr produzierten Pakete anzuzeigen, wählen Sie die folgende Erweiterungsliste aus:

<details>
    <summary>Klicken Sie hier, um die Liste der nicht mehr produzierten Pakete zu erweitern.</summary>
    <ul>
        <li>Microsoft.AspNetCore</li>
        <li>Microsoft.AspNetCore.All</li>
        <li>Microsoft.AspNetCore.App</li>
        <li>Microsoft.AspNetCore.Antiforgery</li>
        <li>Microsoft.AspNetCore.Authentication</li>
        <li>Microsoft.AspNetCore.Authentication.Abstractions</li>
        <li>Microsoft.AspNetCore.Authentication.Cookies</li>
        <li>Microsoft.AspNetCore.Authentication.Core</li>
        <li>Microsoft.AspNetCore.Authentication.OAuth</li>
        <li>Microsoft.AspNetCore.Authorization.Policy</li>
        <li>Microsoft.AspNetCore.CookiePolicy</li>
        <li>Microsoft.AspNetCore.Cors</li>
        <li>Microsoft.AspNetCore.Diagnostics</li>
        <li>Microsoft.AspNetCore.Diagnostics.HealthChecks</li>
        <li>Microsoft.AspNetCore.HostFiltering</li>
        <li>Microsoft.AspNetCore.Hosting</li>
        <li>Microsoft.AspNetCore.Hosting.Abstractions</li>
        <li>Microsoft.AspNetCore.Hosting.Server.Abstractions</li>
        <li>Microsoft.AspNetCore.Http</li>
        <li>Microsoft.AspNetCore.Http.Abstractions</li>
        <li>Microsoft.AspNetCore.Http.Connections</li>
        <li>Microsoft.AspNetCore.Http.Extensions</li>
        <li>Microsoft.AspNetCore.HttpOverrides</li>
        <li>Microsoft.AspNetCore.HttpsPolicy</li>
        <li>Microsoft.AspNetCore.Identity</li>
        <li>Microsoft.AspNetCore.Localization</li>
        <li>Microsoft.AspNetCore.Localization.Routing</li>
        <li>Microsoft.AspNetCore.Mvc</li>
        <li>Microsoft.AspNetCore.Mvc.Abstractions</li>
        <li>Microsoft.AspNetCore.Mvc.Analyzers</li>
        <li>Microsoft.AspNetCore.Mvc.ApiExplorer</li>
        <li>Microsoft.AspNetCore.Mvc.Api.Analyzers</li>
        <li>Microsoft.AspNetCore.Mvc.Core</li>
        <li>Microsoft.AspNetCore.Mvc.Cors</li>
        <li>Microsoft.AspNetCore.Mvc.DataAnnotations</li>
        <li>Microsoft.AspNetCore.Mvc.Formatters.Json</li>
        <li>Microsoft.AspNetCore.Mvc.Formatters.Xml</li>
        <li>Microsoft.AspNetCore.Mvc.Localization</li>
        <li>Microsoft.AspNetCore.Mvc.Razor</li>
        <li>Microsoft.AspNetCore.Mvc.Razor.ViewCompilation</li>
        <li>Microsoft.AspNetCore.Mvc.RazorPages</li>
        <li>Microsoft.AspNetCore.Mvc.TagHelpers</li>
        <li>Microsoft.AspNetCore.Mvc.ViewFeatures</li>
        <li>Microsoft.AspNetCore.Razor</li>
        <li>Microsoft.AspNetCore.Razor.Runtime</li>
        <li>Microsoft.AspNetCore.Razor.Design</li>
        <li>Microsoft.AspNetCore.ResponseCaching</li>
        <li>Microsoft.AspNetCore.ResponseCaching.Abstractions</li>
        <li>Microsoft.AspNetCore.ResponseCompression</li>
        <li>Microsoft.AspNetCore.Rewrite</li>
        <li>Microsoft.AspNetCore.Routing</li>
        <li>Microsoft.AspNetCore.Routing.Abstractions</li>
        <li>Microsoft.AspNetCore.Server.HttpSys</li>
        <li>Microsoft.AspNetCore.Server.IIS</li>
        <li>Microsoft.AspNetCore.Server.IISIntegration</li>
        <li>Microsoft.AspNetCore.Server.Kestrel</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Core</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Https</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets</li>
        <li>Microsoft.AspNetCore.Session</li>
        <li>Microsoft.AspNetCore.SignalR</li>
        <li>Microsoft.AspNetCore. SignalR. Kern</li>
        <li>Microsoft.AspNetCore.StaticFiles</li>
        <li>Microsoft.AspNetCore.WebSockets</li>
        <li>Microsoft.AspNetCore.WebUtilities</li>
        <li>Microsoft.Net.Http.Headers </li>
    </ul>
</details>

### <a name="review-breaking-changes"></a>Überprüfen von Änderungen

[Überprüfen von Änderungen](#break)

### <a name="framework-reference"></a>Rahmenreferenz

Features von ASP.NET Core, die über eines der oben aufgeführten `Microsoft.AspNetCore.App` Pakete verfügbar waren, sind als Teil des gemeinsam genutzten Frameworks verfügbar. Das *freigegebene Framework* ist der Satz von Assemblys (*DLL*-Dateien), die auf dem Computer installiert werden und eine Laufzeitkomponente sowie ein Zielpaket enthalten. Weitere Informationen finden Sie unter [The shared framework](https://natemcmaster.com/blog/2018/08/29/netcore-primitives-2/) (Das freigegebene Framework).

* Projekte, die auf das `Microsoft.NET.Sdk.Web` SDK abzielen, verweisen implizit auf das `Microsoft.AspNetCore.App`-Framework.

  Für diese Projekte sind keine weiteren Verweise erforderlich:

  ```xml
  <Project Sdk="Microsoft.NET.Sdk.Web">
    <PropertyGroup>
      <TargetFramework>netcoreapp3.0</TargetFramework>
    </PropertyGroup>
      ...
  </Project>
  ```

* Projekte, `Microsoft.NET.Sdk` die `Microsoft.NET.Sdk.Razor` auf das Ziel `FrameworkReference` oder `Microsoft.AspNetCore.App`SDK abzielen, sollten eine explizite zu:

  ```xml
  <Project Sdk="Microsoft.NET.Sdk.Razor">
    <PropertyGroup>
      <TargetFramework>netcoreapp3.0</TargetFramework>
    </PropertyGroup>

    <ItemGroup>
      <FrameworkReference Include="Microsoft.AspNetCore.App" />
    </ItemGroup>
      ...
  </Project>
  ```

#### <a name="framework-dependent-builds-using-docker"></a>Framework-abhängige Builds mit Docker

Framework-abhängige Builds von Konsolen-Apps, die ein Paket verwenden, das von der ASP.NET [freigegebenen Core-Frameworks](https://natemcmaster.com/blog/2018/08/29/netcore-primitives-2/) abhängt, können den folgenden Laufzeitfehler verursachen:

```console
It was not possible to find any compatible framework version
The specified framework 'Microsoft.AspNetCore.App', version '3.0.0' was not found.
  - No frameworks were found.
```

`Microsoft.AspNetCore.App`ist das gemeinsame Framework, das die ASP.NET Core-Laufzeit enthält und nur im [Punkt-/Core-Docker-Image](https://hub.docker.com/_/microsoft-dotnet-core-aspnet/) vorhanden ist. Das 3.0 SDK reduziert die Größe von frameworkabhängigen Builds, die ASP.NET Core verwenden, indem keine duplizierten Kopien von Bibliotheken enthalten sind, die im freigegebenen Framework verfügbar sind. Dies ist eine potenzielle Einsparung von bis zu 18 MB, aber es erfordert, dass die ASP.NET Core-Laufzeit vorhanden / installiert sein, um die App auszuführen.

Um festzustellen, ob die App eine (direkte oder indirekte) Abhängigkeit vom freigegebenen ASP.NET Core-Framework hat, untersuchen Sie die *Datei runtimeconfig.json,* die während eines Builds/Veröffentlichens Ihrer App generiert wurde. Die folgende JSON-Datei zeigt eine Abhängigkeit vom freigegebenen ASP.NET Core-Framework:

```json
{
  "runtimeOptions": {
    "tfm": "netcoreapp3.0",
    "framework": {
      "name": "Microsoft.AspNetCore.App",
      "version": "3.0.0"
    },
    "configProperties": {
      "System.GC.Server": true
    }
  }
}
```

Wenn Ihre App Docker verwendet, verwenden Sie ein Basisabbild, das ASP.NET Core 3.0 enthält. Beispiel: `docker pull mcr.microsoft.com/dotnet/core/aspnet:3.0`.

### <a name="add-package-references-for-removed-assemblies"></a>Hinzufügen von Paketverweisen für entfernte Assemblys

ASP.NET Core 3.0 entfernt einige Assemblys, `Microsoft.AspNetCore.App` die zuvor Teil des Paketverweises waren. Vergleichen Sie die beiden freigegebenen Frameworkordner, um zu visualisieren, welche Assemblys entfernt wurden. Ein Vergleich der Versionen 2.2.7 und 3.0.0:

![Vergleich der gemeinsamen Frameworkassemblys](22-to-30/_static/assembly-diff.png)

Um die von den entfernten Assemblys bereitgestellten Features weiterhin zu verwenden, verweisen Sie auf die 3.0-Versionen der entsprechenden Pakete:

* Eine vorlagengenerierte Web-App mit **einzelnen Benutzerkonten** erfordert das Hinzufügen der folgenden Pakete:

  [!code-xml[](22-to-30/samples/WebFull.csproj?highlight=9-13)]

* [Microsoft.EntityFrameworkCore](https://www.nuget.org/packages/Microsoft.EntityFrameworkCore)

  Weitere Informationen zum Verweisen auf das datenbankanbieterspezifische Paket finden Sie unter [Datenbankanbieter](/ef/core/providers/index).

* Identitäts-UI

  Unterstützung für [die Identitätsbenutzeroberfläche](xref:security/authentication/identity) kann hinzugefügt werden, indem auf das [Microsoft.AspNetCore.Identity.UI-Paket](https://www.nuget.org/packages/Microsoft.AspNetCore.Identity.UI) verwiesen wird.

* SPA-Dienstleistungen

  * [Microsoft.AspNetCore.SpaServices](https://www.nuget.org/packages/Microsoft.AspNetCore.SpaServices)
  * [Microsoft.AspNetCore.SpaServices.Extensions](https://www.nuget.org/packages/Microsoft.AspNetCore.SpaServices.Extensions)

* Authentifizierungsunterstützung &ndash; für Authentifizierungsflüsse von Drittanbietern ist als NuGet-Pakete verfügbar:

  * Facebook OAuth ([Microsoft.AspNetCore.Authentication.Facebook](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Facebook))
  * Google OAuth ([Microsoft.AspNetCore.Authentication.Google](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Google))
  * Microsoft-Kontoauthentifizierung ([Microsoft.AspNetCore.Authentication.MicrosoftAccount](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.MicrosoftAccount))
  * OpenID Connect-Authentifizierung ([Microsoft.AspNetCore.Authentication.OpenIdConnect](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.OpenIdConnect))
  * OpenID Connect-Trägertoken ([Microsoft.AspNetCore.Authentication.JwtBearer](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.JwtBearer))
  * Twitter OAuth ([Microsoft.AspNetCore.Authentication.Twitter](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Twitter))
  * WsFederation-Authentifizierung ([Microsoft.AspNetCore.Authentication.WsFederation](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.WsFederation))

* Formatierungs- und `System.Net.HttpClient` &ndash; Inhaltsaushandlungsunterstützung für das [Microsoft.AspNet.WebApi.Client](https://www.nuget.org/packages/Microsoft.AspNet.WebApi.Client/) NuGet-Paket bietet nützliche Erweiterbarkeit `System.Net.HttpClient` für mit APIs wie `ReadAsAsync` und `PostJsonAsync`.

* Razor-Laufzeitkompilierung &ndash; Unterstützung für die Laufzeitkompilierung von Razor-Ansichten und -Seiten ist jetzt Teil von [Microsoft.AspNetCore.Mvc.Razor.RuntimeCompilation](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Razor.RuntimeCompilation).

* MVC `Newtonsoft.Json` (Json.NET) &ndash; Unterstützung unterstützung für `Newtonsoft.Json` die Verwendung von MVC mit ist jetzt Teil von [Microsoft.AspNetCore.Mvc.NewtonsoftJson](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson).

## <a name="startup-changes"></a>Anlaufänderungen

Die folgende Abbildung zeigt die gelöschten und geänderten Zeilen in einer ASP.NET Core 2.2 Razor Pages Web-App:

![die gelöschten und geänderten Zeilen in einer ASP.NET Core 2.2 Razor Web-App](22-to-30/_static/startup2.2.png)

In der obigen Abbildung wird gelöschter Code rot dargestellt. Der gelöschte Code zeigt keinen Cookie-Optionscode an, der vor dem Vergleich der Dateien gelöscht wurde.

Die folgende Abbildung zeigt die hinzugefügten und geänderten Zeilen in einer ASP.NET Core 3.0 Razor Pages-Web-App:

![die hinzugefügten und geänderten Zeilen in einer ASP.NET Core 3.0 Razor Web-App](22-to-30/_static/startup3.0.png)

In der obigen Abbildung wird hinzugefügter Code grün dargestellt. Weitere Informationen zu den folgenden Änderungen:

* `services.AddMvc`zu `services.AddRazorPages`, siehe [MVC-Dienstregistrierung](#mvc-service-registration) in diesem Dokument.
* `CompatibilityVersion`, <xref:mvc/compatibility-version>siehe .
* `IHostingEnvironment`in `IWebHostEnvironment`, siehe [diese GitHub-Ankündigung](https://github.com/dotnet/AspNetCore/issues/7749).
* `app.UseAuthorization`wurde den Vorlagen hinzugefügt, um anzuzeigen, dass die Orderautorisierungs-Middleware hinzugefügt werden muss. Wenn die App keine Autorisierung verwendet, können Sie `app.UseAuthorization`den Aufruf von sicher entfernen.
* `app.UseEndpoints`, siehe [Razor Pages](#razor-pages) oder [Migrate Startup.Configure](#migrate-startupconfigure) in diesem Dokument.

### <a name="analyzer-support"></a>Analyzer-Unterstützung

Projekte, `Microsoft.NET.Sdk.Web` die implizit auf Analyser verweisen, die zuvor als Teil des [Microsoft.AspNetCore.Mvc.Analyzers-Pakets](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Analyzers/) ausgeliefert wurden. Es sind keine zusätzlichen Referenzen erforderlich, um diese zu aktivieren.

Wenn Ihre App [API-Analysatoren](xref:web-api/advanced/analyzers) verwendet, die zuvor mit dem [Microsoft.AspNetCore.Mvc.Api.Analyzers-Paket](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Api.Analyzers/) ausgeliefert wurden, bearbeiten Sie Ihre Projektdatei, um auf die Imasatoren zu verweisen, die als Teil des .NET Core Web SDK ausgeliefert werden:

```xml
<Project Sdk="Microsoft.NET.Sdk.Web">
    <PropertyGroup>
        <TargetFramework>netcoreapp3.0</TargetFramework>
        <IncludeOpenAPIAnalyzers>true</IncludeOpenAPIAnalyzers>
    </PropertyGroup>

    ...
</Project>
```

### <a name="razor-class-library"></a>Razor-Klassenbibliothek

Razor-Klassenbibliotheksprojekte, die UI-Komponenten `AddRazorSupportForMvc` für MVC bereitstellen, müssen die Eigenschaft in der Projektdatei festlegen:

```xml
<PropertyGroup>
  <AddRazorSupportForMvc>true</AddRazorSupportForMvc>
</PropertyGroup>
```

### <a name="in-process-hosting-model"></a>In-Process-Hostingmodell

Projekte verwenden standardmäßig das [prozessübergreifende Hostingmodell](xref:host-and-deploy/aspnet-core-module#in-process-hosting-model) in ASP.NET Core 3.0 oder höher. Sie können die `<AspNetCoreHostingModel>` Eigenschaft in der Projektdatei `InProcess`optional entfernen, wenn ihr Wert ist.

## <a name="kestrel"></a>Kestrel

### <a name="configuration"></a>Konfiguration

Migrieren der Kestrel-Konfiguration `ConfigureWebHostDefaults` zum Webhost-Generator, der von (*Program.cs)* bereitgestellt wird

```csharp
public static IHostBuilder CreateHostBuilder(string[] args) =>
    Host.CreateDefaultBuilder(args)
        .ConfigureWebHostDefaults(webBuilder =>
        {
            webBuilder.ConfigureKestrel(serverOptions =>
            {
                // Set properties and call methods on options
            })
            .UseStartup<Startup>();
        });
```

Wenn die App den Host `HostBuilder`manuell `UseKestrel` mit erstellt, `ConfigureWebHostDefaults`rufen Sie den Webhost-Builder in :

```csharp
public static void Main(string[] args)
{
    var host = new HostBuilder()
        .UseContentRoot(Directory.GetCurrentDirectory())
        .ConfigureWebHostDefaults(webBuilder =>
        {
            webBuilder.UseKestrel(serverOptions =>
            {
                // Set properties and call methods on options
            })
            .UseIISIntegration()
            .UseStartup<Startup>();
        })
        .Build();

    host.Run();
}
```

### <a name="connection-middleware-replaces-connection-adapters"></a>Verbindungsmiddleware ersetzt Verbindungsadapter

Verbindungsadapter (`Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.IConnectionAdapter`) wurden aus Kestrel entfernt. Ersetzen Sie Verbindungsadapter durch Verbindungsmiddleware. Connection Middleware ähnelt HTTP Middleware in der ASP.NET Core-Pipeline, jedoch für Verbindungen auf niedrigerer Ebene. HTTPS und Verbindungsprotokollierung:

* Wurden von Verbindungsadaptern zu Verbindungsmiddleware verschoben.
* Diese Erweiterungsmethoden funktionieren wie in früheren Versionen von ASP.NET Core. 

Weitere Informationen finden Sie [im Beispiel TlsFilterConnectionHandler im Abschnitt ListenOptions.Protocols des Artikels Kestrel](/aspnet/core/fundamentals/servers/kestrel?view=aspnetcore-3.0#listenoptionsprotocols).

### <a name="transport-abstractions-moved-and-made-public"></a>Transportabstraktionen verschoben und öffentlich gemacht

Die Kestrel-Transportschicht wurde in `Connections.Abstractions` als öffentliche Schnittstelle verfügbar gemacht. Im Rahmen dieser Updates:

* `Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions`und zugehörigeTypen wurden entfernt.
* <xref:Microsoft.AspNetCore.Server.Kestrel.KestrelServerOptions.NoDelay>wurde von <xref:Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions> den Transportoptionen verschoben.
* `Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions.Internal.SchedulingMode`wurde aus <xref:Microsoft.AspNetCore.Server.Kestrel.KestrelServerOptions>entfernt.

Weitere Informationen finden Sie in den folgenden GitHub-Ressourcen:

* [Client/Server-Netzwerkabstraktionen (dotnet/AspNetCore #10308)](https://github.com/dotnet/AspNetCore/issues/10308)
* [Implementieren Sie neue Grundgesteins-Listener-Abstraktion und replat Kestrel oben (dotnet/AspNetCore #10321)](https://github.com/dotnet/AspNetCore/pull/10321)

### <a name="kestrel-request-trailer-headers"></a>Kestrel-Trailer-Header anfordern

Für Apps, die auf frühere Versionen von ASP.NET Core abzielen:

* Kestrel fügt der Anforderungsheadersammlung HTTP/1.1-Header-Header hinzu.
* Anhänger sind verfügbar, nachdem der Anforderungstext bis zum Ende gelesen wurde.

Dies führt zu einigen Bedenken hinsichtlich der Mehrdeutigkeit zwischen Headern und Trailern, so dass die Trailer in eine neue Kollektion (`RequestTrailerExtensions`) in 3.0 verschoben wurden.

HTTP/2-Anforderungs-Trailer sind:

* Nicht verfügbar in ASP.NET Core 2.2.
* Erhältlich in 3.0 als `RequestTrailerExtensions`.

Für den Zugriff auf diese Anhänger sind neue Methoden zur Anforderungserweiterung vorhanden. Wie bei HTTP/1.1 sind Trailer verfügbar, nachdem der Anforderungstext bis zum Ende gelesen wurde.

Für die Version 3.0 `RequestTrailerExtensions` stehen die folgenden Methoden zur Verfügung:

* `GetDeclaredTrailers`&ndash; Ruft den `Trailer` Anforderungsheader ab, der auflistet, welche Trailer nach dem Körper erwartet werden sollen.
* `SupportsTrailers`&ndash; Gibt an, ob die Anforderung den Empfang von Trailer-Headern unterstützt.
* `CheckTrailersAvailable`&ndash; Überprüft, ob die Anforderung Trailer unterstützt und ob sie zum Lesen verfügbar sind. Bei dieser Prüfung wird nicht davon ausgegangen, dass Trailer zu lesen sind. Es gibt möglicherweise keine Trailer `true` zu lesen, auch wenn von dieser Methode zurückgegeben wird.
* `GetTrailer`&ndash; Ruft den angeforderten Trailing-Header aus der Antwort ab. Überprüfen `SupportsTrailers` Sie `GetTrailer`vor <xref:System.NotSupportedException> dem Aufruf , oder es kann vorkommen, dass die Anforderung keine nachgestellten Header unterstützt.

Weitere Informationen finden Sie unter [Stellen von Anforderungs-Trailern in einer separaten Sammlung (dotnet/AspNetCore #10410).](https://github.com/dotnet/AspNetCore/pull/10410)

### <a name="allowsynchronousio-disabled"></a>AllowSynchronousIO deaktiviert

`AllowSynchronousIO`aktiviert oder deaktiviert synchrone E/A-APIs, z. `HttpRequest.Body.Read`B. , `HttpResponse.Body.Write`und `Stream.Flush`. Diese APIs sind eine Quelle von Threadhunger, was zu App-Abstürzen führt. In 3.0 ist `AllowSynchronousIO` standardmäßig deaktiviert. Weitere Informationen finden Sie [im Abschnitt Synchrone E/A im Kestrel-Artikel](/aspnet/core/fundamentals/servers/kestrel?view=aspnetcore-3.0#synchronous-io).

Wenn synchrone E/A-E-Nachrichten benötigt werden, kann diese aktiviert werden, indem die `AllowSynchronousIO` Option auf dem verwendeten Server konfiguriert wird (z. B. beim Aufruf `ConfigureKestrel`von Kestrel). Beachten Sie, dass Server (Kestrel, HttpSys, TestServer `AllowSynchronousIO` usw.) alle über eine eigene Option verfügen, die sich nicht auf andere Server auswirkt. Synchrone E/A-Nachrichten können für alle Server pro `IHttpBodyControlFeature.AllowSynchronousIO` Anforderung aktiviert werden, indem sie die Option verwendet:

```csharp
var syncIOFeature = HttpContext.Features.Get<IHttpBodyControlFeature>();

if (syncIOFeature != null)
{
    syncIOFeature.AllowSynchronousIO = true;
}
```

Wenn Sie Probleme <xref:System.IO.TextWriter> mit Implementierungen oder anderen Streams haben, die <xref:System.IO.Stream.DisposeAsync*> synchrone APIs in [Dispose](/dotnet/standard/garbage-collection/implementing-dispose)aufrufen, rufen Sie stattdessen die neue API auf.

Weitere Informationen finden Sie unter [[Ankündigung] AllowSynchronousIO deaktiviert auf allen Servern (dotnet/AspNetCore #7644)](https://github.com/dotnet/AspNetCore/issues/7644).

### <a name="microsoftaspnetcoreserverkestrelhttps-assembly-removed"></a>Microsoft.AspNetCore.Server.Kestrel.Https-Assembly entfernt

In ASP.NET Core 2.1 wurde der Inhalt von *Microsoft.AspNetCore.Server.Kestrel.Https.dll* in *Microsoft.AspNetCore.Server.Kestrel.Core.dll*verschoben. Dies war eine nicht `TypeForwardedTo` brechende Aktualisierung mit Attributen. Für 3.0 wurden die leere *Microsoft.AspNetCore.Server.Kestrel.Https.dll-Assembly* und das NuGet-Paket entfernt.

Bibliotheken, die auf [Microsoft.AspNetCore.Server.Kestrel.Https](https://www.nuget.org/packages/Microsoft.AspNetCore.Server.Kestrel.Https) verweisen, sollten ASP.NET Core-Abhängigkeiten auf 2.1 oder höher aktualisieren.

Apps und Bibliotheken, die auf ASP.NET Core 2.1 oder höher abzielen, sollten alle direkten Verweise auf das [Microsoft.AspNetCore.Server.Kestrel.Https-Paket](https://www.nuget.org/packages/Microsoft.AspNetCore.Server.Kestrel.Https) entfernen.

<a id="jsonnet-support"></a>

## <a name="newtonsoftjson-jsonnet-support"></a>Newtonsoft.Json (Json.NET) Unterstützung

Im Rahmen der Arbeiten zur [Verbesserung des ASP.NET Core Shared Framework](https://blogs.msdn.microsoft.com/webdev/2018/10/29/a-first-look-at-changes-coming-in-asp-net-core-3-0/)wurde [Newtonsoft.Json (Json.NET)](https://www.newtonsoft.com/json/help/html/Introduction.htm) aus dem ASP.NET Core Shared Framework entfernt.

Der standardmäßige JSON-Serialisierungsmodul für ASP.NET Core ist jetzt <xref:System.Text.Json>, was in .NET Core 3.0 neu ist. Erwägen `System.Text.Json` Sie, wenn möglich, die Verwendung in Betracht zu ziehen. Es ist leistungsstark und erfordert keine zusätzliche Bibliotheksabhängigkeit. Da `System.Text.Json` es jedoch neu ist, fehlen derzeit möglicherweise Funktionen, die Ihre App benötigt. Weitere Informationen finden Sie unter [Migrieren von Newtonsoft.Json zu System.Text.Json](/dotnet/standard/serialization/system-text-json-migrate-from-newtonsoft-how-to).

### <a name="use-newtonsoftjson-in-an-aspnet-core-30-opno-locsignalr-project"></a>Verwenden von Newtonsoft.Json in einem SignalR ASP.NET Core 3.0-Projekt

* Installieren Sie [SignalRMicrosoft.AspNetCore. . Protocols.NewtonsoftJson](https://www.nuget.org/packages/Microsoft.AspNetCore.SignalR.Protocols.NewtonsoftJson) NuGet-Paket.

* Verketten Sie auf `AddNewtonsoftJsonProtocol` dem Client `HubConnectionBuilder` einen Methodenaufruf für die Instanz:

  ```csharp
  new HubConnectionBuilder()
      .WithUrl("/chatHub")
      .AddNewtonsoftJsonProtocol(...)
      .Build();
  ```

* Verketten Sie auf `AddNewtonsoftJsonProtocol` dem Server `AddSignalR` einen `Startup.ConfigureServices`Methodenaufruf für den Methodenaufruf in:

  ```csharp
  services.AddSignalR()
      .AddNewtonsoftJsonProtocol(...);
  ```

### <a name="use-newtonsoftjson-in-an-aspnet-core-30-mvc-project"></a>Verwenden von Newtonsoft.Json in einem ASP.NET Core 3.0 MVC-Projekt

* Installieren Sie das [Microsoft.AspNetCore.Mvc.NewtonsoftJson-Paket.](https://nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson)

* Aktualisieren, `Startup.ConfigureServices` `AddNewtonsoftJson`um aufzurufen .

  ```csharp
  services.AddMvc()
      .AddNewtonsoftJson();
  ```

  `AddNewtonsoftJson`ist mit den neuen MVC-Dienstregistrierungsmethoden kompatibel:

  * `AddRazorPages`
  * `AddControllersWithViews`
  * `AddControllers`

  ```csharp
  services.AddControllers()
      .AddNewtonsoftJson();
  ```

  `Newtonsoft.Json`Einstellungen können im Aufruf `AddNewtonsoftJson`eingestellt werden:

  ```csharp
  services.AddMvc()
      .AddNewtonsoftJson(options =>
             options.SerializerSettings.ContractResolver =
                new CamelCasePropertyNamesContractResolver());
  ```

**Hinweis:** Wenn `AddNewtonsoftJson` die Methode nicht verfügbar ist, stellen Sie sicher, dass Sie das [Microsoft.AspNetCore.Mvc.NewtonsoftJson-Paket](https://nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson) installiert haben. Ein häufiger Fehler ist, das [Paket Newtonsoft.Json](https://www.nuget.org/packages/Newtonsoft.Json/) anstelle des [Microsoft.AspNetCore.Mvc.NewtonsoftJson-Pakets](https://nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson) zu installieren.

## <a name="mvc-service-registration"></a>MVC-Dienstregistrierung

ASP.NET Core 3.0 fügt neue Optionen für `Startup.ConfigureServices`die Registrierung von MVC-Szenarien innerhalb hinzu.

Es `IServiceCollection` stehen drei neue Erweiterungsmethoden der obersten Ebene im Zusammenhang mit MVC-Szenarien zur Verfügung. Vorlagen verwenden diese neuen `AddMvc`Methoden anstelle von . Verhält `AddMvc` sich jedoch weiterhin wie in früheren Versionen.

Im folgenden Beispiel wird Unterstützung für Controller und API-bezogene Features, jedoch keine Ansichten oder Seiten hinzugefügt. Die API-Vorlage verwendet diesen Code:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllers();
}
```

Im folgenden Beispiel wird Unterstützung für Controller, API-bezogene Features und Ansichten, jedoch keine Seiten hinzugefügt. Die Web Application (MVC)-Vorlage verwendet diesen Code:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllersWithViews();
}
```

Im folgenden Beispiel wird Unterstützung für Razor Pages und minimale Controllerunterstützung hinzugefügt. Die Webanwendungsvorlage verwendet diesen Code:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddRazorPages();
}
```

Die neuen Methoden können auch kombiniert werden. Das folgende Beispiel entspricht `AddMvc` dem Aufruf in ASP.NET Core 2.2:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllersWithViews();
    services.AddRazorPages();
}
```

## <a name="routing-startup-code"></a>Routing-Startcode

Wenn eine `UseMvc` App `UseSignalR`aufruft oder , migrieren Sie die App nach Möglichkeit nach [Endpoint Routing.](xref:fundamentals/routing) Um die Endpoint-Routing-Kompatibilität mit früheren MVC-Versionen zu verbessern, haben wir einige der in ASP.NET Core 2.2 eingeführten Änderungen in der URL-Generierung rückgängig gemacht. Wenn bei der Verwendung von Endpoint Routing in 2.2 Probleme auftreten, erwarten Sie Verbesserungen in ASP.NET Core 3.0 mit den folgenden Ausnahmen:

* Wenn die App `IRouter` DynamicRouteValuesTransformer `Route`implementiert oder erbt, verwenden Sie [DynamicRouteValuesTransformer](https://github.com/dotnet/AspNetCore.Docs/issues/12997) als Ersatz.
* Wenn die App `RouteData.Routers` direkt innerhalb von MVC auf das Analysieren von URLs zugreift, können Sie diese durch die Verwendung von [LinkParser.ParsePathByEndpointName](xref:Microsoft.AspNetCore.Routing.LinkParserEndpointNameAddressExtensions.ParsePathByEndpointName*)ersetzen. 
  * Definieren Sie die Route mit einem Routennamen.
  * Verwenden `LinkParser.ParsePathByEndpointName` und übergeben Sie den gewünschten Routennamen.

Endpoint Routing unterstützt die gleiche Routenmustersyntax und `IRouter`Routenmustererstellungsfeatures wie . Endpoint Routing `IRouteConstraint`unterstützt . Das Endpunktrouting unterstützt `[Route]`, `[HttpGet]`und die anderen MVC-Routingattribute.

Für die meisten `Startup` Anwendungen sind nur Änderungen erforderlich.

### <a name="migrate-startupconfigure"></a>Migration von Startup.Configure

Allgemeine Beratung:

* Fügen Sie `UseRouting`hinzu.
* Wenn die `UseStaticFiles`App `UseStaticFiles` aufruft, platzieren Sie **vor** `UseRouting`.
* Wenn die App Authentifizierungs-/Autorisierungsfunktionen `AuthorizePage` wie oder `[Authorize]`verwendet, `UseCors`platzieren `UseEndpoints`Sie den Aufruf an `UseAuthentication` und `UseAuthorization`: **nach** `UseRouting` , und , jedoch vor :

  ```csharp
  public void Configure(IApplicationBuilder app)
  {
    ...

    app.UseStaticFiles();

    app.UseRouting();
    app.UseCors();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints => {
       endpoints.MapControllers();
    });
  ```

* Ersetzen `UseMvc` `UseSignalR` oder `UseEndpoints`mit .
* Wenn die App [CORS-Szenarien](xref:security/cors) verwendet, `[EnableCors]`z. B. , platzieren Sie den Aufruf `UseCors` `UseAuthentication` `UseCors` vor `UseAuthorization`jeder `UseEndpoints`anderen Middleware, die CORS verwendet (z. B. platzieren Sie vor , und ).
* Ersetzen `IHostingEnvironment` `IWebHostEnvironment` Sie diese `using` durch, <xref:Microsoft.Extensions.Hosting?displayProperty=fullName> und fügen Sie eine Anweisung für den Namespace hinzu.
* Ersetzen `IApplicationLifetime` <xref:Microsoft.Extensions.Hosting.IHostApplicationLifetime> Sie<xref:Microsoft.Extensions.Hosting?displayProperty=fullName> dies durch (Namespace).
* Ersetzen `EnvironmentName` <xref:Microsoft.Extensions.Hosting.Environments> Sie<xref:Microsoft.Extensions.Hosting?displayProperty=fullName> dies durch (Namespace).

Der folgende Code ist `Startup.Configure` ein Beispiel für eine typische ASP.NET Core 2.2-App:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseStaticFiles();

    app.UseAuthentication();

    app.UseSignalR(hubs =>
    {
        hubs.MapHub<ChatHub>("/chat");
    });

    app.UseMvc(routes =>
    {
        routes.MapRoute("default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

Nach der `Startup.Configure` Aktualisierung des vorherigen Codes:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseStaticFiles();

    app.UseRouting();

    app.UseCors();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>("/chat");
        endpoints.MapControllerRoute("default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

> [!WARNING]
> Bei den meisten `UseAuthentication`Apps `UseAuthorization`ruft `UseCors` sie an , `UseRouting` `UseEndpoints` auf und muss zwischen den Aufrufen an und der enthatonen Anzeige angezeigt werden, um wirksam zu sein.

### <a name="health-checks"></a>Integritätsprüfungen

Integritätsprüfungen verwenden das Endpunktrouting mit dem generischen Host. Rufen Sie in `Startup.Configure` auf der Endpunkterstellung mit der Endpunkt-URL oder dem relativen Pfad `MapHealthChecks` auf:

```csharp
app.UseEndpoints(endpoints =>
{
    endpoints.MapHealthChecks("/health");
});
```

Für Endpunkte für Integritätsprüfungen gilt Folgendes:

* Sie geben mindestens einen zugelassenen Host oder Port an.
* Sie erfordern Autorisierung.
* Sie erfordern CORS.

Weitere Informationen finden Sie unter <xref:host-and-deploy/health-checks>.

### <a name="security-middleware-guidance"></a>Anleitung zur Sicherheits-Middleware

Die Unterstützung für Autorisierung und CORS ist im [Middleware-Ansatz](xref:fundamentals/middleware/index) einheitlich. Dies ermöglicht die Verwendung der gleichen Middleware und Funktionalität in diesen Szenarien. In dieser Version wird eine aktualisierte Autorisierungsmiddleware bereitgestellt, und CORS Middleware wird erweitert, damit sie die von MVC-Controllern verwendeten Attribute verstehen kann.

#### <a name="cors"></a>CORS

Bisher war die Konfiguration von CORS schwierig. Middleware wurde für den Einsatz in einigen Anwendungsfällen zur Verfügung gestellt, aber MVC-Filter sollten **ohne** die Middleware in anderen Anwendungsfällen verwendet werden. Mit ASP.NET Core 3.0 empfehlen wir, dass alle Apps, die CORS benötigen, die CORS Middleware zusammen mit Endpoint Routing verwenden. `UseCors`kann mit einer Standardrichtlinie `[EnableCors]` bereitgestellt `[DisableCors]` werden, und Attribute können verwendet werden, um die Standardrichtlinie bei Bedarf zu überschreiben.

Siehe folgendes Beispiel:

* CORS ist für alle Endpunkte mit der `default` benannten Richtlinie aktiviert.
* Die `MyController` Klasse deaktiviert CORS `[DisableCors]` mit dem Attribut.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseCors("default");

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

[DisableCors]
public class MyController : ControllerBase
{
    ...
}
```

#### <a name="authorization"></a>Authorization

In früheren Versionen von ASP.NET Core wurde `[Authorize]` die Autorisierungsunterstützung über das Attribut bereitgestellt. Autorisierungsmiddleware war nicht verfügbar. In ASP.NET Core 3.0 ist eine Autorisierungs-Middleware erforderlich. Wir empfehlen, die ASP.NET Core`UseAuthorization`Authorization `UseAuthentication`Middleware ( ) unmittelbar nach zu platzieren. Die Authorization Middleware kann auch mit einer Standardrichtlinie konfiguriert werden, die überschrieben werden kann.

In ASP.NET Core 3.0 `UseAuthorization` oder `Startup.Configure`höher, wird `HomeController` in aufgerufen, und Folgendes erfordert einen angemeldeten Benutzer:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

public class HomeController : Controller
{
    [Authorize]
    public IActionResult BuyWidgets()
    {
        ...
    }
}
```

Bei der Verwendung von Endpunktrouting wird empfohlen, sich nicht zu konfigurieren `<xref:Microsoft.AspNetCore.Mvc.Authorization.AuthorizeFilter>` und sich stattdessen auf die Autorisierungsmiddleware zu verlassen.  Wenn die App `AuthorizeFilter` einen als globalen Filter in MVC verwendet, wird empfohlen, den `AddAuthorization`Code umzugestalten, um eine Richtlinie im Aufruf von bereitzustellen.

Der `DefaultPolicy` ist zunächst so konfiguriert, dass eine Authentifizierung erforderlich ist, sodass keine zusätzliche Konfiguration erforderlich ist. Im folgenden Beispiel werden MVC-Endpunkte so `RequireAuthorization` markiert, dass alle `DefaultPolicy`Anforderungen basierend auf der autorisiert werden müssen. Die erlaubt `HomeController` jedoch den Zugriff, ohne dass `[AllowAnonymous]`sich der Benutzer bei der App anmeldet, aufgrund von:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute().RequireAuthorization();
    });
}

[AllowAnonymous]
public class HomeController : Controller
{
    ...
}
```

### <a name="authorization-for-specific-endpoints"></a>Autorisierung für bestimmte Endpunkte

Die Autorisierung kann auch für bestimmte Klassen von Endpunkten konfiguriert werden. Der folgende Code ist ein Beispiel für das Konvertieren `AuthorizeFilter` einer MVC-App, die eine globale in eine App mit einer bestimmten Richtlinie konfiguriert hat, die eine Autorisierung erfordert:

[!code-csharp[](22-to-30/samples/Startup.cs?name=snippet&highlight=8-9,21-22,26-27,53-54)]

Richtlinien können auch angepasst werden. Der `DefaultPolicy` ist so konfiguriert, dass eine Authentifizierung erforderlich ist:

[!code-csharp[](22-to-30/samples/Startup2.cs?name=snippet&highlight=21-26,52)]

[!code-csharp[](22-to-30/samples/HomeController.cs?name=snippet)]

Alternativ können alle Endpunkte so konfiguriert werden, `RequireAuthorization` dass `FallbackPolicy`sie eine Autorisierung erfordern, ohne `[Authorize]` oder durch Konfigurieren einer . Die `FallbackPolicy` unterscheidet sich `DefaultPolicy`von der . Der `DefaultPolicy` wird `[Authorize]` von `RequireAuthorization`oder `FallbackPolicy` ausgelöst, während der ausgelöst wird, wenn keine andere Richtlinie festgelegt ist. `FallbackPolicy`ist zunächst so konfiguriert, dass Anforderungen ohne Autorisierung zugelassen werden.

Das folgende Beispiel ist das `DefaultPolicy` gleiche wie `FallbackPolicy` das vorherige Beispiel, verwendet `[AllowAnonymous]` jedoch die, um immer eine Authentifizierung für alle Endpunkte zu verlangen, außer wenn angegeben ist:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    ...

    services.AddAuthorization(options =>
    {
        options.FallbackPolicy = new AuthorizationPolicyBuilder()
          .RequireAuthenticatedUser()
          .Build();
    });
}

public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

[AllowAnonymous]
public class HomeController : Controller
{
    ...
}
```

Die Autorisierung durch Middleware funktioniert ohne spezifische Kenntnisse des Frameworks. Beispielsweise verfügen [Integritätsprüfungen](xref:host-and-deploy/health-checks) nicht über spezifische Kenntnisse der Autorisierung, aber Integritätsprüfungen können eine konfigurierbare Autorisierungsrichtlinie haben, die von der Middleware angewendet wird.

Darüber hinaus kann jeder Endpunkt seine Autorisierungsanforderungen anpassen. Im folgenden Beispiel `UseAuthorization` verarbeitet die `DefaultPolicy`Autorisierung `/healthz` mit dem , `admin` aber der Endpunkt der Integritätsprüfung erfordert einen Benutzer:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints
            .MapHealthChecks("/healthz")
            .RequireAuthorization(new AuthorizeAttribute(){ Roles = "admin", });
    });
}
```

Der Schutz ist für einige Szenarien implementiert. Endpoints Middleware löst eine Ausnahme aus, wenn eine Autorisierung oder CORS-Richtlinie aufgrund fehlender Middleware übersprungen wird. Die Analyzer-Unterstützung zur Bereitstellung zusätzlicher Rückmeldungen zu Fehlkonfigurationen ist im Gange.

#### <a name="custom-authorization-handlers"></a>Benutzerdefinierte Autorisierungshandler

Wenn die App benutzerdefinierte [Autorisierungshandler](xref:security/authorization/policies#authorization-handlers)verwendet, übergibt das Endpunktrouting einen anderen Ressourcentyp an Handler als MVC. Handler, die erwarten, dass die Kontextressource des Autorisierungshandlers vom Typ <xref:Microsoft.AspNetCore.Mvc.Filters.AuthorizationFilterContext> ist (der von <xref:Microsoft.AspNetCore.Routing.RouteEndpoint> [MVC-Filtern bereitgestellte](xref:security/authorization/policies#accessing-mvc-request-context-in-handlers)Ressourcentyp), müssen aktualisiert werden, um Ressourcen des Typs zu verarbeiten (der Ressourcentyp, der Autorisierungshandlern durch Endpunktrouting gegeben wird).

MVC verwendet `AuthorizationFilterContext` weiterhin Ressourcen. Wenn die App also MVC-Autorisierungsfilter zusammen mit der Endpunktroutingautorisierung verwendet, kann es erforderlich sein, beide Arten von Ressourcen zu behandeln.

### SignalR

Die SignalR Zuordnung von Hubs `UseEndpoints`findet nun innerhalb von statt.

Ordnen Sie `MapHub`jeden Hub mit zu. Wie in früheren Versionen wird jeder Hub explizit aufgelistet.

Im folgenden Beispiel wird `ChatHub` SignalR die Unterstützung für den Hub hinzugefügt:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>();
    });
}
```

Es gibt eine neue Option zum Steuern von Nachrichtengrößenbeschränkungen von Clients. Gehen Sie beispielsweise in `Startup.ConfigureServices` folgendermaßen vor:

```csharp
services.AddSignalR(hubOptions =>
{
    hubOptions.MaximumReceiveMessageSize = 32768;
});
```

In ASP.NET Core 2.2 können `TransportMaxBufferSize` Sie die und das würde effektiv die maximale Nachrichtengröße steuern. In ASP.NET Core 3.0 steuert diese Option jetzt nur noch die maximale Größe, bevor der Gegendruck beobachtet wird.

### <a name="mvc-controllers"></a>MVC-Controller

Die Zuordnung der Controller `UseEndpoints`findet nun innerhalb von statt.

Fügen `MapControllers` Sie hinzu, wenn die App Attributrouting verwendet. Da Routing Unterstützung für viele Frameworks in ASP.NET Core 3.0 oder höher enthält, ist das Hinzufügen von attributgerouteten Controllern Opt-in.

Ersetzen Sie Folgendes:

* `MapRoute` mit `MapControllerRoute`
* `MapAreaRoute` mit `MapAreaControllerRoute`

Da Routing jetzt mehr als nur MVC unterstützt, hat sich die Terminologie geändert, damit diese Methoden klar angeben, was sie tun. Herkömmliche Routen, `MapControllerRoute` / `MapAreaControllerRoute` / `MapDefaultControllerRoute` wie sie in der Reihenfolge angewendet werden, in der sie hinzugefügt werden. Platzieren Sie zuerst spezifischere Routen (z. B. Routen für ein Gebiet).

Siehe folgendes Beispiel:

* `MapControllers`unterstützt attributegeroutete Controller.
* `MapAreaControllerRoute`eine herkömmliche Route für Steuerungen in einem Gebiet hinzugefügt.
* `MapControllerRoute`eine herkömmliche Route für Controller.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapControllers();
        endpoints.MapAreaControllerRoute(
            "admin",
            "admin",
            "Admin/{controller=Home}/{action=Index}/{id?}");
        endpoints.MapControllerRoute(
            "default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

#### <a name="async-suffix-removal-from-controller-action-names"></a>Async-Suffix-Entfernung aus Controller-Aktionsnamen

In ASP.NET Core 3.0 entfernt ASP.NET `Async` Core MVC das Suffix aus Controlleraktionsnamen. Sowohl die Routing- als auch die Verbindungsgenerierung sind von dieser neuen Standardeinstellung betroffen. Beispiel:

```csharp
public class ProductsController : Controller
{
    public async Task<IActionResult> ListAsync()
    {
        var model = await _dbContext.Products.ToListAsync();
        return View(model);
    }
}
```

Vor ASP.NET Core 3.0:

* Auf die vorherige Aktion konnte auf der *Route Products/ListAsync* zugegriffen werden.
* Linkgenerierung erforderlich, `Async` um das Suffix anzugeben. Beispiel:

    ```cshtml
    <a asp-controller="Products" asp-action="ListAsync">List</a>
    ```

In ASP.NET Core 3.0:

* Auf die vorherige Aktion kann auf der Route *Produkte/Liste* zugegriffen werden.
* Für die Linkgenerierung ist `Async` das Suffix nicht anzugeben. Beispiel:

    ```cshtml
    <a asp-controller="Products" asp-action="List">List</a>
    ```

Diese Änderung wirkt sich nicht [`[ActionName]`](/dotnet/api/microsoft.aspnetcore.mvc.actionnameattribute) auf Die mit dem Attribut angegebenen Namen aus. Das Standardverhalten kann mit folgendem `Startup.ConfigureServices`Code in deaktiviert werden:

```csharp
services.AddMvc(options =>
    options.SuppressAsyncSuffixInActionNames = false);
```

#### <a name="changes-to-link-generation"></a>Änderungen bei der Linkgenerierung

Wie in der Dokumentation zu [Unterschieden zu früheren Versionen des Routings](xref:fundamentals/routing#differences-from-earlier-versions-of-routing)erläutert, gibt es einige Unterschiede bei der Linkgenerierung (z. B. verwendungs- `Url.Link` und ähnliche APIs). Dazu gehören:

* Standardmäßig wird bei der Verwendung von Endpunktrouting die Groß-/Kleinschreibung von Routenparametern in generierten URIs nicht unbedingt beibehalten. Dieses Verhalten kann mit `IOutboundParameterTransformer` der Schnittstelle gesteuert werden.
* Das Generieren eines URI für eine ungültige Route (ein Controller/eine Aktion oder seite, die nicht vorhanden ist) erzeugt eine leere Zeichenfolge unter Endpunktrouting, anstatt einen ungültigen URI zu erzeugen.
* Umgebungswerte (Routenparameter aus dem aktuellen Kontext) werden nicht automatisch bei der Linkgenerierung mit Endpunktrouting verwendet. Zuvor wurden beim Generieren eines Links zu einer anderen Aktion (oder Seite) nicht angegebene Routenwerte aus den *aktuellen* Routenumgebungswerten abgeleitet. Bei der Verwendung des Endpunktroutings müssen alle Routenparameter während der Linkgenerierung explizit angegeben werden.

### <a name="razor-pages"></a>Razor Pages

Das Mapping von Razor-Seiten findet jetzt innerhalb von statt. `UseEndpoints`

Fügen `MapRazorPages` Sie hinzu, wenn die App Razor Pages verwendet. Da Endpoint Routing Unterstützung für viele Frameworks bietet, ist das Hinzufügen von Razor Pages jetzt Opt-in.

In der `Startup.Configure` folgenden `MapRazorPages` Methode wird Unterstützung für Razor Pages hinzugefügt:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapRazorPages();
    });
}
```

### <a name="use-mvc-without-endpoint-routing"></a>MVC ohne Endpunktrouting verwenden

Die Verwendung `UseMvc` von `UseMvcWithDefaultRoute` MVC über oder in ASP.NET Core `Startup.ConfigureServices`3.0 erfordert ein explizites Opt-in innerhalb . Dies ist erforderlich, da MVC wissen muss, ob es sich während der Initialisierung auf die Autorisierung und CORS Middleware verlassen kann. Es wird ein Analyzer bereitgestellt, der warnt, wenn die App versucht, eine nicht unterstützte Konfiguration zu verwenden.

Wenn die App `IRouter` Unterstützung `EnableEndpointRouting` für ältere Personen benötigt, deaktivieren Sie die Verwendung eines der folgenden Ansätze in: `Startup.ConfigureServices`

```csharp
services.AddMvc(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddControllers(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddControllersWithViews(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddRazorPages().AddMvcOptions(options => options.EnableEndpointRouting = false);
```

### <a name="health-checks"></a>Integritätsüberprüfungen

Zustandsprüfungen können als *Router-Ware* mit Endpoint Routing verwendet werden.

Hinzufügen, `MapHealthChecks` um Zustandsprüfungen mit Endpoint Routing zu verwenden. Die `MapHealthChecks` Methode akzeptiert `UseHealthChecks`Argumente ähnlich . Der Vorteil `MapHealthChecks` der `UseHealthChecks` Verwendung von over ist die Möglichkeit, die Autorisierung anzuwenden und eine genauere Kontrolle über die Matching-Richtlinie zu haben.

Im folgenden Beispiel `MapHealthChecks` wird ein Zustandsprüfungsendpunkt unter: `/healthz`

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHealthChecks("/healthz", new HealthCheckOptions() { });
    });
}
```

## <a name="hostbuilder-replaces-webhostbuilder"></a>HostBuilder ersetzt WebHostBuilder

Die ASP.NET Core 3.0-Vorlagen verwenden [Generic Host](xref:fundamentals/host/generic-host). Frühere Versionen verwendeten [Web Host](xref:fundamentals/host/web-host). Der folgende Code zeigt die ASP.NET `Program` Core 3.0-Vorlagengenerierte Klasse:

[!code-csharp[](22-to-30/samples/Program.cs?name=snippet)]

Der folgende Code zeigt die ASP.NET Core `Program` 2.2-Vorlagengenerierte Klasse:

[!code-csharp[](22-to-30/samples/Program2.2.cs?name=snippet)]

<xref:Microsoft.AspNetCore.Hosting.IWebHostBuilder>bleibt in 3.0 und ist `webBuilder` der Typ des im vorherigen Codebeispiel gesehenen. <xref:Microsoft.AspNetCore.Hosting.WebHostBuilder>wird in einer zukünftigen Version veraltet und `HostBuilder`durch ersetzt.

Die bedeutendste Veränderung `WebHostBuilder` `HostBuilder` von zu ist in [der Abhängigkeitsinjektion (DI)](xref:fundamentals/dependency-injection). Bei `HostBuilder`Verwendung von können Sie `Startup`nur Folgendes in den Konstruktor von einschleusen:

* <xref:Microsoft.Extensions.Configuration.IConfiguration>
* <xref:Microsoft.Extensions.Hosting.IHostEnvironment>
* <xref:Microsoft.AspNetCore.Hosting.IWebHostEnvironment>

Die `HostBuilder` DI-Einschränkungen:

* Aktivieren Sie die einmalige Container-Bauweise des DI-Containers.
* Vermeidet die resultierenden Probleme mit der Lebensdauer des Objekts, z. B. das Lösen mehrerer Instanzen von Singletons.

Weitere Informationen finden Sie unter [Vermeiden der Start-Start-Service-Injektion in ASP.NET Core 3](https://andrewlock.net/avoiding-startup-service-injection-in-asp-net-core-3/).

## <a name="addauthorization-moved-to-a-different-assembly"></a>AddAuthorization in eine andere Assembly verschoben

Die ASP.NET Core 2.2 und niedrigeren `AddAuthorization` Methoden in *Microsoft.AspNetCore.Authorization.dll*:

* Wurden umbenannt `AddAuthorizationCore`.
* Sie wurden zu *Microsoft.AspNetCore.Authorization.Policy.dll*verschoben.

Apps, die sowohl *Microsoft.AspNetCore.Authorization.dll* als *auch Microsoft.AspNetCore.Authorization.Policy.dll* verwenden, sind davon nicht betroffen.

Apps, die *Microsoft.AspNetCore.Authorization.Policy.dll* nicht verwenden, sollten eine der folgenden Aufgaben ausführen:

* Fügen Sie einen Verweis auf *Microsoft.AspNetCore.Authorization.Policy.dll*hinzu. Dieser Ansatz funktioniert für die meisten Apps und ist alles, was erforderlich ist.
* Wechseln sie zur Verwendung`AddAuthorizationCore`

Weitere Informationen finden Sie unter [Brechen von Änderungen in `AddAuthorization(o =>`) Überlastlebensdauern in einer anderen Assembly #386](https://github.com/aspnet/Announcements/issues/386).

## <a name="identity-ui"></a>Identitäts-UI

Identitäts-UI-Updates für ASP.NET Core 3.0:

* Hinzufügen eines Paketverweises zu [Microsoft.AspNetCore.Identity.UI](https://nuget.org/packages/Microsoft.AspNetCore.Identity.UI).
* Apps, die Razor Pages nicht `MapRazorPages`verwenden, müssen aufrufen. Siehe [Razor-Seiten](#razor-pages) in diesem Dokument.
* Bootstrap 4 ist das Standard-UI-Framework. Legen `IdentityUIFrameworkVersion` Sie eine Projekteigenschaft fest, um die Standardeinstellung zu ändern. Weitere Informationen finden Sie in [dieser GitHub-Ankündigung](https://github.com/aspnet/Announcements/issues/380).

## SignalR

Der SignalR JavaScript-Client `@aspnet/signalr` wurde `@microsoft/signalr`von zu geändert. Um auf diese Änderung zu reagieren, ändern Sie `require` die Verweise in `import` *package.json-Dateien,* Anweisungen und ECMAScript-Anweisungen.

### <a name="systemtextjson-is-the-default-protocol"></a>System.Text.Json ist das Standardprotokoll

`System.Text.Json`ist jetzt das standardmäßige Hubprotokoll, das sowohl vom Client als auch vom Server verwendet wird.

Rufen `Startup.ConfigureServices`Sie `AddJsonProtocol` in an, um Serialisierungsoptionen festzulegen.

**Server:**

```csharp
services.AddSignalR(...)
        .AddJsonProtocol(options =>
        {
            options.PayloadSerializerOptions.WriteIndented = false;
        })
```

**Kunde:**

```csharp
new HubConnectionBuilder()
    .WithUrl("/chatHub")
    .AddJsonProtocol(options =>
    {
        options.PayloadSerializerOptions.WriteIndented = false;
    })
    .Build();
```

### <a name="switch-to-newtonsoftjson"></a>Wechseln zu Newtonsoft.Json

Wenn Sie Funktionen von Newtonsoft.Json verwenden, die [in System.Text.Json nicht unterstützt werden,](/dotnet/standard/serialization/system-text-json-migrate-from-newtonsoft-how-to)können Sie zurück zu `Newtonsoft.Json`wechseln. Siehe [Verwenden von Newtonsoft.Json in SignalR einem ASP.NET Core 3.0-Projekt](#use-newtonsoftjson-in-an-aspnet-core-30-signalr-project) weiter oben in diesem Artikel.

## <a name="redis-distributed-caches"></a>Redis verteilte Caches

Das [Microsoft.Extensions.Caching.Redis-Paket](https://www.nuget.org/packages/Microsoft.Extensions.Caching.Redis) ist für ASP.NET Core 3.0-Apps oder höher nicht verfügbar. Ersetzen Sie den Paketverweis durch [Microsoft.Extensions.Caching.StackExchangeRedis](https://www.nuget.org/packages/Microsoft.Extensions.Caching.StackExchangeRedis). Weitere Informationen finden Sie unter <xref:performance/caching/distributed>.

## <a name="opt-in-to-runtime-compilation"></a>Opt-in für Die Laufzeitkompilierung

Vor ASP.NET Core 3.0 war die Laufzeitkompilierung von Ansichten ein implizites Feature des Frameworks. Die Laufzeitkompilierung ergänzt die Buildzeitkompilierung von Ansichten. Es ermöglicht dem Framework, Razor-Ansichten und -Seiten (*.cshtml-Dateien)* zu kompilieren, wenn die Dateien geändert werden, ohne die gesamte App neu erstellen zu müssen. Diese Funktion unterstützt das Szenario, in dem Eine schnelle Bearbeitung in der IDE vorgenommen und der Browser aktualisiert wird, um die Änderungen anzuzeigen.

In ASP.NET Core 3.0 ist die Laufzeitkompilierung ein Opt-in-Szenario. Die Buildzeitkompilierung ist der einzige Mechanismus für die Ansichtskompilierung, der standardmäßig aktiviert ist. Die Laufzeit basiert auf Visual Studio oder [dotnet-watch](xref:tutorials/dotnet-watch) in Visual Studio Code, um das Projekt neu zu erstellen, wenn Änderungen an *.cshtml-Dateien* erkannt werden. In Visual Studio werden Änderungen an *.cs*, *.cshtml*oder *.razor-Dateien* im ausgeführten Projekt (<kbd>Strg+F5</kbd>), aber nicht gedebugbt (<kbd>F5</kbd>) ausgelöst, eine Neukompilierung des Projekts auslösen.

So aktivieren Sie die Laufzeitkompilierung in Ihrem ASP.NET Core 3.0-Projekt:

1. das NuGet-Paket [Microsoft.AspNetCore.Mvc.Razor.RuntimeCompilation](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Razor.RuntimeCompilation) installieren.
1. Update `Startup.ConfigureServices` zum `AddRazorRuntimeCompilation`Aufrufen :

    Verwenden Sie für ASP.NET Core MVC den folgenden Code:

    ```csharp
    services.AddControllersWithViews()
        .AddRazorRuntimeCompilation(...);
    ```
 
    Verwenden Sie für ASP.NET Core Razor Pages den folgenden Code:
 
    ```csharp
    services.AddRazorPages()
        .AddRazorRuntimeCompilation(...);
    ```
 
Das Beispiel https://github.com/aspnet/samples/tree/master/samples/aspnetcore/mvc/runtimecompilation zeigt ein Beispiel für das Aktivieren der Laufzeitkompilierung bedingt in Entwicklungsumgebungen.

Weitere Informationen zur Zusammenstellung <xref:mvc/views/view-compilation>von Razor-Dateien finden Sie unter .

## <a name="migrate-libraries-via-multi-targeting"></a>Migrieren von Bibliotheken über Multi-Targeting

Bibliotheken müssen häufig mehrere Versionen von ASP.NET Core unterstützen. Die meisten Bibliotheken, die mit früheren Versionen von ASP.NET Core kompiliert wurden, sollten weiterhin problemlos funktionieren. Die folgenden Bedingungen erfordern, dass die App quer kompiliert wird:

* Die Bibliothek basiert auf einem Feature, das eine binäre [Bruchänderung](#breaking-api-changes)hat.
* Die Bibliothek möchte die neuen Funktionen in ASP.NET Core 3.0 nutzen. 

Beispiel:

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFrameworks>netcoreapp3.0;netstandard2.0</TargetFrameworks>
  </PropertyGroup>

  <ItemGroup Condition="'$(TargetFramework)' == 'netcoreapp3.0'">
    <FrameworkReference Include="Microsoft.AspNetCore.App" />
  </ItemGroup>

  <ItemGroup Condition="'$(TargetFramework)' == 'netstandard2.0'">
    <PackageReference Include="Microsoft.AspNetCore" Version="2.1.0" />
  </ItemGroup>
</Project>
```

Verwenden `#ifdefs` Sie diese Option, um ASP.NET Core 3.0-spezifischen APIs zu aktivieren:

```csharp
var webRootFileProvider =
#if NETCOREAPP3_0
    GetRequiredService<IWebHostEnvironment>().WebRootFileProvider;
#elif NETSTANDARD2_0
    GetRequiredService<IHostingEnvironment>().WebRootFileProvider;
#else
#error unknown target framework
#endif
```

Weitere Informationen zur Verwendung ASP.NET Core-APIs <xref:fundamentals/target-aspnetcore>in einer Klassenbibliothek finden Sie unter .

## <a name="miscellaneous-changes"></a>Verschiedene Änderungen

Das Validierungssystem in .NET Core 3.0 und höher behandelt Non-Nullable-Parameter oder gebundene Eigenschaften so, als würden sie ein `[Required]`-Attribut aufweisen. Weitere Informationen finden Sie unter [[Erforderlich]-Attribut](xref:mvc/models/validation?view=aspnetcore-3.1#required-attribute).

### <a name="publish"></a>Veröffentlichen

Löschen Sie die *Ordner bin* und *obj* im Projektverzeichnis.

## <a name="testserver"></a>TestServer

Erstellen Sie <xref:Microsoft.AspNetCore.TestHost.TestServer> für Apps, die direkt mit <xref:Microsoft.AspNetCore.Hosting.IWebHostBuilder> <xref:Microsoft.Extensions.Hosting.GenericHostWebHostBuilderExtensions.ConfigureWebHost%2A>dem [generischen Host](xref:fundamentals/host/web-host)verwendet werden, die `TestServer` on a in:

```csharp
[Fact]
public async Task GenericCreateAndStartHost_GetTestServer()
{
    using var host = await new HostBuilder()
        .ConfigureWebHost(webBuilder =>
        {
            webBuilder
                .UseTestServer()
                .Configure(app => { });
        })
    .StartAsync();

    var response = await host.GetTestServer().CreateClient().GetAsync("/");

    Assert.Equal(HttpStatusCode.NotFound, response.StatusCode);
}
```

<a name="break"></a>

## <a name="breaking-api-changes"></a>Brechen von API-Änderungen

Überprüfen Sie brechende Änderungen:

* [Vollständige Liste der änderungen in der ASP.NET Core 3.0-Version](https://github.com/aspnet/Announcements/issues?page=1&q=is%3Aissue+is%3Aopen+label%3A%22Breaking+change%22+label%3A3.0.0)
* [Brechen von API-Änderungen in Antiforgery, CORS, Diagnostics, MVC und Routing](https://github.com/aspnet/Announcements/issues/387). Diese Liste enthält Breaking Changes für Kompatibilitätsoptionen.
* Eine Zusammenfassung von 2.2-bis-3.0, die Änderungen in .NET Core, ASP.NET Core und Entity Framework Core aufbrechen, finden Sie unter Brechen von Änderungen für die [Migration von Version 2.2 nach 3.0](/dotnet/core/compatibility/2.2-3.0).

## <a name="net-core-30-on-azure-app-service"></a>.NET Core 3.0 in Azure App Service

Weitere Informationen zum Rollout von .NET Core in Azure App Service finden Sie auf der offiziellen [.NET Core on App Service-Website.](https://aspnetcoreon.azurewebsites.net/) Bis .NET Core 3.0 in Azure App Service verfügbar ist, befolgen Sie die Anweisungen unter [Bereitstellen ASP.NET Core-Vorschauversion für Azure App Service](xref:host-and-deploy/azure-apps/index#deploy-aspnet-core-preview-release-to-azure-app-service).
