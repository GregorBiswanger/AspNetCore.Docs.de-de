---
title: Migrieren von ASP.NET Core 2.2 zu 3.0
author: rick-anderson
description: Hier erfahren Sie, wie Sie ein ASP.NET Core 2.2-Projekt zu ASP.NET Core 3.0 migrieren.
ms.author: riande
ms.custom: mvc
ms.date: 09/25/2019
uid: migration/22-to-30
ms.openlocfilehash: 630066f8745bbc3de145f2c8c1b97ea0853fbe66
ms.sourcegitcommit: cf9ffcce4fe0b69fe795aae9ae06e99fdb18bdfc
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 09/26/2019
ms.locfileid: "71306654"
---
# <a name="migrate-from-aspnet-core-22-to-30"></a>Migrieren von ASP.NET Core 2.2 zu 3.0

Von [Scott Adder](https://github.com/scottaddie) und [Rick Anderson](https://twitter.com/RickAndMSFT)

In diesem Artikel wird erläutert, wie ein vorhandenes ASP.NET Core 2.2-Projekt auf ASP.NET Core 3.0 aktualisiert wird.

## <a name="prerequisites"></a>Erforderliche Komponenten

# <a name="visual-studiotabvisual-studio"></a>[Visual Studio](#tab/visual-studio)

[!INCLUDE[](~/includes/net-core-prereqs-vs-3.0.md)]

# <a name="visual-studio-codetabvisual-studio-code"></a>[Visual Studio Code](#tab/visual-studio-code)

[!INCLUDE[](~/includes/net-core-prereqs-vsc-3.0.md)]

# <a name="visual-studio-for-mactabvisual-studio-mac"></a>[Visual Studio für Mac](#tab/visual-studio-mac)

[!INCLUDE[](~/includes/net-core-prereqs-mac-3.0.md)]

---

## <a name="update-the-project-file"></a>Aktualisieren der Projektdatei

### <a name="update-the-target-framework"></a>Aktualisieren des Ziel Frameworks

ASP.net Core 3,0 und höher wird nur unter .net Core ausgeführt. Legen Sie für `netcoreapp3.0`den [zielframeworkmoniker (TFM)](/dotnet/standard/frameworks) Folgendes fest:

```xml
<TargetFramework>netcoreapp3.0</TargetFramework>
```

### <a name="remove-obsolete-package-references"></a>Veraltete Paket Verweise entfernen

ASP.net Core erzeugt keine große Anzahl von Features für nuget-Pakete mehr. Diese Paket Verweise sollten aus der Projektdatei entfernt werden. Die vollständige Liste der Pakete, die nicht mehr erstellt werden, finden Sie unten:

<details>
    <summary>Klicken Sie hier, um die Liste der Pakete zu erweitern, die nicht mehr erstellt werden.</summary>
    <ul>
        <li>Microsoft.AspNetCore</li>
        <li>Microsoft.AspNetCore.All</li>
        <li>Microsoft.AspNetCore.App</li>
        <li>Microsoft.AspNetCore.Antiforgery</li>
        <li>Microsoft.AspNetCore.Authentication</li>
        <li>Microsoft.AspNetCore.Authentication.Abstractions</li>
        <li>Microsoft.AspNetCore.Authentication.Cookies</li>
        <li>Microsoft.AspNetCore.Authentication.Core</li>
        <li>Microsoft.AspNetCore.Authentication.JwtBearer</li>
        <li>Microsoft.AspNetCore.Authentication.OAuth</li>
        <li>Microsoft.AspNetCore.Authentication.OpenIdConnect</li>
        <li>Microsoft.AspNetCore.Authorization</li>
        <li>Microsoft.AspNetCore.Authorization.Policy</li>
        <li>Microsoft.AspNetCore.CookiePolicy</li>
        <li>Microsoft.AspNetCore.Cors</li>
        <li>Microsoft.AspNetCore.Cryptography.Internal</li>
        <li>Microsoft.AspNetCore.Cryptography.KeyDerivation</li>
        <li>Microsoft.AspNetCore.DataProtection</li>
        <li>Microsoft.AspNetCore.DataProtection.Abstractions</li>
        <li>Microsoft.AspNetCore.DataProtection.Extensions</li>
        <li>Microsoft.AspNetCore.Diagnostics</li>
        <li>Microsoft.AspNetCore.Diagnostics.HealthChecks</li>
        <li>Microsoft.AspNetCore.HostFiltering</li>
        <li>Microsoft.AspNetCore.Hosting</li>
        <li>Microsoft.AspNetCore.Hosting.Abstractions</li>
        <li>Microsoft.AspNetCore.Hosting.Server.Abstractions</li>
        <li>Microsoft.AspNetCore.Http</li>
        <li>Microsoft.AspNetCore.Http.Abstractions</li>
        <li>Microsoft.AspNetCore.Http.Connections</li>
        <li>Microsoft.AspNetCore.Http.Extensions</li>
        <li>Microsoft.AspNetCore.Http.Features</li>
        <li>Microsoft.AspNetCore.HttpOverrides</li>
        <li>Microsoft.AspNetCore.HttpsPolicy</li>
        <li>Microsoft.AspNetCore.Identity</li>
        <li>Microsoft.AspNetCore.Localization</li>
        <li>Microsoft.AspNetCore.Localization.Routing</li>
        <li>Microsoft.AspNetCore.MiddlewareAnalysis</li>
        <li>Microsoft.AspNetCore.Mvc</li>
        <li>Microsoft.AspNetCore.Mvc.Abstractions</li>
        <li>Microsoft.AspNetCore.Mvc.Analyzers</li>
        <li>Microsoft.AspNetCore.Mvc.ApiExplorer</li>
        <li>Microsoft.AspNetCore.Mvc.Api.Analyzers</li>
        <li>Microsoft.AspNetCore.Mvc.Core</li>
        <li>Microsoft.AspNetCore.Mvc.Cors</li>
        <li>Microsoft.AspNetCore.Mvc.DataAnnotations</li>
        <li>Microsoft.AspNetCore.Mvc.Formatters.Json</li>
        <li>Microsoft.AspNetCore.Mvc.Formatters.Xml</li>
        <li>Microsoft.AspNetCore.Mvc.Localization</li>
        <li>Microsoft.AspNetCore.Mvc.Razor</li>
        <li>Microsoft.AspNetCore.Mvc.Razor.Extensions</li>
        <li>Microsoft.AspNetCore.Mvc.Razor.ViewCompilation</li>
        <li>Microsoft.AspNetCore.Mvc.RazorPages</li>
        <li>Microsoft.AspNetCore.Mvc.TagHelpers</li>
        <li>Microsoft.AspNetCore.Mvc.ViewFeatures</li>
        <li>Microsoft.AspNetCore.Razor</li>
        <li>Microsoft.AspNetCore.Razor.Runtime</li>
        <li>Microsoft.AspNetCore.Razor.Design</li>
        <li>Microsoft.AspNetCore.ResponseCaching</li>
        <li>Microsoft.AspNetCore.ResponseCaching.Abstractions</li>
        <li>Microsoft.AspNetCore.ResponseCompression</li>
        <li>Microsoft.AspNetCore.Rewrite</li>
        <li>Microsoft.AspNetCore.Routing</li>
        <li>Microsoft.AspNetCore.Routing.Abstractions</li>
        <li>Microsoft.AspNetCore.Server.HttpSys</li>
        <li>Microsoft.AspNetCore.Server.IIS</li>
        <li>Microsoft.AspNetCore.Server.IISIntegration</li>
        <li>Microsoft.AspNetCore.Server.Kestrel</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Core</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Https</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets</li>
        <li>Microsoft.AspNetCore.Session</li>
        <li>Microsoft.AspNetCore.SignalR</li>
        <li>Microsoft.AspNetCore.SignalR.Core</li>
        <li>Microsoft.AspNetCore.StaticFiles</li>
        <li>Microsoft.AspNetCore.WebSockets</li>
        <li>Microsoft.AspNetCore.WebUtilities</li>
        <li>Microsoft.net. http. Headers</li>
    </ul>
</details>

### <a name="framework-reference"></a>Frameworkverweis

Features von ASP.net Core, die über eines der oben aufgeführten Pakete verfügbar waren, sind als Teil des `Microsoft.AspNetCore.App` freigegebenen Frameworks verfügbar. Das frei *gegebene Framework* ist der Satz von Assemblys (*dll* -Dateien), die auf dem Computer installiert sind und eine Laufzeitkomponente und ein Ziel Paket enthalten. Weitere Informationen finden Sie unter [The shared framework](https://natemcmaster.com/blog/2018/08/29/netcore-primitives-2/) (Das freigegebene Framework).

* Projekte, die auf `Microsoft.NET.Sdk.Web` das SDK abzielen, `Microsoft.AspNetCore.App` verweisen implizit auf das Framework.

Für diese Projekte sind keine weiteren Verweise erforderlich:

```xml
<Project Sdk="Microsoft.NET.Sdk.Web">
  <PropertyGroup>
    <TargetFramework>netcoreapp3.0</TargetFramework>
  </PropertyGroup>
    ...
</Project>
```

* Projekte, die `Microsoft.NET.Sdk` das `Microsoft.NET.Sdk.Razor` Ziel oder das SDK sind, `FrameworkReference` sollten `Microsoft.AspNetCore.App`eine explizite zu folgenden hinzufügen:

```xml
<Project Sdk="Microsoft.NET.Sdk.Razor">
  <PropertyGroup>
    <TargetFramework>netcoreapp3.0</TargetFramework>
  </PropertyGroup>

  <ItemGroup>
    <FrameworkReference Include="Microsoft.AspNetCore.App" />
  </ItemGroup>
    ...
</Project>
```

#### <a name="framework-dependent-builds-using-docker"></a>Framework-abhängige Builds mithilfe von Docker

Framework-abhängige Builds von Konsolen-apps, die ein Paket verwenden, das vom ASP.net Core [Shared Framework](https://natemcmaster.com/blog/2018/08/29/netcore-primitives-2/) abhängt, können den folgenden Laufzeitfehler verursachen:

```cli
It was not possible to find any compatible framework version
The specified framework 'Microsoft.AspNetCore.App', version '3.0.0' was not found.
  - No frameworks were found.
```

`Microsoft.AspNetCore.App`ist das freigegebene Framework, das die ASP.net Core Runtime enthält und nur auf dem docker-Image [dotnet/Core/ASPNET](https://hub.docker.com/_/microsoft-dotnet-core-aspnet/) vorhanden ist.  Das 3,0 SDK reduziert die Größe von Framework-abhängigen Builds mithilfe von ASP.net Core, indem keine doppelten Kopien von Bibliotheken eingeschlossen werden, die im freigegebenen Framework verfügbar sind.  Dies ist eine potenzielle Einsparung von bis zu ~ 18 MB, erfordert jedoch, dass die ASP.net Core-Laufzeit vorhanden/installiert sein muss, um die APP auszuführen.

Überprüfen Sie die *runtimeconfig. JSON* -Datei, die während der Erstellung/Veröffentlichung Ihrer APP generiert wird, um zu bestimmen, ob die APP eine Abhängigkeit (entweder direkt oder indirekt) auf dem ASP.net Core freigegebenen Framework aufweist. Die folgende JSON-Datei zeigt eine Abhängigkeit vom ASP.net Core Shared Framework:

```JSON
{
  "runtimeOptions": {
    "tfm": "netcoreapp3.0",
    "framework": {
      "name": "Microsoft.AspNetCore.App",
      "version": "3.0.0"
    },
    "configProperties": {
      "System.GC.Server": true
    }
  }
}
```

Wenn Ihre APP docker verwendet, verwenden Sie ein Basis Image, das ASP.net Core 3,0 enthält. Beispielsweise `docker pull mcr.microsoft.com/dotnet/core/aspnet:3.0`.

### <a name="add-package-references-for-removed-assemblies"></a>Paket Verweise für entfernte Assemblys hinzufügen

ASP.net Core 3,0 entfernt einige Assemblys, die zuvor Teil `Microsoft.AspNetCore.App` des Paket Verweises waren. Um die von diesen Assemblys bereitgestellten Funktionen weiterhin zu verwenden, verweisen Sie auf die 3,0-Versionen der entsprechenden Pakete:

* Weitere &ndash; Informationen zum Verweisen auf das Datenbankanbieter spezifische Paket finden Sie unter [Datenbankanbieter](/ef/core/providers/index). Entity Framework Core

* Identitäts Benutzeroberfläche

  Unterstützung für die [Benutzeroberfläche der Identität](xref:security/authentication/identity) kann durch Verweisen auf das [Microsoft. aspnetcore. Identity. UI](https://www.nuget.org/packages/Microsoft.AspNetCore.Identity.UI) -Paket hinzugefügt werden.

* Spa-Dienste
  * [Microsoft. aspnetcore. Spaservices](https://www.nuget.org/packages/Microsoft.AspNetCore.SpaServices)
  * [Microsoft. aspnetcore. Spaservices. Extensions](https://www.nuget.org/packages/Microsoft.AspNetCore.SpaServices.Extensions)

* Die &ndash; Authentifizierungs Unterstützung für Authentifizierungs Abläufe von Drittanbietern ist als nuget-Pakete verfügbar:

  * Facebook OAuth ([Microsoft. aspnetcore. Authentication. Facebook](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Facebook))
  * Google OAuth ([Microsoft. aspnetcore. Authentication. Google](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Google))
  * OpenID Connect-bearertoken ([Microsoft. aspnetcore. Authentication. jwtbearertoken](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.JwtBearer))
  * Microsoft-Konto Authentifizierung ([Microsoft. aspnetcore. Authentication. microsoftaccount](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.MicrosoftAccount))
  * OpenID Connect-Authentifizierung ([Microsoft. aspnetcore. Authentication. openidconnect](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.OpenIdConnect))
  * Twitter OAuth ([Microsoft. aspnetcore. Authentication. Twitter](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Twitter))
  * Wsfederation-Authentifizierung ([Microsoft. aspnetcore. Authentication. wsfederation](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.WsFederation))

* Die Unterstützung von Formatierung und `System.Net.HttpClient` Inhaltsaushandlung für &ndash; das nuget-Paket " [Microsoft. Aspnet. WebAPI. Client](https://www.nuget.org/packages/Microsoft.AspNet.WebApi.Client/) " bietet eine `ReadAsAsync`nützliche `PostJsonAsync` Erweiterbarkeit für `System.Net.HttpClient` mit APIs wie z. b. usw.

* Die Kompilierungs &ndash; Unterstützung für Razor-Runtime für die Lauf Zeit Kompilierung von Razor-Ansichten und-Seiten ist nun Bestandteil von [Microsoft. aspnetcore. MVC. Razor. runtimecompilation](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Razor.RuntimeCompilation).

* Die `Newtonsoft.Json` MVC &ndash; -Unterstützung für die Verwendung `Newtonsoft.Json` von MVC mit ist nun Bestandteil von [Microsoft. aspnetcore. MVC. newtonsoftware](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson).

### <a name="analyzer-support"></a>Analyse Unterstützung

* Projekte, die `Microsoft.NET.Sdk.Web` implizit auf Analysen abzielen, die zuvor als Teil des Pakets [Microsoft. aspnetcore. MVC. Analysen](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Analyzers/) ausgeliefert wurden. Es sind keine zusätzlichen Verweise erforderlich, um diese zu aktivieren.

* Wenn Ihre APP [API-Analysen](xref:web-api/advanced/analyzers) verwendet, die zuvor mit dem Paket [Microsoft. aspnetcore. MVC. API. Analysen](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Api.Analyzers/) ausgeliefert wurden, bearbeiten Sie die Projektdatei so, dass Sie auf die Analysen verweist, die als Teil des .net Core Web SDK ausgeliefert werden:

```xml
<Project Sdk="Microsoft.NET.Sdk.Web">
  <PropertyGroup>
    <TargetFramework>netcoreapp3.0</TargetFramework>
    <IncludeOpenAPIAnalyzers>true</IncludeOpenAPIAnalyzers>
  </PropertyGroup>

  ...
</Project>
```

### <a name="razor-class-library"></a>Razor-Klassenbibliothek

Razor-Klassen Bibliotheks Projekte, die Benutzeroberflächen Komponenten für MVC bereit `AddRazorSupportForMvc` stellen, müssen die-Eigenschaft in der Projektdatei festlegen:

```xml
<PropertyGroup>
  <AddRazorSupportForMvc>true</AddRazorSupportForMvc>
</PropertyGroup>
```

### <a name="in-process-hosting-model"></a>In-Process-Hostingmodell

Projekte werden standardmäßig auf das [In-Process-Hostingmodell](xref:host-and-deploy/aspnet-core-module#in-process-hosting-model) in ASP.NET Core 3.0 oder höher eingestellt. Wenn der Wert `InProcess` lautet, können Sie optional die Eigenschaft `<AspNetCoreHostingModel>` in der Projektdatei entfernen.

## <a name="kestrel"></a>Kestrel

### <a name="configuration"></a>Konfiguration

Migrieren Sie die Kestrel-Konfiguration zum von `ConfigureWebHostDefaults` bereitgestellten Webhost-Generator (*Program.cs*):

```csharp
public static IHostBuilder CreateHostBuilder(string[] args) =>
    Host.CreateDefaultBuilder(args)
        .ConfigureWebHostDefaults(webBuilder =>
        {
            webBuilder.ConfigureKestrel(serverOptions =>
            {
                // Set properties and call methods on options
            })
            .UseStartup<Startup>();
        });
```

Wenn die APP den Host mit `HostBuilder`manuell erstellt `UseKestrel` , müssen Sie auf dem Webhost- `ConfigureWebHostDefaults`Generator in folgenden Befehl ausführen:

```csharp
public static void Main(string[] args)
{
    var host = new HostBuilder()
        .UseContentRoot(Directory.GetCurrentDirectory())
        .ConfigureWebHostDefaults(webBuilder =>
        {
            webBuilder.UseKestrel(serverOptions =>
            {
                // Set properties and call methods on options
            })
            .UseIISIntegration()
            .UseStartup<Startup>();
        })
        .Build();

    host.Run();
}
```

### <a name="connection-middleware-replaces-connection-adapters"></a>Verbindungs-Middleware ersetzt Verbindungs Adapter

Verbindungs Adapter (<xref:Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.IConnectionAdapter>) wurden aus Kestrel entfernt. Ersetzen Sie Verbindungs Adapter durch Verbindungs Middleware. Die Verbindungs Middleware ähnelt http-Middleware in der ASP.net Core Pipeline, aber für Verbindungen auf niedrigerer Ebene. HTTPS und Verbindungs Protokollierung:

* Wurden von Verbindungs Adaptern zur Verbindungs Middleware verschoben.
* Diese Erweiterungs Methoden funktionieren wie in früheren Versionen von ASP.net Core. 

Weitere Informationen finden Sie [im Abschnitt "tlsfilterconnectionhandler" im Abschnitt "listenoptions. Protokolls" im Kestrel-Artikel](/aspnet/core/fundamentals/servers/kestrel?view=aspnetcore-3.0#listenoptionsprotocols).

### <a name="transport-abstractions-moved-and-made-public"></a>Transport Abstraktionen verschoben und öffentlich gemacht

Die Kestrel-Transportschicht wurde in `Connections.Abstractions`als öffentliche Schnittstelle verfügbar gemacht. Als Teil dieser Updates:

* `Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions`und zugeordnete Typen wurden entfernt.
* <xref:Microsoft.AspNetCore.Server.Kestrel.KestrelServerOptions.NoDelay>wurde von <xref:Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions> zu den Transport Optionen verschoben.
* <xref:Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions.Internal.SchedulingMode>wurde aus <xref:Microsoft.AspNetCore.Server.Kestrel.KestrelServerOptions>entfernt.

Weitere Informationen finden Sie in den folgenden GitHub-Ressourcen:

* [Client/Server-Netzwerk Abstraktionen (ASPNET/aspnetcore-#10308)](https://github.com/aspnet/AspNetCore/issues/10308)
* [Implementieren Sie die neue Fundament-Listener-Abstraktion, und setzen Sie Kestrel im oberen Bereich (ASPNET/aspnetcore-#10321).](https://github.com/aspnet/AspNetCore/pull/10321)

### <a name="kestrel-request-trailer-headers"></a>Kestrel-Anforderungs Nachspann Header

Für apps, die auf frühere Versionen von ASP.net Core abzielen:

* Kestrel fügt der Auflistung der Anforderungs Header HTTP/1.1-Auflistungs Header hinzu.
* Nach dem Lesen des Anforderungs Texts sind die nach dem Ende des Anforderungs Texts verfügbar.

Dies bewirkt einige Bedenken bezüglich der Mehrdeutigkeit zwischen Headern und nach Spann, sodass die Nachspann in eine neue`RequestTrailerExtensions`Sammlung () in 3,0 verschoben wurden.

HTTP/2-Anforderungs Nachspann:

* Nicht verfügbar in ASP.net Core 2,2.
* Verfügbar in 3,0 als `RequestTrailerExtensions`.

Für den Zugriff auf diese Nachspann sind neue Anforderungs Erweiterungs Methoden vorhanden. Wie bei HTTP/1.1 sind Nachspann verfügbar, nachdem der Anforderungs Text bis zum Ende gelesen wurde.

Für die Version 3,0 sind die folgenden `RequestTrailerExtensions` Methoden verfügbar:

* `GetDeclaredTrailers`Ruft den Anforderungs `Trailer` Header ab, der auflistet, welche Nachspann nach dem Text erwartet werden. &ndash;
* `SupportsTrailers`&ndash; Gibt an, ob die Anforderung empfangende nach Spann Header unterstützt.
* `CheckTrailersAvailable`&ndash; Überprüft, ob die Anforderung Nachspann unterstützt und ob Sie zum Lesen verfügbar sind. Bei dieser Überprüfung wird nicht davon ausgegangen, dass zum Lesen von nach spannenden Möglicherweise gibt es keine zu lesenden Nachspann, auch wenn `true` von dieser Methode zurückgegeben wird.
* `GetTrailer`&ndash; Ruft den angeforderten nachfolgenden Header aus der Antwort ab. Über `SupportsTrailers` prüfen Sie `GetTrailer`vor dem Aufrufen <xref:System.NotSupportedException> von, oder kann eintreten, wenn die Anforderung keine nachfolgenden Header unterstützt.

Weitere Informationen finden Sie unter [Put Request Trailers in a separate Collection (ASPNET/aspnetcore-#10410)](https://github.com/aspnet/AspNetCore/pull/10410).

### <a name="allowsynchronousio-disabled"></a>Allowsynchronousio deaktiviert

`AllowSynchronousIO`aktiviert oder deaktiviert synchrone e/a-APIs `HttpRequest.Body.Read`, `HttpResponse.Body.Write`wie z `Stream.Flush`. b., und. Diese APIs sind eine Quelle der Thread Hungersnot, die zu app-Abstürzen führt. In 3,0 `AllowSynchronousIO` ist standardmäßig deaktiviert. Weitere Informationen finden Sie im Abschnitt "Synchrone e/a" [im Kestrel-Artikel](/aspnet/core/fundamentals/servers/kestrel?view=aspnetcore-3.0#synchronous-io).

Zusätzlich zum Aktivieren `AllowSynchronousIO` von mit `ConfigureKestrel`den Optionen können synchrone e/a-Vorgänge auch auf Anforderungs Basis als vorübergehende Entschärfung überschrieben werden:

```csharp
var syncIOFeature = HttpContext.Features.Get<IHttpBodyControlFeature>();

if (syncIOFeature != null)
{
    syncIOFeature.AllowSynchronousIO = true;
}
```

Wenn Sie Probleme mit <xref:System.IO.TextWriter> Implementierungen oder anderen Streams haben, die synchrone APIs [in verwerfen](/dotnet/standard/garbage-collection/implementing-dispose)aufzurufen, <xref:System.IO.Stream.DisposeAsync*> müssen Sie stattdessen die neue API abrufen.

Weitere Informationen finden Sie unter [[Ankündigung] allowsynchronousio deaktiviert auf allen Servern (ASPNET/aspnetcore-#7644)](https://github.com/aspnet/AspNetCore/issues/7644).

### <a name="microsoftaspnetcoreserverkestrelhttps-assembly-removed"></a>Die Assembly "Microsoft. aspnetcore. Server. Kestrel. https" wurde entfernt.

In ASP.net Core 2,1 wurde der Inhalt von " *Microsoft. aspnetcore. Server. Kestrel. HTTPS. dll* " in " *Microsoft. aspnetcore. Server. Kestrel. Core. dll*" verschoben. Dabei handelt es sich um ein nicht Erbrechtes Update mit `TypeForwardedTo` Attributen. Bei 3,0 wurden die leere *Microsoft. aspnetcore. Server. Kestrel. HTTPS. dll* -Assembly (und das nuget-Paket) entfernt.

Bibliotheken, die auf [Microsoft. aspnetcore. Server. Kestrel. HTTPS](https://www.nuget.org/packages/Microsoft.AspNetCore.Server.Kestrel.Https) verweisen, sollten ASP.net Core Abhängigkeiten auf 2,1 oder höher aktualisieren.

Apps und Bibliotheken, die auf ASP.net Core 2,1 oder höher abzielen, sollten alle direkten Verweise auf das Paket [Microsoft. aspnetcore. Server. Kestrel. HTTPS](https://www.nuget.org/packages/Microsoft.AspNetCore.Server.Kestrel.Https) entfernen.

## <a name="jsonnet-support"></a>JSON.NET-Unterstützung

Als Teil der Arbeit zur [Verbesserung der ASP.net Core Shared Framework](https://blogs.msdn.microsoft.com/webdev/2018/10/29/a-first-look-at-changes-coming-in-asp-net-core-3-0/)wurde [JSON.net](https://www.newtonsoft.com/json/help/html/Introduction.htm) aus dem freigegebenen Framework ASP.net Core entfernt.

Der Standardwert für ASP.net Core ist jetzt [System. Text. JSON](/dotnet/api/system.text.json?view=netcore-3.0), das in .net Core 3,0 neu ist. Verwenden Sie `System.Text.Json` nach Möglichkeit die Verwendung von. Dies ist eine hohe Leistung und erfordert keine zusätzliche Bibliotheks Abhängigkeit. Da `System.Text.Json` jedoch neu ist, fehlen möglicherweise derzeit die Features, die Ihre APP benötigt.

Ihre `Newtonsoft.Json` App erfordert möglicherweise eine Integration, `Newtonsoft.Json`Wenn Sie eine-spezifische Funktion wie jsonpatch oder Konverter verwendet oder bestimmte Typen [formatiert](xref:web-api/advanced/formatting) `Newtonsoft.Json`.

Informationen zum Verwenden von JSON.net in einem 3,0 ASP.net Core signalr-Projekt finden Sie unter [Wechseln zu "newtonsoft. JSON](#switch-to-newtonsoftjson) " in diesem Dokument.

So verwenden Sie Json.NET in einem ASP.NET Core 3.0-Projekt:

* Fügen Sie [Microsoft.AspNetCore.Mvc.NewtonsoftJson](https://nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson) einen Paketverweis hinzu.
* Aktualisieren `Startup.ConfigureServices` , um `AddNewtonsoftJson`aufzurufen.

  ```csharp
  services.AddMvc()
      .AddNewtonsoftJson();
  ```

  `AddNewtonsoftJson`ist mit den neuen Registrierungsmethoden für den MVC-Dienst kompatibel:

  * `AddRazorPages`
  * `AddControllersWithViews`
  * `AddControllers`

  ```csharp
  services.AddControllers()
      .AddNewtonsoftJson();
  ```

  JSON.NET-Einstellungen können im `AddNewtonsoftJson`-Befehl festgelegt werden:

  ```csharp
  services.AddMvc()
      .AddNewtonsoftJson(options =>
             options.SerializerSettings.ContractResolver =
                new CamelCasePropertyNamesContractResolver());
  ```

## <a name="mvc-service-registration"></a>MVC-Dienst Registrierung

In ASP.NET Core 3.0 werden neue Optionen zum Registrieren von MVC-Szenarios in `Startup.ConfigureServices` hinzugefügt.

Drei neue Erweiterungs Methoden der obersten Ebene, die sich auf MVC `IServiceCollection` -Szenarios für beziehen, sind verfügbar. Vorlagen verwenden diese neuen Methoden anstelle von `UseMvc`. Verhält sich jedoch weiterhin wie in früheren Versionen. `AddMvc`

Im folgenden Beispiel wird die Unterstützung für Controller und API-Funktionen hinzugefügt, jedoch keine Sichten oder Seiten. Die API-Vorlage verwendet diesen Code:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllers();
}
```

Im folgenden Beispiel werden die Unterstützung für Controller, API-bezogene Features und Sichten, aber keine Seiten hinzugefügt. Die Vorlage Webanwendung (MVC) verwendet folgenden Code:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllersWithViews();
}
```

Im folgenden Beispiel wird Unterstützung für Razor Pages und minimale Controller Unterstützung hinzugefügt. Die Webanwendungsvorlage verwendet diesen Code:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddRazorPages();
}
```

Die neuen Methoden können ebenfalls kombiniert werden. Das folgende Beispiel entspricht dem Aufrufen von `AddMvc` in ASP.NET Core 2.2:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllersWithViews();
    services.AddRazorPages();
}
```

## <a name="routing-startup-code"></a>Routing Startcode

Wenn eine APP oder `UseMvc` `UseSignalR`aufruft, migrieren Sie die APP nach Möglichkeit zum [Endpunkt Routing](xref:fundamentals/routing) . Um die Kompatibilität mit dem Endpunkt Routing mit früheren Versionen von MVC zu verbessern, haben wir einige der Änderungen in der URL-Generierung wieder hergestellt, die in ASP.net Core 2,2 eingeführt wurden. Wenn bei der Verwendung des Endpunkt Routings in 2,2 Probleme auftreten, erwarten Sie Verbesserungen in ASP.net Core 3,0 mit folgenden Ausnahmen:

* Wenn die APP implementiert `IRouter` oder von `Route`der Anwendung erbt, verwenden Sie [dynamicroutevaluestransex](https://github.com/aspnet/AspNetCore.Docs/issues/12997) als Ersatz.

* Wenn die APP direkt in `RouteData.Routers` MVC zugreift, um URLs zu analysieren, können Sie dies durch die `LinkParser.ParsePathByEndpointName`Verwendung von ersetzen. 
 * Hiermit wird die Route mit einem Routennamen definiert.
 * Verwenden `LinkParser.ParsePathByEndpointName` Sie, und übergeben Sie den gewünschten Routennamen.

Das Endpunkt Routing unterstützt die gleiche Routing Muster Syntax und die Funktionen zum `IRouter`Erstellen von Routen Mustern wie. Das Endpunkt Routing `IRouteConstraint`unterstützt. Das Endpunkt Routing `[Route]`unter `[HttpGet]`stützt, und die anderen MVC-Routing Attribute.

Bei den meisten Anwendungen müssen `Startup` nur Änderungen vorgenommen werden.

### <a name="migrate-startupconfigure"></a>"Startup. configure" Migrieren

Allgemeine Hinweise:

* Fügen `UseRouting`Sie hinzu.
* Wenn die APP aufruft `UseStaticFiles`, platzieren `UseStaticFiles` Sie es **vor** `UseRouting`.
* Wenn die APP Authentifizierungs-/Autorisierungsfeatures `AuthorizePage` wie `[Authorize]`oder verwendet, platzieren `UseRouting` Sie `UseAuthentication` den `UseAuthorization`-Befehl unter und `UseCors`: **nach**und `UseEndpoints`, aber vor:

  ```csharp
  public void Configure(IApplicationBuilder app)
  {
    ...

    app.UseStaticFiles();

    app.UseRouting();
    app.UseCors();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints => {
       endpoints.MapControllers();
    }
  ```

* Ersetzen `UseMvc` Sie `UseSignalR` oder durch`UseEndpoints`.
* Wenn die APP [cors](xref:security/cors) `[EnableCors]`-Szenarien (z. b.) verwendet, `UseCors` platzieren Sie den-Anrufe vor allen anderen Middleware, die cors `UseAuthentication`verwenden (z `UseEndpoints`. b. platzieren `UseCors` vor, `UseAuthorization`und).
* Ersetzen `IHostingEnvironment` Sie `IWebHostEnvironment` durch, und `using` fügen Sie eine <xref:Microsoft.Extensions.Hosting?displayProperty=fullName> -Anweisung für den Namespace hinzu.
* Ersetzen `IApplicationLifetime` Sie <xref:Microsoft.Extensions.Hosting.IHostApplicationLifetime> dies<xref:Microsoft.Extensions.Hosting?displayProperty=fullName> durch (-Namespace).
* Ersetzen `EnvironmentName` Sie <xref:Microsoft.Extensions.Hosting.Environments> dies<xref:Microsoft.Extensions.Hosting?displayProperty=fullName> durch (-Namespace).

Der folgende Code ist ein Beispiel für `Startup.Configure` eine typische ASP.net Core 2,2-App:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseStaticFiles();

    app.UseAuthentication();

    app.UseSignalR(hubs =>
    {
        hubs.MapHub<ChatHub>("/chat");
    });

    app.UseMvc(routes =>
    {
        routes.MapRoute("default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

Nach dem Aktualisieren des `Startup.Configure` vorherigen Codes:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseStaticFiles();

    app.UseRouting();

    app.UseCors();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>("/chat");
        endpoints.MapControllerRoute("default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

> [!WARNING]
> Bei den meisten apps müssen Aufrufe `UseAuthentication`von `UseAuthorization`, und `UseCors` zwischen den Aufrufen von `UseRouting` und `UseEndpoints` auftreten, um wirksam zu werden.

### <a name="health-checks"></a>Integritätsprüfungen

Integritäts Überprüfungen verwenden das Endpunkt Routing mit dem generischen Host. Rufen Sie in `Startup.Configure` auf der Endpunkterstellung mit der Endpunkt-URL oder dem relativen Pfad `MapHealthChecks` auf:

```csharp
app.UseEndpoints(endpoints =>
{
    endpoints.MapHealthChecks("/health");
});
```

Endpunkte für Integritätsprüfungen können

* Geben Sie einen oder mehrere zugelassene Hosts/Ports an.
* Autorisierung erforderlich.
* Erfordert cors.

Weitere Informationen finden Sie unter <xref:host-and-deploy/health-checks>.

### <a name="security-middleware-guidance"></a>Leitfaden zur Sicherheit von Middleware

Unterstützung für die Autorisierung und cors ist in Bezug auf den [Middleware](xref:fundamentals/middleware/index) -Ansatz einheitlich. Dies ermöglicht die Verwendung derselben Middleware und derselben Funktionalität in diesen Szenarien. In dieser Version wird eine aktualisierte Autorisierungs Middleware bereitgestellt, und die cors-Middleware wird verbessert, sodass Sie die von MVC-Controllern verwendeten Attribute verstehen kann.

#### <a name="cors"></a>CORS

Zuvor war es möglicherweise schwierig, cors zu konfigurieren. Die Middleware wurde zur Verwendung in einigen Anwendungsfällen bereitgestellt, aber MVC-Filter waren in anderen Anwendungsfällen **ohne** die Middleware vorgesehen. Bei ASP.net Core 3,0 wird empfohlen, dass alle apps, die cors benötigen, die cors-Middleware zusammen mit dem Endpunkt Routing verwenden. `UseCors`kann mit einer Standard Richtlinie angegeben werden, und `[EnableCors]` die `[DisableCors]` -und-Attribute können verwendet werden, um die Standard Richtlinie nach Bedarf zu überschreiben.

Im folgenden Beispiel:

* Cors ist für alle Endpunkte mit der `default` benannten Richtlinie aktiviert.
* Die `MyController` -Klasse deaktiviert cors mit dem `[DisableCors]` -Attribut.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseCors("default");

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

[DisableCors]
public class MyController : ControllerBase
{
    ...
}
```

#### <a name="authorization"></a>Autorisierung

In früheren Versionen von ASP.NET Core wurde die Unterstützung für die Autorisierung über das Attribut `[Authorize]` bereitgestellt. Die Autorisierungsmiddleware war nicht verfügbar. In ASP.NET Core 3.0 ist die Autorisierungsmiddleware erforderlich. Es wird empfohlen, die ASP.NET Core-Autorisierungsmiddleware (`UseAuthorization`) direkt nach `UseAuthentication` zu platzieren. Die Middleware für die Autorisierung kann auch mit einer Standardrichtlinie konfiguriert werden, die überschrieben werden kann.

In ASP.NET Core 3.0 oder höher wird `UseAuthorization` in `Startup.Configure`aufgerufen, und für folgende `HomeController`-Klasse ist ein angemeldeter Benutzer erforderlich:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

public class HomeController : ControllerBase
{
    [Authorize]
    public IActionResult BuyWidgets()
    {
        ...
    }
}
```

Wenn die APP `AuthorizeFilter` als globaler Filter in MVC verwendet, empfiehlt es sich, den Code so zu umgestalten, dass er eine Richtlinie `AddAuthorization`im-Befehl bereitstellt.

Das `DefaultPolicy` ist anfänglich so konfiguriert, dass eine Authentifizierung erforderlich ist, sodass keine zusätzliche Konfiguration erforderlich ist. Im folgenden Beispiel werden die MVC-Endpunkte als `RequireAuthorization` markiert, sodass alle Anforderungen auf der `DefaultPolicy`Grundlage von autorisiert werden müssen. Der ermöglicht jedoch `HomeController` den Zugriff, ohne dass der Benutzer sich bei der APP `[AllowAnonymous]`anmeldet. Dies liegt an folgendem:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute().RequireAuthorization();
    });
}

[AllowAnonymous]
public class HomeController : ControllerBase
{
    ...
}
```

Richtlinien können auch angepasst werden. Wenn Sie auf dem vorherigen Beispiel aufbauen `DefaultPolicy` , wird der so konfiguriert, dass eine Authentifizierung und ein bestimmter Bereich erforderlich sind:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    ...

    services.AddAuthorization(options =>
    {
        options.DefaultPolicy = new AuthorizationPolicyBuilder()
          .RequireAuthenticatedUser()
          .RequireScope("MyScope")
          .Build();
    });
}

public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute().RequireAuthorization();
    });
}

[AllowAnonymous]
public class HomeController : ControllerBase
{
    ...
}
```

Alternativ können alle Endpunkte so konfiguriert werden, dass Sie ohne `[Authorize]` oder `RequireAuthorization` durch Konfigurieren von `FallbackPolicy`eine Autorisierung erfordern. Der `FallbackPolicy` unterscheidet sich `DefaultPolicy`vom. `FallbackPolicy` Wird von `[Authorize]` oder`RequireAuthorization`ausgelöst, während das ausgelöst wird, wenn keine andere Richtlinie festgelegt ist. `DefaultPolicy` `FallbackPolicy`ist anfänglich so konfiguriert, dass Anforderungen ohne Autorisierung zugelassen werden.

Das folgende Beispiel ist identisch mit dem vorherigen `DefaultPolicy` Beispiel `FallbackPolicy` , verwendet jedoch, um immer eine Authentifizierung für alle Endpunkte anzufordern, `[AllowAnonymous]` außer wenn angegeben ist:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    ...

    services.AddAuthorization(options =>
    {
        options.FallbackPolicy = new AuthorizationPolicyBuilder()
          .RequireAuthenticatedUser()
          .RequireScope("MyScope")
          .Build();
    });
}

public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

[AllowAnonymous]
public class HomeController : ControllerBase
{
    ...
}
```

Die Autorisierung durch Middleware funktioniert, ohne dass das Framework über bestimmte Kenntnisse der Autorisierung verfügt. Integritäts [Prüfungen](xref:host-and-deploy/health-checks) haben beispielsweise keine spezifischen Kenntnisse der Autorisierung, aber Integritätsprüfungen können eine konfigurierbare Autorisierungs Richtlinie aufweisen, die von der Middleware angewendet wird.

Außerdem kann jeder Endpunkt seine Autorisierungs Anforderungen anpassen. Im folgenden Beispiel `UseAuthorization` wird die Autorisierung mit der `DefaultPolicy`verarbeitet, aber der `/healthz` Integritätsprüfung- `admin` Endpunkt erfordert einen Benutzer:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints
            .MapHealthChecks("/healthz")
            .RequireAuthorization(new AuthorizeAttribute(){ Roles = "admin", });
    });
}
```

Der Schutz wird für einige Szenarien implementiert. `UseEndpoint`Middleware löst eine Ausnahme aus, wenn eine Autorisierungs-oder cors-Richtlinie aufgrund fehlender Middleware übersprungen wird. Analyse Unterstützung, um zusätzliches Feedback zur Fehlkonfiguration bereitzustellen.

### <a name="signalr"></a>SignalR

Die Zuordnung von signalr Hubs erfolgt nun in `UseEndpoints`.

Ordnen Sie jeden Hub `MapHub`mit zu. Wie in früheren Versionen wird jeder Hub explizit aufgelistet.

Im folgenden Beispiel wird die Unterstützung für `ChatHub` den signalr-Hub hinzugefügt:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>();
    });
}
```

Es gibt eine neue Option zum Steuern von Größenbeschränkungen für Nachrichten von Clients. Beispiel: in `Startup.ConfigureServices`:

```csharp
services.AddSignalR(hubOptions =>
{
    hubOptions.MaximumReceiveMessageSize = 32768;
});
```

In ASP.net Core 2.2 konnten Sie die `TransportMaxBufferSize` festlegen, wodurch die maximale Nachrichtengröße effektiv gesteuert werden kann. In ASP.NET Core 3.0 steuert diese Option jetzt nur die maximale Größe, bevor der Rückstau festgestellt wird.

### <a name="mvc-controllers"></a>MVC-Controller

Die Zuordnung von Controllern erfolgt nun `UseEndpoints`in.

Fügen Sie `MapControllers` hinzu, wenn die App Attributrouting verwendet. Da das Routing Unterstützung für viele Frameworks in ASP.NET Core 3.0 oder höher bietet, ist das Hinzufügen von Controllern mit Attributrouting eine Option.

Ersetzen Sie Folgendes:

* `MapRoute`entspricht`MapControllerRoute`
* `MapAreaRoute`entspricht`MapAreaControllerRoute`

Da das Routing nun die Unterstützung für mehr als nur MVC umfasst, hat sich die Terminologie geändert, damit diese Methoden deutlich erkennen können, was Sie tun. Herkömmliche `MapControllerRoute` Routen wie `MapAreaControllerRoute` werden in / der Reihenfolge angewendet, in der Sie hinzugefügt werden. / `MapDefaultControllerRoute` Platzieren Sie zunächst spezifischere Routen (z. b. Routen für einen Bereich).

Im folgenden Beispiel:

* `MapControllers`Fügt Unterstützung für Attribut Weiterleitungs Controller hinzu.
* `MapAreaControllerRoute`Fügt eine konventionelle Route für Controller in einem Bereich hinzu.
* `MapControllerRoute`Fügt eine konventionelle Route für Controller hinzu.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapControllers();
        endpoints.MapAreaControllerRoute(
            "admin",
            "admin",
            "Admin/{controller=Home}/{action=Index}/{id?}");
        endpoints.MapControllerRoute(
            "default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

### <a name="razor-pages"></a>Razor Pages

Die Zuordnung Razor Pages jetzt innerhalb `UseEndpoints`von stattfinden.

Fügen `MapRazorPages` Sie hinzu, wenn die APP Razor Pages verwendet. Da das Endpunkt Routing Unterstützung für viele Frameworks umfasst, ist das Hinzufügen von Razor Pages jetzt deaktiviert.

In der folgenden `Startup.Configure` `MapRazorPages` Methode fügt Unterstützung für Razor Pages hinzu:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapRazorPages();
    });
}
```

### <a name="use-mvc-without-endpoint-routing"></a>Verwenden von MVC ohne Endpunkt Routing

Die Verwendung von MVC über`UseMvc` oder`UseMvcWithDefaultRoute` in ASP.NET Core 3.0 erfordert ein explizites Opt-in in `Startup.ConfigureServices`. Dies ist erforderlich, da MVC wissen muss, ob während der Initialisierung auf die Autorisierung und die CORS-Middleware zurückgegriffen werden kann. Es wird ein Analyzer bereitgestellt, der warnt, wenn die App versucht, eine nicht unterstützte Konfiguration zu verwenden.

Wenn die APP Legacy `IRouter` Unterstützung erfordert, deaktivieren `EnableEndpointRouting` Sie die Verwendung der folgenden Ansätze in: `Startup.ConfigureServices`

```csharp
services.AddMvc(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddControllers(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddControllersWithViews(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddRazorPages().AddMvcOptions(options => options.EnableEndpointRouting = false);
```

### <a name="health-checks"></a>Integritätsprüfungen

Integritätsprüfungen können als *routerware* mit Endpunkt Routing verwendet werden.

Fügen `MapHealthChecks` Sie hinzu, um Integritätsprüfungen mit Endpunkt Routing zu verwenden. Die `MapHealthChecks` -Methode akzeptiert Argumente `UseHealthChecks`ähnlich wie. Der Vorteil der Verwendung `MapHealthChecks` von `UseHealthChecks` over ist die Fähigkeit, Autorisierung anzuwenden und eine präzisere Kontrolle über die abgleichsrichtlinie zu haben.

Im folgenden Beispiel `MapHealthChecks` wird für einen Integritäts Prüf `/healthz`Punkt aufgerufen:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHealthChecks("/healthz", new HealthCheckOptions() { });
    });
}
```

## <a name="hostbuilder-replaces-webhostbuilder"></a>Der hostbuilder ersetzt webhostbuilder.

Die ASP.NET Core 3.0-Vorlagen verwenden den [generischen Host](xref:fundamentals/host/generic-host). In früheren Versionen wurde der [Webhost](xref:fundamentals/host/web-host) verwendet. Der folgende Code zeigt die von der ASP.NET Core 3.0 generierte `Program`-Klasse:

[!code-csharp[](22-to-30/samples/Program.cs?name=snippet)]

Der folgende Code zeigt die von der Vorlage generierte `Program`-Klasse für ASP.NET Core 2.2:

[!code-csharp[](22-to-30/samples/Program2.2.cs?name=snippet)]

<xref:Microsoft.AspNetCore.Hosting.IWebHostBuilder> verbleibt in Version 3.0 und ist der Typ von `webBuilder`, der im vorangehenden Codebeispiel dargestellt ist. <xref:Microsoft.AspNetCore.Hosting.WebHostBuilder> wird in einer zukünftigen Version als veraltet markiert und durch `HostBuilder`ersetzt.

Die signifikanteste Änderung `WebHostBuilder` von `HostBuilder` in ist die [Abhängigkeitsinjektion (di)](xref:fundamentals/dependency-injection). Wenn Sie `HostBuilder`verwenden, können Sie nur <xref:Microsoft.Extensions.Configuration.IConfiguration> den <xref:Microsoft.AspNetCore.Hosting.IHostingEnvironment> Konstruktor von und in `Startup`einfügen. Die `HostBuilder` di-Einschränkungen:

* Aktivieren Sie den di-Container nur ein einziges Mal.
* Vermeidet die resultierenden Probleme bei der Objekt Lebensdauer wie das Auflösen mehrerer Instanzen von Singletons.

## <a name="addauthorization-moved-to-a-different-assembly"></a>Addauthorization in eine andere Assembly verschoben

Die `AddAuthorization`-Methoden für ASP.NET 2.2 und niedriger in *Microsoft.AspNetCore.Authorization.dll*:

* Wurden umbenannt `AddAuthorizationCore`.
* Wurden in " *Microsoft. aspnetcore. Authorization. Policy. dll*" verschoben.

Apps, die sowohl *Microsoft. aspnetcore. Authorization. dll* als auch *Microsoft. aspnetcore. Authorization. Policy. dll* verwenden, sind nicht betroffen.

Apps, die nicht *Microsoft. aspnetcore. Authorization. Policy. dll* verwenden, sollten eine der folgenden Aktionen ausführen:

* Wechseln zu mithilfe von`AddAuthorizationCore`
* Fügen Sie einen Verweis auf *Microsoft. aspnetcore. Authorization. Policy. dll*hinzu.

Weitere Informationen finden Sie unter [Breaking Change in `AddAuthorization(o =>`(Breaking Change in) der Überlastung in einer anderen Assembly #386](https://github.com/aspnet/Announcements/issues/386).

## <a name="signalr"></a>SignalR

Der signalr-JavaScript-Client wurde `@aspnet/signalr` von `@microsoft/signalr`in geändert. Um auf diese Änderung zu reagieren, ändern Sie die Verweise in " *Package. JSON* "-Dateien, `require` -Anweisungen und ECMAScript `import` -Anweisungen.

### <a name="systemtextjson-is-the-default-protocol"></a>"System. Text. JSON" ist das Standardprotokoll.

`System.Text.Json`ist nun das Standardhub Protokoll, das sowohl vom Client als auch vom Server verwendet wird.

In `Startup.ConfigureServices`wird aufgerufen `AddJsonProtocol` , um Serialisierungsoptionen festzulegen.

**Servers**

```csharp
services.AddSignalR(...)
        .AddJsonProtocol(options =>
        {
            options.WriteIndented = false;
        })
```

**Ent**

```csharp
new HubConnectionBuilder()
    .WithUrl("/chatHub")
    .AddJsonProtocol(options =>
    {
        options.WriteIndented = false;
    })
    .Build();
```

### <a name="switch-to-newtonsoftjson"></a>Wechseln Sie zu "newtonsoft. JSON".

Wenn Sie Funktionen von `Newtonsoft.Json` verwenden, die in `System.Text.Json`nicht unterstützt werden, können Sie zurück `Newtonsoft.Json`zu folgenden Aktionen wechseln:

1. Installieren Sie das nuget-Paket [Microsoft. aspnetcore. signalr. Protokolls. newtonsoft JSON](https://www.nuget.org/packages/Microsoft.AspNetCore.SignalR.Protocols.NewtonsoftJson) .
1. Verketten Sie auf dem Client `AddNewtonsoftJsonProtocol` einen Methoden Aufrufder `HubConnectionBuilder` -Instanz:

    ```csharp
    new HubConnectionBuilder()
        .WithUrl("/chatHub")
        .AddNewtonsoftJsonProtocol(...)
        .Build();
    ```

1. Verketten Sie auf dem- `AddNewtonsoftJsonProtocol` Server einen Methodenaufrufe `AddSignalR` des-Methoden `Startup.ConfigureServices`Aufrufes in:

    ```csharp
    services.AddSignalR()
        .AddNewtonsoftJsonProtocol(...);
    ```

## <a name="opt-in-to-runtime-compilation"></a>Abonnieren der Lauf Zeit Kompilierung

In 3,0 ist die Lauf Zeit Kompilierung ein Opt-in-Szenario. Informationen zum Aktivieren der Lauf Zeit <xref:mvc/views/view-compilation#runtime-compilation>Kompilierung finden Sie unter.

## <a name="migrating-libraries-via-multi-targeting"></a>Migrieren von Bibliotheken per Zielvorgabe

Bibliotheken müssen häufig mehrere Versionen von ASP.net Core unterstützen. Die meisten Bibliotheken, die für frühere Versionen von ASP.net Core kompiliert wurden, sollten ohne Probleme weiterhin funktionieren. Die folgenden Bedingungen erfordern eine Kreuz Kompilierung der APP:

* Die Bibliothek basiert auf einer Funktion, die über eine binäre [Breaking Change](#breaking-api-changes)verfügt.
* Die Bibliothek möchte die neuen Features in ASP.net Core 3,0 nutzen. 

Beispiel:

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFrameworks>netcoreapp3.0;netstandard2.0</TargetFrameworks>
  </PropertyGroup>

  <ItemGroup Condition="'$(TargetFramework)' == 'netcoreapp3.0'">
    <FrameworkReference Include="Microsoft.AspNetCore.App" />
  </ItemGroup>

  <ItemGroup Condition="'$(TargetFramework)' == 'netstandard2.0'">
    <PackageReference Include="Microsoft.AspNetCore" Version="2.1.0" />
  </ItemGroup>
</Project>
```

Verwenden `#ifdefs` Sie, um ASP.net Core 3,0-spezifische APIs zu aktivieren:

```csharp
var webRootFileProvider =
#if NETCOREAPP3_0
    GetRequiredService<IWebHostEnvironment>().WebRootFileProvider;
#else if NETSTANDARD2_0
    GetRequiredService<IHostingEnvironment>().WebRootFileProvider;
#else
#error unknown target framework
#endif
```

## <a name="breaking-api-changes"></a>Wichtige API-Änderungen

* [Umfassende Liste der wichtigen Änderungen in der Version ASP.net Core 3,0](https://github.com/aspnet/Announcements/issues?page=2&q=is%3Aissue+is%3Aopen+label%3A%22Breaking+change%22+label%3A3.0.0)
* [Unterbrechen von API-Änderungen in Antifälschung, cors, Diagnose, MVC und Routing](https://github.com/aspnet/Announcements/issues/387). Diese Liste enthält wichtige Änderungen für Kompatibilitäts Switches.
* Eine Zusammenfassung 2,2-zu-3,0-Änderungen in .net Core, ASP.net Core und Entity Framework Core finden Sie unter [Breaking Changes for Migration from Version 2,2 to 3,0](/dotnet/core/compatibility/2.2-3.0).

## <a name="aspnet-core-30-not-currently-available-for-azure-app-service"></a>ASP.net Core 3,0 ist zurzeit für Azure App Service nicht verfügbar.

Wir hoffen, dies bald zur Verfügung zu stellen. Bis ASP.net Core 3,0 auf Azure App Service verfügbar ist, befolgen Sie die Anweisungen unter Bereitstellen [ASP.net Core Vorschauversion Azure App Service](xref:host-and-deploy/azure-apps/index#deploy-aspnet-core-preview-release-to-azure-app-service).

## <a name="mysqldataentityframeworkcore-currently-not-supported-on-aspnet-core-30"></a>MySQL. Data. entityframeworkcore wird derzeit auf ASP.net Core 3,0 nicht unterstützt.

Weitere Informationen finden Sie unter [GitHub-Problem](https://github.com/aspnet/EntityFrameworkCore/issues/17788).
