---
title: Migrieren von ASP.net Core 2,2 zu 3,0
author: rick-anderson
description: Erfahren Sie, wie Sie ein ASP.net Core 2,2-Projekt zu ASP.net Core 3,0 migrieren.
ms.author: riande
ms.custom: mvc
ms.date: 05/03/2020
no-loc:
- Blazor
- Identity
- Let's Encrypt
- Razor
- SignalR
uid: migration/22-to-30
ms.openlocfilehash: 5156e21cd33e6779ef005c9a12dec6be4685d485
ms.sourcegitcommit: 70e5f982c218db82aa54aa8b8d96b377cfc7283f
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 05/04/2020
ms.locfileid: "82777240"
---
# <a name="migrate-from-aspnet-core-22-to-30"></a>Migrieren von ASP.net Core 2,2 zu 3,0

Von [Scott Adder](https://github.com/scottaddie) und [Rick Anderson](https://twitter.com/RickAndMSFT)

In diesem Artikel wird erläutert, wie ein vorhandenes ASP.net Core 2,2-Projekt auf ASP.net Core 3,0 aktualisiert wird. Es ist möglicherweise hilfreich, ein neues ASP.net Core 3,0-Projekt zu erstellen:

* Vergleichen Sie mit dem ASP.net Core 2,2-Code.
* Kopieren Sie die relevanten Änderungen in das Projekt ASP.net Core 3,0.

## <a name="prerequisites"></a>Voraussetzungen

# <a name="visual-studio"></a>[Visual Studio](#tab/visual-studio)

[!INCLUDE[](~/includes/net-core-prereqs-vs-3.0.md)]

# <a name="visual-studio-code"></a>[Visual Studio Code](#tab/visual-studio-code)

[!INCLUDE[](~/includes/net-core-prereqs-vsc-3.0.md)]

# <a name="visual-studio-for-mac"></a>[Visual Studio für Mac](#tab/visual-studio-mac)

[!INCLUDE[](~/includes/net-core-prereqs-mac-3.0.md)]

---

## <a name="update-net-core-sdk-version-in-globaljson"></a>Aktualisieren der .NET Core SDK-Version in „global.json“

Wenn Ihre Lösung auf eine [globale. JSON](/dotnet/core/tools/global-json) -Datei basiert, um eine bestimmte .net Core SDK Version zu erreichen `version` , aktualisieren Sie Ihre-Eigenschaft auf die Version 3,0, die auf Ihrem Computer installiert ist:

```json
{
  "sdk": {
    "version": "3.0.100"
  }
}
```

## <a name="update-the-project-file"></a>Aktualisieren der Projektdatei

### <a name="update-the-target-framework"></a>Aktualisieren des Ziel Frameworks

ASP.net Core 3,0 und höher wird nur unter .net Core ausgeführt. Legen Sie für `netcoreapp3.0`den [zielframeworkmoniker (TFM)](/dotnet/standard/frameworks) Folgendes fest:

[!code-xml[](22-to-30/samples/Web1.csproj?highlight=4)]

### <a name="remove-obsolete-package-references"></a>Veraltete Paket Verweise entfernen

Eine große Anzahl von nuget-Paketen wird nicht für ASP.net Core 3,0 erstellt. Solche Paket Verweise sollten aus der Projektdatei entfernt werden. Sehen Sie sich die folgende Projektdatei für eine ASP.net Core 2,2-Web-App an:

```xml
<Project Sdk="Microsoft.NET.Sdk.Web">

  <PropertyGroup>
    <TargetFramework>netcoreapp2.2</TargetFramework>
    <AspNetCoreHostingModel>InProcess</AspNetCoreHostingModel>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.AspNetCore.App"/>
    <PackageReference Include="Microsoft.AspNetCore.Razor.Design" Version="2.2.0" PrivateAssets="All" />
  </ItemGroup>

</Project>
```

Die aktualisierte Projektdatei für ASP.net Core 3,0:

[!code-xml[](22-to-30/samples/Web1.csproj?highlight=4)]

Die aktualisierte ASP.net Core 3,0-Projektdatei:

* In `<PropertyGroup>`:
  * Aktualisiert den TFM auf`netcoreapp3.0`
  * Entfernt das `<AspNetCoreHostingModel>` -Element. Weitere Informationen finden Sie unter [in-Process-Hostingmodell](#in-process-hosting-model) in diesem Dokument.

* In `<ItemGroup>`:
  * `Microsoft.AspNetCore.App`wurde entfernt. Weitere Informationen finden Sie in diesem Dokument in der [frameworkreferenz](#framework-reference) .
  * `Microsoft.AspNetCore.Razor.Design`wurde entfernt und in der folgenden Liste von Paketen, die nicht mehr erstellt werden.

Um die vollständige Liste der Pakete anzuzeigen, die nicht mehr erstellt werden, wählen Sie die folgende Erweiterungs Liste aus:

<details>
    <summary>Klicken Sie, um die Liste der Pakete zu erweitern, die nicht mehr erstellt werden</summary>
    <ul>
        <li>Microsoft.AspNetCore</li>
        <li>Microsoft.AspNetCore.All</li>
        <li>Microsoft.AspNetCore.App</li>
        <li>Microsoft.AspNetCore.Antiforgery</li>
        <li>Microsoft.AspNetCore.Authentication</li>
        <li>Microsoft.AspNetCore.Authentication.Abstractions</li>
        <li>Microsoft.AspNetCore.Authentication.Cookies</li>
        <li>Microsoft.AspNetCore.Authentication.Core</li>
        <li>Microsoft.AspNetCore.Authentication.OAuth</li>
        <li>Microsoft.AspNetCore.Authorization.Policy</li>
        <li>Microsoft.AspNetCore.CookiePolicy</li>
        <li>Microsoft.AspNetCore.Cors</li>
        <li>Microsoft.AspNetCore.Diagnostics</li>
        <li>Microsoft.AspNetCore.Diagnostics.HealthChecks</li>
        <li>Microsoft.AspNetCore.HostFiltering</li>
        <li>Microsoft.AspNetCore.Hosting</li>
        <li>Microsoft.AspNetCore.Hosting.Abstractions</li>
        <li>Microsoft.AspNetCore.Hosting.Server.Abstractions</li>
        <li>Microsoft.AspNetCore.Http</li>
        <li>Microsoft.AspNetCore.Http.Abstractions</li>
        <li>Microsoft.AspNetCore.Http.Connections</li>
        <li>Microsoft.AspNetCore.Http.Extensions</li>
        <li>Microsoft.AspNetCore.HttpOverrides</li>
        <li>Microsoft.AspNetCore.HttpsPolicy</li>
        <li>Microsoft. aspnetcore.Identity</li>
        <li>Microsoft.AspNetCore.Localization</li>
        <li>Microsoft.AspNetCore.Localization.Routing</li>
        <li>Microsoft.AspNetCore.Mvc</li>
        <li>Microsoft.AspNetCore.Mvc.Abstractions</li>
        <li>Microsoft.AspNetCore.Mvc.Analyzers</li>
        <li>Microsoft.AspNetCore.Mvc.ApiExplorer</li>
        <li>Microsoft.AspNetCore.Mvc.Api.Analyzers</li>
        <li>Microsoft.AspNetCore.Mvc.Core</li>
        <li>Microsoft.AspNetCore.Mvc.Cors</li>
        <li>Microsoft.AspNetCore.Mvc.DataAnnotations</li>
        <li>Microsoft.AspNetCore.Mvc.Formatters.Json</li>
        <li>Microsoft.AspNetCore.Mvc.Formatters.Xml</li>
        <li>Microsoft.AspNetCore.Mvc.Localization</li>
        <li>Microsoft. aspnetcore. MVC.Razor</li>
        <li>Microsoft. aspnetcore. MVC. Razor. Viewcompilation</li>
        <li>Microsoft.AspNetCore.Mvc.RazorPages</li>
        <li>Microsoft.AspNetCore.Mvc.TagHelpers</li>
        <li>Microsoft.AspNetCore.Mvc.ViewFeatures</li>
        <li>Microsoft. aspnetcore.Razor</li>
        <li>Microsoft. aspnetcore. Razor. Runtime</li>
        <li>Microsoft. aspnetcore. Razor. Ausge</li>
        <li>Microsoft.AspNetCore.ResponseCaching</li>
        <li>Microsoft.AspNetCore.ResponseCaching.Abstractions</li>
        <li>Microsoft.AspNetCore.ResponseCompression</li>
        <li>Microsoft.AspNetCore.Rewrite</li>
        <li>Microsoft.AspNetCore.Routing</li>
        <li>Microsoft.AspNetCore.Routing.Abstractions</li>
        <li>Microsoft.AspNetCore.Server.HttpSys</li>
        <li>Microsoft.AspNetCore.Server.IIS</li>
        <li>Microsoft.AspNetCore.Server.IISIntegration</li>
        <li>Microsoft.AspNetCore.Server.Kestrel</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Core</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Https</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets</li>
        <li>Microsoft.AspNetCore.Session</li>
        <li>Microsoft. aspnetcore.SignalR</li>
        <li>Microsoft. aspnetcore. SignalR. Core</li>
        <li>Microsoft.AspNetCore.StaticFiles</li>
        <li>Microsoft.AspNetCore.WebSockets</li>
        <li>Microsoft.AspNetCore.WebUtilities</li>
        <li>Microsoft.Net.Http.Headers </li>
    </ul>
</details>

### <a name="review-breaking-changes"></a>Wichtige Änderungen überprüfen

[Wichtige Änderungen überprüfen](#break)

### <a name="framework-reference"></a>Frameworkverweis

Features von ASP.net Core, die über eines der oben aufgeführten Pakete verfügbar waren, sind als Teil des frei `Microsoft.AspNetCore.App` gegebenen Frameworks verfügbar. Das *freigegebene Framework* ist der Satz von Assemblys (*DLL*-Dateien), die auf dem Computer installiert werden und eine Laufzeitkomponente sowie ein Zielpaket enthalten. Weitere Informationen finden Sie unter [The shared framework](https://natemcmaster.com/blog/2018/08/29/netcore-primitives-2/) (Das freigegebene Framework).

* Projekte, die auf das `Microsoft.NET.Sdk.Web` SDK abzielen, verweisen implizit auf das `Microsoft.AspNetCore.App`-Framework.

  Für diese Projekte sind keine weiteren Verweise erforderlich:

  ```xml
  <Project Sdk="Microsoft.NET.Sdk.Web">
    <PropertyGroup>
      <TargetFramework>netcoreapp3.0</TargetFramework>
    </PropertyGroup>
      ...
  </Project>
  ```

* Projekte, die `Microsoft.NET.Sdk` das `Microsoft.NET.Sdk.Razor` Ziel oder das SDK sind, `FrameworkReference` sollten `Microsoft.AspNetCore.App`eine explizite zu folgenden hinzufügen:

  ```xml
  <Project Sdk="Microsoft.NET.Sdk.Razor">
    <PropertyGroup>
      <TargetFramework>netcoreapp3.0</TargetFramework>
    </PropertyGroup>

    <ItemGroup>
      <FrameworkReference Include="Microsoft.AspNetCore.App" />
    </ItemGroup>
      ...
  </Project>
  ```

#### <a name="framework-dependent-builds-using-docker"></a>Framework-abhängige Builds mithilfe von Docker

Framework-abhängige Builds von Konsolen-apps, die ein Paket verwenden, das vom ASP.net Core [Shared Framework](https://natemcmaster.com/blog/2018/08/29/netcore-primitives-2/) abhängt, können den folgenden Laufzeitfehler verursachen:

```console
It was not possible to find any compatible framework version
The specified framework 'Microsoft.AspNetCore.App', version '3.0.0' was not found.
  - No frameworks were found.
```

`Microsoft.AspNetCore.App`ist das freigegebene Framework, das die ASP.net Core Runtime enthält und nur auf dem docker-Image [dotnet/Core/ASPNET](https://hub.docker.com/_/microsoft-dotnet-core-aspnet/) vorhanden ist. Das 3,0 SDK reduziert die Größe von Framework-abhängigen Builds mit ASP.net Core, indem doppelte Kopien von Bibliotheken, die im freigegebenen Framework verfügbar sind, nicht eingeschlossen werden. Dies ist eine potenzielle Einsparung von bis zu 18 MB, aber es ist erforderlich, dass die ASP.net Core-Laufzeit zum Ausführen der app vorhanden bzw. installiert ist.

Überprüfen Sie die *runtimeconfig. JSON* -Datei, die während der Erstellung/Veröffentlichung Ihrer APP generiert wird, um zu bestimmen, ob die APP eine Abhängigkeit (entweder direkt oder indirekt) auf dem ASP.net Core freigegebenen Framework aufweist. Die folgende JSON-Datei zeigt eine Abhängigkeit vom ASP.net Core Shared Framework:

```json
{
  "runtimeOptions": {
    "tfm": "netcoreapp3.0",
    "framework": {
      "name": "Microsoft.AspNetCore.App",
      "version": "3.0.0"
    },
    "configProperties": {
      "System.GC.Server": true
    }
  }
}
```

Wenn Ihre APP docker verwendet, verwenden Sie ein Basis Image, das ASP.net Core 3,0 enthält. Beispiel: `docker pull mcr.microsoft.com/dotnet/core/aspnet:3.0`.

### <a name="add-package-references-for-removed-assemblies"></a>Paket Verweise für entfernte Assemblys hinzufügen

ASP.net Core 3,0 entfernt einige Assemblys, die zuvor Teil `Microsoft.AspNetCore.App` des Paket Verweises waren. Um zu visualisieren, welche Assemblys entfernt wurden, vergleichen Sie die beiden freigegebenen frameworkordner Beispielsweise ein Vergleich der Versionen 2.2.7 und 3.0.0:

![Vergleich von Shared Framework](22-to-30/_static/assembly-diff.png)

Um die von den entfernten Assemblys bereitgestellten Funktionen weiterhin zu verwenden, verweisen Sie auf die 3,0-Versionen der entsprechenden Pakete:

* Bei einer Vorlagen generierten Web-App mit **einzelnen Benutzerkonten** müssen die folgenden Pakete hinzugefügt werden:

  [!code-xml[](22-to-30/samples/WebFull.csproj?highlight=9-13)]

* [Microsoft.EntityFrameworkCore](https://www.nuget.org/packages/Microsoft.EntityFrameworkCore)

  Weitere Informationen zum Verweisen auf das Datenbankanbieter spezifische Paket finden Sie unter [Datenbankanbieter](/ef/core/providers/index).

* Benutzeroberfläche von Identity

  Unterstützung für [ Identity die Benutzeroberfläche](xref:security/authentication/identity) kann durch Verweisen auf [Microsoft. aspnetcore.Identityhinzugefügt werden. UI](https://www.nuget.org/packages/Microsoft.AspNetCore.Identity.UI) -Paket.

* Spa-Dienste

  * [Microsoft.AspNetCore.SpaServices](https://www.nuget.org/packages/Microsoft.AspNetCore.SpaServices)
  * [Microsoft. aspnetcore. Spaservices. Extensions](https://www.nuget.org/packages/Microsoft.AspNetCore.SpaServices.Extensions)

* Die &ndash; Authentifizierungs Unterstützung für Authentifizierungs Abläufe von Drittanbietern ist als nuget-Pakete verfügbar:

  * Facebook OAuth ([Microsoft. aspnetcore. Authentication. Facebook](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Facebook))
  * Google OAuth ([Microsoft. aspnetcore. Authentication. Google](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Google))
  * Microsoft-Konto Authentifizierung ([Microsoft. aspnetcore. Authentication. microsoftaccount](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.MicrosoftAccount))
  * OpenID Connect-Authentifizierung ([Microsoft. aspnetcore. Authentication. openidconnect](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.OpenIdConnect))
  * OpenID Connect-bearertoken ([Microsoft. aspnetcore. Authentication. jwtbearertoken](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.JwtBearer))
  * Twitter OAuth ([Microsoft. aspnetcore. Authentication. Twitter](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Twitter))
  * Wsfederation-Authentifizierung ([Microsoft. aspnetcore. Authentication. wsfederation](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.WsFederation))

* Die Unterstützung von Formatierung und `System.Net.HttpClient` &ndash; Inhaltsaushandlung für das nuget-Paket " [Microsoft. Aspnet. WebAPI. Client](https://www.nuget.org/packages/Microsoft.AspNet.WebApi.Client/) " bietet eine `ReadAsAsync` nützliche `PostJsonAsync`Erweiterbarkeit für `System.Net.HttpClient` mit APIs wie und.

* Razordie unter &ndash; Stützung der Lauf Zeit Kompilierung für die Lauf Zeit Kompilierung von Razor Sichten und Seiten ist nun Bestandteil von [Microsoft. aspnetcore. MVC.Razor Runtimecompilation](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Razor.RuntimeCompilation).

* MVC `Newtonsoft.Json` -unter &ndash; Stützung (JSON.net) Unterstützung für die `Newtonsoft.Json` Verwendung von MVC mit ist nun Bestandteil von [Microsoft. aspnetcore. MVC. newtonsoftware](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson).

## <a name="startup-changes"></a>Start Änderungen

Die folgende Abbildung zeigt die gelöschten und geänderten Zeilen in einer ASP.net Core Razor -Web-App mit 2,2-Seiten:

![die gelöschten und geänderten Zeilen in einer ASP.net Core Razor 2,2-Web-App](22-to-30/_static/startup2.2.png)

In der vorangehenden Abbildung ist gelöschter Code rot dargestellt. Der gelöschte Code zeigt keinen Code für Cookie-Optionen an, der vor dem Vergleichen der Dateien gelöscht wurde.

In der folgenden Abbildung werden die hinzugefügten und geänderten Zeilen in Razor einer ASP.net Core-Web-App mit 3,0-Seiten angezeigt

![die hinzugefügten und geänderten Zeilen in einer Razor ASP.net Core 3,0-Web-App](22-to-30/_static/startup3.0.png)

In der vorangehenden Abbildung ist der hinzugefügte Code grün dargestellt. Weitere Informationen zu den folgenden Änderungen:

* `services.AddMvc`Informationen `services.AddRazorPages`zu finden Sie unter [MVC-Dienst Registrierung](#mvc-service-registration) in diesem Dokument.
* `CompatibilityVersion`finden <xref:mvc/compatibility-version>Sie unter.
* `IHostingEnvironment`zu `IWebHostEnvironment`finden Sie [diese GitHub-Ankündigung](https://github.com/dotnet/AspNetCore/issues/7749).
* `app.UseAuthorization`wurde den Vorlagen hinzugefügt, um anzuzeigen, dass die Middleware für die Bestell Autorisierung hinzugefügt werden muss. Wenn die APP keine Autorisierung verwendet, können Sie den-Befehl problemlos `app.UseAuthorization`entfernen.
* `app.UseEndpoints`finden [ Razor ](#razor-pages) Sie in diesem Dokument Unterseiten oder [Migrieren von "Startup. configure](#migrate-startupconfigure) ".

### <a name="analyzer-support"></a>Analyse Unterstützung

Projekte, die `Microsoft.NET.Sdk.Web` implizit auf Analysen abzielen, die zuvor als Teil des Pakets [Microsoft. aspnetcore. MVC. Analysen](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Analyzers/) ausgeliefert wurden. Es sind keine zusätzlichen Verweise erforderlich, um diese zu aktivieren.

Wenn Ihre APP [API-Analysen](xref:web-api/advanced/analyzers) verwendet, die zuvor mit dem Paket [Microsoft. aspnetcore. MVC. API. Analysen](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Api.Analyzers/) ausgeliefert wurden, bearbeiten Sie die Projektdatei so, dass Sie auf die Analysen verweist, die als Teil des .net Core Web SDK ausgeliefert werden:

```xml
<Project Sdk="Microsoft.NET.Sdk.Web">
    <PropertyGroup>
        <TargetFramework>netcoreapp3.0</TargetFramework>
        <IncludeOpenAPIAnalyzers>true</IncludeOpenAPIAnalyzers>
    </PropertyGroup>

    ...
</Project>
```

### <a name="razor-class-library"></a>RazorKlassenbibliothek

RazorIn Klassen Bibliotheks Projekten, die Benutzeroberflächen Komponenten für MVC bereit `AddRazorSupportForMvc` stellen, muss die-Eigenschaft in der Projektdatei festgelegt werden:

```xml
<PropertyGroup>
  <AddRazorSupportForMvc>true</AddRazorSupportForMvc>
</PropertyGroup>
```

### <a name="in-process-hosting-model"></a>In-Process-Hostingmodell

-Projekte werden standardmäßig in ASP.net Core 3,0 oder höher auf das [in-Process-Hostingmodell](xref:host-and-deploy/aspnet-core-module#in-process-hosting-model) eingestellt. Wenn der Wert lautet `<AspNetCoreHostingModel>` `InProcess`, können Sie optional die-Eigenschaft in der Projektdatei entfernen.

## <a name="kestrel"></a>Kestrel

### <a name="configuration"></a>Konfiguration

Migrieren Sie die Kestrel-Konfiguration zum von `ConfigureWebHostDefaults` bereitgestellten [Webhost](#hostb) -Generator (*Program.cs*):

```csharp
public static IHostBuilder CreateHostBuilder(string[] args) =>
    Host.CreateDefaultBuilder(args)
        .ConfigureWebHostDefaults(webBuilder =>
        {
            webBuilder.ConfigureKestrel(serverOptions =>
            {
                // Set properties and call methods on options
            })
            .UseStartup<Startup>();
        });
```

Wenn die APP den Host mit `HostBuilder`manuell erstellt, müssen `UseKestrel` Sie auf dem Webhost- `ConfigureWebHostDefaults`Generator in folgenden Befehl ausführen:

```csharp
public static void Main(string[] args)
{
    var host = new HostBuilder()
        .UseContentRoot(Directory.GetCurrentDirectory())
        .ConfigureWebHostDefaults(webBuilder =>
        {
            webBuilder.UseKestrel(serverOptions =>
            {
                // Set properties and call methods on options
            })
            .UseIISIntegration()
            .UseStartup<Startup>();
        })
        .Build();

    host.Run();
}
```

### <a name="connection-middleware-replaces-connection-adapters"></a>Verbindungs-Middleware ersetzt Verbindungs Adapter

Verbindungs Adapter (`Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.IConnectionAdapter`) wurden aus Kestrel entfernt. Ersetzen Sie Verbindungs Adapter durch Verbindungs Middleware. Die Verbindungs Middleware ähnelt http-Middleware in der ASP.net Core Pipeline, aber für Verbindungen auf niedrigerer Ebene. HTTPS und Verbindungs Protokollierung:

* Wurden von Verbindungs Adaptern zur Verbindungs Middleware verschoben.
* Diese Erweiterungs Methoden funktionieren wie in früheren Versionen von ASP.net Core. 

Weitere Informationen finden Sie [im Abschnitt "tlsfilterconnectionhandler" im Abschnitt "listenoptions. Protokolls" im Kestrel-Artikel](/aspnet/core/fundamentals/servers/kestrel?view=aspnetcore-3.0#listenoptionsprotocols).

### <a name="transport-abstractions-moved-and-made-public"></a>Transport Abstraktionen verschoben und öffentlich gemacht

Die Kestrel-Transportschicht wurde in `Connections.Abstractions` als öffentliche Schnittstelle verfügbar gemacht. Als Teil dieser Updates:

* `Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions`und zugeordnete Typen wurden entfernt.
* <xref:Microsoft.AspNetCore.Server.Kestrel.KestrelServerOptions.NoDelay>wurde von <xref:Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions> zu den Transport Optionen verschoben.
* `Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions.Internal.SchedulingMode`wurde aus <xref:Microsoft.AspNetCore.Server.Kestrel.KestrelServerOptions>entfernt.

Weitere Informationen finden Sie in den folgenden GitHub-Ressourcen:

* [Client/Server-Netzwerk Abstraktionen (dotnet/aspnetcore-#10308)](https://github.com/dotnet/AspNetCore/issues/10308)
* [Implementieren Sie die neue Fundament-Listener-Abstraktion und REPLAT Kestrel (dotnet/aspnetcore-#10321).](https://github.com/dotnet/AspNetCore/pull/10321)

### <a name="kestrel-request-trailer-headers"></a>Kestrel-Anforderungs Nachspann Header

Für apps, die auf frühere Versionen von ASP.net Core abzielen:

* Kestrel fügt der Auflistung der Anforderungs Header HTTP/1.1-Auflistungs Header hinzu.
* Nach dem Lesen des Anforderungs Texts sind die nach dem Ende des Anforderungs Texts verfügbar.

Dies bewirkt einige Bedenken bezüglich der Mehrdeutigkeit zwischen Headern und nach Spann, sodass die Nachspann in eine neue`RequestTrailerExtensions`Sammlung () in 3,0 verschoben wurden.

HTTP/2-Anforderungs Nachspann:

* Nicht verfügbar in ASP.net Core 2,2.
* Verfügbar in 3,0 als `RequestTrailerExtensions`.

Für den Zugriff auf diese Nachspann sind neue Anforderungs Erweiterungs Methoden vorhanden. Wie bei HTTP/1.1 sind Nachspann verfügbar, nachdem der Anforderungs Text bis zum Ende gelesen wurde.

Für die Version 3,0 sind die folgenden `RequestTrailerExtensions` Methoden verfügbar:

* `GetDeclaredTrailers`&ndash; Ruft den Anforderungs `Trailer` Header ab, der auflistet, welche Nachspann nach dem Text erwartet werden.
* `SupportsTrailers`&ndash; Gibt an, ob die Anforderung empfangende nach Spann Header unterstützt.
* `CheckTrailersAvailable`&ndash; Überprüft, ob die Anforderung Nachspann unterstützt und ob Sie zum Lesen verfügbar sind. Bei dieser Überprüfung wird nicht davon ausgegangen, dass zum Lesen von nach spannenden Möglicherweise gibt es keine zu lesenden Nachspann, auch wenn `true` von dieser Methode zurückgegeben wird.
* `GetTrailer`&ndash; Ruft den angeforderten nachfolgenden Header aus der Antwort ab. Über `SupportsTrailers` prüfen Sie `GetTrailer`vor dem Aufrufen <xref:System.NotSupportedException> von, oder kann eintreten, wenn die Anforderung keine nachfolgenden Header unterstützt.

Weitere Informationen finden Sie unter [Put Request Trailers in a separate Collection (dotnet/aspnetcore-#10410)](https://github.com/dotnet/AspNetCore/pull/10410).

### <a name="allowsynchronousio-disabled"></a>Allowsynchronousio deaktiviert

`AllowSynchronousIO`aktiviert oder deaktiviert synchrone e/a-APIs, wie `HttpRequest.Body.Read`z `HttpResponse.Body.Write`. b `Stream.Flush`., und. Diese APIs sind eine Quelle der Thread Hungersnot, die zu app-Abstürzen führt. In 3.0 ist `AllowSynchronousIO` standardmäßig deaktiviert. Weitere Informationen finden Sie [im Abschnitt "Synchrone e/a" im Kestrel-Artikel](/aspnet/core/fundamentals/servers/kestrel?view=aspnetcore-3.0#synchronous-io).

Wenn eine synchrone e/a erforderlich ist, kann Sie aktiviert werden, `AllowSynchronousIO` indem die-Option auf dem verwendeten Server konfiguriert `ConfigureKestrel`wird (z. b. bei Verwendung von Kestrel). Beachten Sie, dass Server (Kestrel, httpsys, Testserver usw.) über eine eigene `AllowSynchronousIO` Option verfügen, die sich nicht auf andere Server auswirkt. Synchrone e/a-Vorgänge können für alle Server auf Anforderungs Basis aktiviert werden. verwenden `IHttpBodyControlFeature.AllowSynchronousIO` Sie dazu die folgende Option:

```csharp
var syncIOFeature = HttpContext.Features.Get<IHttpBodyControlFeature>();

if (syncIOFeature != null)
{
    syncIOFeature.AllowSynchronousIO = true;
}
```

Wenn Sie Probleme mit <xref:System.IO.TextWriter> Implementierungen oder anderen Streams haben, die synchrone APIs [in verwerfen](/dotnet/standard/garbage-collection/implementing-dispose)aufzurufen, <xref:System.IO.Stream.DisposeAsync*> müssen Sie stattdessen die neue API abrufen.

Weitere Informationen finden Sie unter [[Ankündigung] allowsynchronousio deaktiviert auf allen Servern (dotnet/aspnetcore-#7644)](https://github.com/dotnet/AspNetCore/issues/7644).

### <a name="microsoftaspnetcoreserverkestrelhttps-assembly-removed"></a>Die Assembly "Microsoft. aspnetcore. Server. Kestrel. https" wurde entfernt.

In ASP.net Core 2,1 wurde der Inhalt von " *Microsoft. aspnetcore. Server. Kestrel. HTTPS. dll* " in " *Microsoft. aspnetcore. Server. Kestrel. Core. dll*" verschoben. Dabei handelt es sich um ein nicht Erbrechtes Update mit `TypeForwardedTo` Attributen. Bei 3,0 wurden die leere *Microsoft. aspnetcore. Server. Kestrel. HTTPS. dll* -Assembly und das nuget-Paket entfernt.

Bibliotheken, die auf [Microsoft. aspnetcore. Server. Kestrel. HTTPS](https://www.nuget.org/packages/Microsoft.AspNetCore.Server.Kestrel.Https) verweisen, sollten ASP.net Core Abhängigkeiten auf 2,1 oder höher aktualisieren.

Apps und Bibliotheken, die auf ASP.net Core 2,1 oder höher abzielen, sollten alle direkten Verweise auf das Paket [Microsoft. aspnetcore. Server. Kestrel. HTTPS](https://www.nuget.org/packages/Microsoft.AspNetCore.Server.Kestrel.Https) entfernen.

<a id="jsonnet-support"></a>

## <a name="newtonsoftjson-jsonnet-support"></a>Unterstützung von "newtonsoft. JSON" (JSON.net)

Im Rahmen der Arbeit zur [Verbesserung der ASP.net Core freigegebenen Frameworks](https://blogs.msdn.microsoft.com/webdev/2018/10/29/a-first-look-at-changes-coming-in-asp-net-core-3-0/)wurde " [newtonsoft. JSON" (JSON.net)](https://www.newtonsoft.com/json/help/html/Introduction.htm) aus dem ASP.net Core Shared Framework entfernt.

Der Standard-JSON-Serialisierer für ASP.net Core <xref:System.Text.Json>ist jetzt, der in .net Core 3,0 neu ist. Verwenden Sie `System.Text.Json` nach Möglichkeit die Verwendung von. Dies ist eine hohe Leistung und erfordert keine zusätzliche Bibliotheks Abhängigkeit. Da `System.Text.Json` jedoch neu ist, fehlen möglicherweise derzeit die Features, die Ihre APP benötigt. Weitere Informationen finden Sie unter [Migrieren von "newtonsoft. JSON" zu "System. Text. JSON](/dotnet/standard/serialization/system-text-json-migrate-from-newtonsoft-how-to)".

### <a name="use-newtonsoftjson-in-an-aspnet-core-30-signalr-project"></a>Verwenden von "newtonsoft. JSON" in SignalR einem ASP.net Core 3,0-Projekt

* Installieren Sie [Microsoft. aspnetcore.SignalR Das nuget-Paket "Protokolls. newtonsoft JSON](https://www.nuget.org/packages/Microsoft.AspNetCore.SignalR.Protocols.NewtonsoftJson) ".

* Verketten Sie auf dem Client `AddNewtonsoftJsonProtocol` einen Methoden Aufrufder `HubConnectionBuilder` -Instanz:

  ```csharp
  new HubConnectionBuilder()
      .WithUrl("/chatHub")
      .AddNewtonsoftJsonProtocol(...)
      .Build();
  ```

* Verketten Sie auf dem- `AddNewtonsoftJsonProtocol` Server einen Methodenaufrufe `AddSignalR` des-Methoden `Startup.ConfigureServices`Aufrufes in:

  ```csharp
  services.AddSignalR()
      .AddNewtonsoftJsonProtocol(...);
  ```

### <a name="use-newtonsoftjson-in-an-aspnet-core-30-mvc-project"></a>Verwenden von "newtonsoft. JSON" in einem ASP.net Core 3,0-MVC-Projekt

* Installieren Sie das Paket [Microsoft. aspnetcore. MVC. newtonsoft JSON](https://nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson) .

* Aktualisieren `Startup.ConfigureServices` , um `AddNewtonsoftJson`aufzurufen.

  ```csharp
  services.AddMvc()
      .AddNewtonsoftJson();
  ```

  `AddNewtonsoftJson`ist mit den neuen Registrierungsmethoden für den MVC-Dienst kompatibel:

  * `AddRazorPages`
  * `AddControllersWithViews`
  * `AddControllers`

  ```csharp
  services.AddControllers()
      .AddNewtonsoftJson();
  ```

  `Newtonsoft.Json`Einstellungen können im-Befehl festgelegt werden `AddNewtonsoftJson`:

  ```csharp
  services.AddMvc()
      .AddNewtonsoftJson(options =>
             options.SerializerSettings.ContractResolver =
                new CamelCasePropertyNamesContractResolver());
  ```

**Hinweis:** Wenn die `AddNewtonsoftJson` Methode nicht verfügbar ist, stellen Sie sicher, dass Sie das Paket [Microsoft. aspnetcore. MVC. newtonsoftware](https://nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson) installiert haben. Ein häufiger Fehler ist die Installation des Pakets " [newtonsoft. JSON](https://www.nuget.org/packages/Newtonsoft.Json/) " anstelle des Pakets " [Microsoft. aspnetcore. MVC. newtonsoftjson](https://nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson) ".

## <a name="mvc-service-registration"></a>MVC-Dienst Registrierung

In ASP.net Core 3,0 werden neue Optionen zum Registrieren von MVC `Startup.ConfigureServices`-Szenarien in hinzugefügt.

Drei neue Erweiterungs Methoden der obersten Ebene, die sich auf MVC `IServiceCollection` -Szenarios für beziehen, sind verfügbar. Vorlagen verwenden diese neuen Methoden anstelle von `AddMvc`. Verhält sich `AddMvc` jedoch weiterhin wie in früheren Versionen.

Im folgenden Beispiel wird die Unterstützung für Controller und API-Funktionen hinzugefügt, jedoch keine Sichten oder Seiten. Die API-Vorlage verwendet diesen Code:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllers();
}
```

Im folgenden Beispiel werden die Unterstützung für Controller, API-bezogene Features und Sichten, aber keine Seiten hinzugefügt. Die Vorlage Webanwendung (MVC) verwendet folgenden Code:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllersWithViews();
}
```

Im folgenden Beispiel wird die unter Razor Stützung für Seiten und die minimale Controller Unterstützung hinzugefügt. Die Webanwendungsvorlage verwendet diesen Code:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddRazorPages();
}
```

Die neuen Methoden können ebenfalls kombiniert werden. Das folgende Beispiel entspricht dem Aufrufen `AddMvc` von in ASP.net Core 2,2:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllersWithViews();
    services.AddRazorPages();
}
```

## <a name="routing-startup-code"></a>Routing Startcode

Wenn eine APP oder `UseMvc` `UseSignalR`aufruft, migrieren Sie die APP nach Möglichkeit zum [Endpunkt Routing](xref:fundamentals/routing) . Um die Kompatibilität mit dem Endpunkt Routing mit früheren Versionen von MVC zu verbessern, haben wir einige der Änderungen in der URL-Generierung wieder hergestellt, die in ASP.net Core 2,2 eingeführt wurden. Wenn bei der Verwendung des Endpunkt Routings in 2,2 Probleme auftreten, erwarten Sie Verbesserungen in ASP.net Core 3,0 mit folgenden Ausnahmen:

* Wenn die APP implementiert `IRouter` oder von `Route`der Anwendung erbt, verwenden Sie [dynamicroutevaluestransex](https://github.com/dotnet/AspNetCore.Docs/issues/12997) als Ersatz.
* Wenn die APP direkt in `RouteData.Routers` MVC zugreift, um URLs zu analysieren, können Sie dies durch die Verwendung von [linkparser. parspathbyendpointname](xref:Microsoft.AspNetCore.Routing.LinkParserEndpointNameAddressExtensions.ParsePathByEndpointName*)ersetzen. 
  * Hiermit wird die Route mit einem Routennamen definiert.
  * Verwenden `LinkParser.ParsePathByEndpointName` Sie, und übergeben Sie den gewünschten Routennamen.

Das Endpunkt Routing unterstützt die gleiche Routing Muster Syntax und die Funktionen zum `IRouter`Erstellen von Routen Mustern wie. Das Endpunkt Routing `IRouteConstraint`unterstützt. Das Endpunkt Routing `[Route]`unter `[HttpGet]`stützt, und die anderen MVC-Routing Attribute.

Bei den meisten Anwendungen müssen `Startup` nur Änderungen vorgenommen werden.

### <a name="migrate-startupconfigure"></a>"Startup. configure" Migrieren

Allgemeine Hinweise:

* Fügen Sie `UseRouting`hinzu.
* Wenn die APP aufruft `UseStaticFiles`, platzieren `UseStaticFiles` Sie es **vor** `UseRouting`.
* Wenn die APP Authentifizierungs-/Autorisierungsfeatures `AuthorizePage` wie `[Authorize]`oder verwendet, platzieren Sie `UseAuthentication` den `UseAuthorization`-Befehl unter `UseRouting` und `UseCors`: **nach**und `UseEndpoints`, aber vor:

  ```csharp
  public void Configure(IApplicationBuilder app)
  {
    ...

    app.UseStaticFiles();

    app.UseRouting();
    app.UseCors();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints => {
       endpoints.MapControllers();
    });
  ```

* Ersetzen `UseMvc` Sie `UseSignalR` oder `UseEndpoints`durch.
* Wenn die APP [cors](xref:security/cors) `[EnableCors]`-Szenarien (z. b.) verwendet, `UseCors` platzieren Sie den-Anrufe vor allen anderen Middleware, die cors verwenden `UseAuthorization`(z `UseEndpoints`. b. platzieren `UseCors` vor `UseAuthentication`, und).
* Ersetzen `IHostingEnvironment` Sie `IWebHostEnvironment` durch, und `using` fügen Sie eine <xref:Microsoft.Extensions.Hosting?displayProperty=fullName> -Anweisung für den Namespace hinzu.
* Ersetzen `IApplicationLifetime` Sie <xref:Microsoft.Extensions.Hosting.IHostApplicationLifetime> dies<xref:Microsoft.Extensions.Hosting?displayProperty=fullName> durch (-Namespace).
* Ersetzen `EnvironmentName` Sie <xref:Microsoft.Extensions.Hosting.Environments> dies<xref:Microsoft.Extensions.Hosting?displayProperty=fullName> durch (-Namespace).

Der folgende Code ist ein Beispiel für `Startup.Configure` eine typische ASP.net Core 2,2-App:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseStaticFiles();

    app.UseAuthentication();

    app.UseSignalR(hubs =>
    {
        hubs.MapHub<ChatHub>("/chat");
    });

    app.UseMvc(routes =>
    {
        routes.MapRoute("default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

Nach dem Aktualisieren des `Startup.Configure` vorherigen Codes:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseStaticFiles();

    app.UseRouting();

    app.UseCors();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>("/chat");
        endpoints.MapControllerRoute("default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

> [!WARNING]
> Bei den meisten apps müssen Aufrufe `UseAuthentication`von `UseAuthorization`, und `UseCors` zwischen den Aufrufen von `UseRouting` und `UseEndpoints` auftreten, um wirksam zu werden.

### <a name="health-checks"></a>Integritätsprüfungen

Integritätsprüfungen verwenden das Endpunktrouting mit dem generischen Host. Rufen Sie in `Startup.Configure` auf der Endpunkterstellung mit der Endpunkt-URL oder dem relativen Pfad `MapHealthChecks` auf:

```csharp
app.UseEndpoints(endpoints =>
{
    endpoints.MapHealthChecks("/health");
});
```

Für Endpunkte für Integritätsprüfungen gilt Folgendes:

* Sie geben mindestens einen zugelassenen Host oder Port an.
* Sie erfordern Autorisierung.
* Sie erfordern CORS.

Weitere Informationen finden Sie unter <xref:host-and-deploy/health-checks>.

### <a name="security-middleware-guidance"></a>Leitfaden zur Sicherheit von Middleware

Unterstützung für die Autorisierung und cors ist in Bezug auf den [Middleware](xref:fundamentals/middleware/index) -Ansatz einheitlich. Dies ermöglicht die Verwendung derselben Middleware und derselben Funktionalität in diesen Szenarien. In dieser Version wird eine aktualisierte Autorisierungs Middleware bereitgestellt, und die cors-Middleware wird verbessert, sodass Sie die von MVC-Controllern verwendeten Attribute verstehen kann.

#### <a name="cors"></a>CORS

Zuvor war es möglicherweise schwierig, cors zu konfigurieren. Die Middleware wurde zur Verwendung in einigen Anwendungsfällen bereitgestellt, aber MVC-Filter waren in anderen Anwendungsfällen **ohne** die Middleware vorgesehen. Bei ASP.net Core 3,0 wird empfohlen, dass alle apps, die cors benötigen, die cors-Middleware zusammen mit dem Endpunkt Routing verwenden. `UseCors`kann mit einer Standard Richtlinie angegeben werden, und `[EnableCors]` die `[DisableCors]` -und-Attribute können verwendet werden, um die Standard Richtlinie nach Bedarf zu überschreiben.

Im folgenden Beispiel:

* Cors ist für alle Endpunkte mit der `default` benannten Richtlinie aktiviert.
* Die `MyController` -Klasse deaktiviert cors mit dem `[DisableCors]` -Attribut.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseCors("default");

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

[DisableCors]
public class MyController : ControllerBase
{
    ...
}
```

#### <a name="authorization"></a>Autorisierung

In früheren Versionen von ASP.net Core wurde Unterstützung der Autorisierung über `[Authorize]` das-Attribut bereitgestellt. Die Autorisierungs Middleware war nicht verfügbar. In ASP.net Core 3,0 ist die Autorisierungs Middleware erforderlich. Es wird empfohlen, die ASP.net Core Autorisierungs Middleware (`UseAuthorization`) `UseAuthentication`direkt nach zu platzieren. Die Middleware für die Autorisierung kann auch mit einer Standard Richtlinie konfiguriert werden, die überschrieben werden kann.

In ASP.net Core 3,0 oder höher `UseAuthorization` wird in `Startup.Configure`aufgerufen, und für Folgendes `HomeController` ist ein angemeldeter Benutzer erforderlich:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

public class HomeController : Controller
{
    [Authorize]
    public IActionResult BuyWidgets()
    {
        ...
    }
}
```

Wenn Sie das Endpunkt Routing verwenden, wird empfohlen `<xref:Microsoft.AspNetCore.Mvc.Authorization.AuthorizeFilter>` , die Autorisierungs Middleware zu konfigurieren und stattdessen darauf zu vertrauen.  Wenn die APP `AuthorizeFilter` als globaler Filter in MVC verwendet, empfiehlt es sich, den Code so zu umgestalten, dass er eine Richtlinie `AddAuthorization`im-Befehl bereitstellt.

Das `DefaultPolicy` ist anfänglich so konfiguriert, dass eine Authentifizierung erforderlich ist, sodass keine zusätzliche Konfiguration erforderlich ist. Im folgenden Beispiel werden die MVC-Endpunkte als `RequireAuthorization` markiert, sodass alle Anforderungen auf der `DefaultPolicy`Grundlage von autorisiert werden müssen. Der ermöglicht jedoch `HomeController` den Zugriff, ohne dass der Benutzer sich bei der APP `[AllowAnonymous]`anmeldet. Dies liegt an folgendem:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute().RequireAuthorization();
    });
}

[AllowAnonymous]
public class HomeController : Controller
{
    ...
}
```

### <a name="authorization-for-specific-endpoints"></a>Autorisierung für bestimmte Endpunkte

Die Autorisierung kann auch für bestimmte Klassen von Endpunkten konfiguriert werden. Der folgende Code ist ein Beispiel für die Umstellung einer MVC-APP, die `AuthorizeFilter` eine globale in eine APP mit einer bestimmten Richtlinie konfiguriert, die eine Autorisierung erfordert:

[!code-csharp[](22-to-30/samples/Startup.cs?name=snippet&highlight=8-9,21-22,26-27,53-54)]

Richtlinien können auch angepasst werden. Der `DefaultPolicy` ist so konfiguriert, dass eine Authentifizierung erforderlich ist:

[!code-csharp[](22-to-30/samples/Startup2.cs?name=snippet&highlight=21-26,52)]

[!code-csharp[](22-to-30/samples/HomeController.cs?name=snippet)]

Alternativ können alle Endpunkte so konfiguriert werden, dass Sie ohne `[Authorize]` oder `RequireAuthorization` durch Konfigurieren von `FallbackPolicy`eine Autorisierung erfordern. Der `FallbackPolicy` unterscheidet sich vom `DefaultPolicy`. `DefaultPolicy` Wird `[Authorize]` von oder `RequireAuthorization`ausgelöst, während das `FallbackPolicy` ausgelöst wird, wenn keine andere Richtlinie festgelegt ist. `FallbackPolicy`ist anfänglich so konfiguriert, dass Anforderungen ohne Autorisierung zugelassen werden.

Das folgende Beispiel ist identisch mit dem vorherigen `DefaultPolicy` Beispiel `FallbackPolicy` , verwendet jedoch, um immer eine Authentifizierung für alle Endpunkte anzufordern, `[AllowAnonymous]` außer wenn angegeben ist:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    ...

    services.AddAuthorization(options =>
    {
        options.FallbackPolicy = new AuthorizationPolicyBuilder()
          .RequireAuthenticatedUser()
          .Build();
    });
}

public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

[AllowAnonymous]
public class HomeController : Controller
{
    ...
}
```

Die Autorisierung durch Middleware funktioniert, ohne dass das Framework über bestimmte Kenntnisse der Autorisierung verfügt. Integritäts [Prüfungen](xref:host-and-deploy/health-checks) haben beispielsweise keine spezifischen Kenntnisse der Autorisierung, aber Integritätsprüfungen können eine konfigurierbare Autorisierungs Richtlinie aufweisen, die von der Middleware angewendet wird.

Außerdem kann jeder Endpunkt seine Autorisierungs Anforderungen anpassen. Im folgenden Beispiel `UseAuthorization` wird die Autorisierung mit der `DefaultPolicy`verarbeitet, aber `/healthz` der Integritätsprüfung- `admin` Endpunkt erfordert einen Benutzer:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints
            .MapHealthChecks("/healthz")
            .RequireAuthorization(new AuthorizeAttribute(){ Roles = "admin", });
    });
}
```

Der Schutz wird für einige Szenarien implementiert. Die Middleware für Endpunkte löst eine Ausnahme aus, wenn eine Autorisierungs-oder cors-Richtlinie aufgrund fehlender Middleware übersprungen wird. Analyse Unterstützung, um zusätzliches Feedback zur Fehlkonfiguration bereitzustellen.

#### <a name="custom-authorization-handlers"></a>Benutzerdefinierte Autorisierungs Handler

Wenn die APP benutzerdefinierte [Autorisierungs Handler](xref:security/authorization/policies#authorization-handlers)verwendet, übergibt das Endpunkt Routing einen anderen Ressourcentyp an Handler als MVC. Handler, die erwarten, dass die Kontext Ressource des Autorisierungs Handler vom Typ <xref:Microsoft.AspNetCore.Mvc.Filters.AuthorizationFilterContext> ist (der [von MVC-Filtern bereitgestellte](xref:security/authorization/policies#accessing-mvc-request-context-in-handlers)Ressourcentyp), muss aktualisiert <xref:Microsoft.AspNetCore.Routing.RouteEndpoint> werden, damit die Ressourcen des Typs (der Ressourcentyp, der den Autorisierungs Handlern durch Endpunkt Routing zugewiesen ist) verarbeitet werden

Da MVC weiterhin `AuthorizationFilterContext` Ressourcen verwendet, ist es möglicherweise erforderlich, beide Arten von Ressourcen zu verarbeiten, wenn die APP MVC-Autorisierungs Filter zusammen mit der Endpunkt Weiterleitungs Autorisierung verwendet.

### SignalR

Die Zuordnung SignalR von Hubs erfolgt nun in `UseEndpoints`.

Ordnen Sie jeden Hub `MapHub`mit zu. Wie in früheren Versionen wird jeder Hub explizit aufgelistet.

Im folgenden Beispiel wird die Unterstützung für `ChatHub` SignalR den Hub hinzugefügt:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>();
    });
}
```

Es gibt eine neue Option zum Steuern von Größenbeschränkungen für Nachrichten von Clients. Gehen Sie beispielsweise in `Startup.ConfigureServices` folgendermaßen vor:

```csharp
services.AddSignalR(hubOptions =>
{
    hubOptions.MaximumReceiveMessageSize = 32768;
});
```

In ASP.net Core 2,2 konnten Sie die festlegen, `TransportMaxBufferSize` die die maximale Nachrichtengröße effektiv steuern würde. In ASP.net Core 3,0 steuert diese Option jetzt nur die maximale Größe, bevor der Rückdruck festgestellt wird.

### <a name="mvc-controllers"></a>MVC-Controller

Die Zuordnung von Controllern erfolgt nun `UseEndpoints`in.

Fügen `MapControllers` Sie hinzu, wenn die APP Attribut Routing verwendet. Da das Routing Unterstützung für viele Frameworks in ASP.net Core 3,0 oder höher bietet, ist das Hinzufügen von Attribut Weiterleitungs Controllern ein Opt-in.

Ersetzen Sie Folgendes:

* `MapRoute` mit `MapControllerRoute`
* `MapAreaRoute` mit `MapAreaControllerRoute`

Da das Routing nun die Unterstützung für mehr als nur MVC umfasst, hat sich die Terminologie geändert, damit diese Methoden deutlich erkennen können, was Sie tun. Herkömmliche Routen `MapControllerRoute` / `MapAreaControllerRoute` / wie `MapDefaultControllerRoute` werden in der Reihenfolge angewendet, in der Sie hinzugefügt werden. Platzieren Sie zunächst spezifischere Routen (z. b. Routen für einen Bereich).

Im folgenden Beispiel:

* `MapControllers`Fügt Unterstützung für Attribut Weiterleitungs Controller hinzu.
* `MapAreaControllerRoute`Fügt eine konventionelle Route für Controller in einem Bereich hinzu.
* `MapControllerRoute`Fügt eine konventionelle Route für Controller hinzu.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapControllers();
        endpoints.MapAreaControllerRoute(
            "admin",
            "admin",
            "Admin/{controller=Home}/{action=Index}/{id?}");
        endpoints.MapControllerRoute(
            "default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

#### <a name="async-suffix-removal-from-controller-action-names"></a>Asynchrones Suffix aus Controller-Aktions Namen entfernen

In ASP.net Core 3,0 entfernt ASP.net Core MVC das Suffix `Async` aus den Controller Aktions Namen. Das Routing und die Verknüpfungs Generierung sind von dieser neuen Standardeinstellung betroffen. Beispiel:

```csharp
public class ProductsController : Controller
{
    public async Task<IActionResult> ListAsync()
    {
        var model = await _dbContext.Products.ToListAsync();
        return View(model);
    }
}
```

Vor ASP.net Core 3,0:

* Auf die vorherige Aktion kann auf der Route " *Products/listasync* " zugegriffen werden.
* Die Link Generierung erforderte das `Async` angeben des Suffixes. Beispiel:

    ```cshtml
    <a asp-controller="Products" asp-action="ListAsync">List</a>
    ```

In ASP.net Core 3,0:

* Auf die vorangehende Aktion kann auf der Route " *Products/List* " zugegriffen werden.
* Bei der Link Generierung muss das `Async` Suffix nicht angegeben werden. Beispiel:

    ```cshtml
    <a asp-controller="Products" asp-action="List">List</a>
    ```

Diese Änderung wirkt sich nicht auf die mit [`[ActionName]`](/dotnet/api/microsoft.aspnetcore.mvc.actionnameattribute) dem-Attribut angegebenen Namen aus. Das Standardverhalten kann mit dem folgenden Code in `Startup.ConfigureServices`deaktiviert werden:

```csharp
services.AddMvc(options =>
    options.SuppressAsyncSuffixInActionNames = false);
```

#### <a name="changes-to-link-generation"></a>Änderungen an der Link Generierung

Wie in der Dokumentation zu den [unterschieden aus früheren Versionen des Routings](xref:fundamentals/routing#differences-from-earlier-versions-of-routing)erläutert, gibt es einige Unterschiede `Url.Link` bei der Link Generierung (z. b. mit und ähnlichen APIs). Dazu gehören:

* Wenn Sie das Endpunkt Routing verwenden, wird die Groß-/Kleinschreibung von Routen Parametern in generierten URIs standardmäßig nicht zwangsläufig beibehalten. Dieses Verhalten kann mit der `IOutboundParameterTransformer` -Schnittstelle gesteuert werden.
* Wenn Sie einen URI für eine ungültige Route generieren (ein Controller, eine Aktion oder eine Seite, die nicht vorhanden ist), wird unter Endpunkt Routing eine leere Zeichenfolge erstellt, anstatt einen ungültigen URI zu erzeugen.
* Ambient-Werte (Routen Parameter aus dem aktuellen Kontext) werden bei der Link Generierung mit dem Endpunkt Routing nicht automatisch verwendet. Zuvor wurden bei der Erstellung eines Links zu einer anderen Aktion (oder Seite) nicht angegebene Routen Werte von den *aktuellen* Routen Werten abgeleitet. Bei Verwendung des Endpunkt Routings müssen alle Routen Parameter während der Link Generierung explizit angegeben werden.

### <a name="razor-pages"></a>RazorSeiten

Die Razor Zuordnung von Seiten erfolgt nun `UseEndpoints`in.

Fügen `MapRazorPages` Sie hinzu, wenn Razor die APP Seiten verwendet. Da das Endpunkt Routing Unterstützung für viele Frameworks Razor umfasst, ist das Hinzufügen von Seiten jetzt deaktiviert.

In der folgenden `Startup.Configure` Methode `MapRazorPages` fügt Unterstützung für Razor Seiten hinzu:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapRazorPages();
    });
}
```

### <a name="use-mvc-without-endpoint-routing"></a>Verwenden von MVC ohne Endpunkt Routing

Die Verwendung von `UseMvc` MVC `UseMvcWithDefaultRoute` über oder in ASP.net Core 3,0 erfordert ein explizites `Startup.ConfigureServices`Opt-in in. Dies ist erforderlich, da MVC wissen muss, ob es während der Initialisierung auf die Autorisierung und die cors-Middleware zurückgreifen kann. Es wird ein Analyzer bereitgestellt, der warnt, wenn die APP versucht, eine nicht unterstützte Konfiguration zu verwenden.

Wenn die APP Legacy `IRouter` Unterstützung erfordert, deaktivieren `EnableEndpointRouting` Sie die Verwendung der folgenden Ansätze in `Startup.ConfigureServices`:

```csharp
services.AddMvc(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddControllers(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddControllersWithViews(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddRazorPages().AddMvcOptions(options => options.EnableEndpointRouting = false);
```

### <a name="health-checks"></a>Integritätsprüfungen

Integritätsprüfungen können als *routerware* mit Endpunkt Routing verwendet werden.

Fügen `MapHealthChecks` Sie hinzu, um Integritätsprüfungen mit Endpunkt Routing zu verwenden. Die `MapHealthChecks` -Methode akzeptiert Argumente ähnlich `UseHealthChecks`wie. Der Vorteil der Verwendung `MapHealthChecks` von `UseHealthChecks` over ist die Fähigkeit, Autorisierung anzuwenden und eine präzisere Kontrolle über die abgleichsrichtlinie zu haben.

Im folgenden Beispiel `MapHealthChecks` wird für einen Integritäts Prüf Punkt aufgerufen `/healthz`:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHealthChecks("/healthz", new HealthCheckOptions() { });
    });
}
```

<a name="hostb"></a>

## <a name="hostbuilder-replaces-webhostbuilder"></a>Der hostbuilder ersetzt webhostbuilder.

In den ASP.net Core 3,0-Vorlagen wird [generischer Host](xref:fundamentals/host/generic-host)verwendet. In früheren Versionen wurde [Webhost](xref:fundamentals/host/web-host)verwendet. Der folgende Code zeigt die von der ASP.net Core 3,0 `Program` -Vorlage generierte Klasse:

[!code-csharp[](22-to-30/samples/Program.cs?name=snippet)]

Der folgende Code zeigt die von der Vorlage generierte `Program` ASP.net Core 2,2-Klasse:

[!code-csharp[](22-to-30/samples/Program2.2.cs?name=snippet)]

<xref:Microsoft.AspNetCore.Hosting.IWebHostBuilder>verbleibt in 3,0 und ist der Typ von `webBuilder` , der im vorangehenden Codebeispiel angezeigt wird. <xref:Microsoft.AspNetCore.Hosting.WebHostBuilder>wird in einer zukünftigen Version als veraltet markiert und durch `HostBuilder`ersetzt.

Die signifikanteste Änderung `WebHostBuilder` von `HostBuilder` in ist die [Abhängigkeitsinjektion (di)](xref:fundamentals/dependency-injection). Wenn Sie `HostBuilder`verwenden, können Sie nur den folgenden in `Startup`den-Konstruktor einfügen:

* <xref:Microsoft.Extensions.Configuration.IConfiguration>
* <xref:Microsoft.Extensions.Hosting.IHostEnvironment>
* <xref:Microsoft.AspNetCore.Hosting.IWebHostEnvironment>

Die `HostBuilder` di-Einschränkungen:

* Aktivieren Sie den di-Container nur ein einziges Mal.
* Vermeidet die resultierenden Probleme bei der Objekt Lebensdauer wie das Auflösen mehrerer Instanzen von Singletons.

Weitere Informationen finden Sie unter [vermeiden der Start Dienst Injektion in ASP.net Core 3](https://andrewlock.net/avoiding-startup-service-injection-in-asp-net-core-3/).

## <a name="addauthorization-moved-to-a-different-assembly"></a>Addauthorization in eine andere Assembly verschoben

Die Methoden ASP.net Core 2,2 und `AddAuthorization` niedriger in *Microsoft. aspnetcore. Authorization. dll*:

* Wurden umbenannt `AddAuthorizationCore`.
* Wurden in " *Microsoft. aspnetcore. Authorization. Policy. dll*" verschoben.

Apps, die sowohl *Microsoft. aspnetcore. Authorization. dll* als auch *Microsoft. aspnetcore. Authorization. Policy. dll* verwenden, sind nicht betroffen.

Apps, die nicht *Microsoft. aspnetcore. Authorization. Policy. dll* verwenden, sollten eine der folgenden Aktionen ausführen:

* Fügen Sie einen Verweis auf *Microsoft. aspnetcore. Authorization. Policy. dll*hinzu. Diese Vorgehensweise funktioniert für die meisten apps und ist alles, was erforderlich ist.
* Wechseln zu mithilfe von`AddAuthorizationCore`

Weitere Informationen finden Sie unter [Breaking Change in `AddAuthorization(o =>`(Breaking Change in) der Überlastung in einer anderen Assembly #386](https://github.com/aspnet/Announcements/issues/386).

## <a name="identity-ui"></a>Benutzeroberfläche von Identity

IdentityAktualisierungen der Benutzeroberfläche für ASP.net Core 3,0:

* Fügen Sie einen Paket Verweis auf [Microsoft. aspnetcoreIdentityhinzu. Benutzeroberfläche](https://nuget.org/packages/Microsoft.AspNetCore.Identity.UI).
* Apps, die keine Razor Seiten verwenden, `MapRazorPages`müssen aufruft. Siehe [ Razor Seiten](#razor-pages) in diesem Dokument.
* Bootstrap 4 ist das Standard Framework für die Benutzeroberfläche. Legen Sie `IdentityUIFrameworkVersion` eine Projekt Eigenschaft fest, um die Standardeinstellung zu ändern. Weitere Informationen finden Sie in [dieser GitHub-Ankündigung](https://github.com/aspnet/Announcements/issues/380).

## SignalR

Der SignalR JavaScript-Client wurde von `@aspnet/signalr` in `@microsoft/signalr`geändert. Um auf diese Änderung zu reagieren, ändern Sie die Verweise in " *Package. JSON* "-Dateien, `require` - `import` Anweisungen und ECMAScript-Anweisungen.

### <a name="systemtextjson-is-the-default-protocol"></a>"System. Text. JSON" ist das Standardprotokoll.

`System.Text.Json`ist nun das Standardhub Protokoll, das sowohl vom Client als auch vom Server verwendet wird.

In `Startup.ConfigureServices`wird aufgerufen `AddJsonProtocol` , um Serialisierungsoptionen festzulegen.

**Servers**

```csharp
services.AddSignalR(...)
        .AddJsonProtocol(options =>
        {
            options.PayloadSerializerOptions.WriteIndented = false;
        })
```

**Ent**

```csharp
new HubConnectionBuilder()
    .WithUrl("/chatHub")
    .AddJsonProtocol(options =>
    {
        options.PayloadSerializerOptions.WriteIndented = false;
    })
    .Build();
```

### <a name="switch-to-newtonsoftjson"></a>Wechseln Sie zu "newtonsoft. JSON".

Wenn Sie [Funktionen von "newtonsoft. JSON" verwenden, die in "System. Text. JSON" nicht unterstützt](/dotnet/standard/serialization/system-text-json-migrate-from-newtonsoft-how-to)werden `Newtonsoft.Json`, können Sie zurück zu wechseln. Weitere Informationen finden Sie weiter oben in diesem Artikel [unter Verwenden von SignalR Newton Soft. JSON in einem ASP.net Core 3,0-Projekt](#use-newtonsoftjson-in-an-aspnet-core-30-signalr-project) .

## <a name="redis-distributed-caches"></a>Verteilte redis-Caches

Das [Microsoft. Extensions. Caching. redis](https://www.nuget.org/packages/Microsoft.Extensions.Caching.Redis) -Paket ist für 3,0 ASP.net Core-Apps oder höher nicht verfügbar. Ersetzen Sie den Paket Verweis durch [Microsoft. Extensions. Caching. stackexchangeredis](https://www.nuget.org/packages/Microsoft.Extensions.Caching.StackExchangeRedis). Weitere Informationen finden Sie unter <xref:performance/caching/distributed>.

## <a name="opt-in-to-runtime-compilation"></a>Abonnieren der Lauf Zeit Kompilierung

Vor ASP.net Core 3,0 war die Lauf Zeit Kompilierung von Sichten eine implizite Funktion des Frameworks. Die Lauf Zeit Kompilierung ergänzt die Kompilierung der Erstellung von Sichten. Dadurch kann das Framework Sichten und Razor Seiten (*cshtml* -Dateien) kompilieren, wenn die Dateien geändert werden, ohne dass die gesamte APP neu erstellt werden muss. Diese Funktion unterstützt das Szenario der schnellen Bearbeitung in der IDE und das Aktualisieren des Browsers, um die Änderungen anzuzeigen.

In ASP.net Core 3,0 ist die Lauf Zeit Kompilierung ein Opt-in-Szenario. Die Kompilierzeit Kompilierung ist der einzige Mechanismus zum Anzeigen der Kompilierung, der standardmäßig aktiviert ist. Die Laufzeit basiert auf Visual Studio oder [dotnet-Watch](xref:tutorials/dotnet-watch) in Visual Studio Code, um das Projekt neu zu erstellen, wenn Änderungen an *cshtml* -Dateien erkannt werden. In Visual Studio werden Änderungen an *den CS*- *, cshtml*-oder *Razor* -Dateien im Projekt, das ausgeführt wird (<kbd>STRG + F5</kbd>), aber nicht debuggt (<kbd>F5</kbd>), die Neukompilierung des Projekts auslöst.

So aktivieren Sie die Lauf Zeit Kompilierung in Ihrem ASP.net Core 3,0-Projekt:

1. Installieren Sie [Microsoft. aspnetcore. MVC.Razor. Runtimecompilation](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Razor.RuntimeCompilation) -nuget-Paket.
1. Update `Startup.ConfigureServices` zum aufzurufen `AddRazorRuntimeCompilation`:

    Verwenden Sie für ASP.net Core MVC den folgenden Code:

    ```csharp
    services.AddControllersWithViews()
        .AddRazorRuntimeCompilation(...);
    ```
 
    Verwenden Sie Razor für ASP.net Core Seiten den folgenden Code:
 
    ```csharp
    services.AddRazorPages()
        .AddRazorRuntimeCompilation(...);
    ```
 
Das Beispiel unter https://github.com/aspnet/samples/tree/master/samples/aspnetcore/mvc/runtimecompilation zeigt ein Beispiel für die bedingte Aktivierung der Lauf Zeit Kompilierung in Entwicklungsumgebungen.

Weitere Informationen zur Kompilierung von Razor Dateien finden <xref:mvc/views/view-compilation>Sie unter.

## <a name="migrate-libraries-via-multi-targeting"></a>Migrieren von Bibliotheken mithilfe der Zielplattform

Bibliotheken müssen häufig mehrere Versionen von ASP.net Core unterstützen. Die meisten Bibliotheken, die für frühere Versionen von ASP.net Core kompiliert wurden, sollten ohne Probleme weiterhin funktionieren. Die folgenden Bedingungen erfordern eine Kreuz Kompilierung der APP:

* Die Bibliothek basiert auf einer Funktion, die über eine binäre [Breaking Change](#breaking-api-changes)verfügt.
* Die Bibliothek möchte die neuen Features in ASP.net Core 3,0 nutzen. 

Beispiel:

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFrameworks>netcoreapp3.0;netstandard2.0</TargetFrameworks>
  </PropertyGroup>

  <ItemGroup Condition="'$(TargetFramework)' == 'netcoreapp3.0'">
    <FrameworkReference Include="Microsoft.AspNetCore.App" />
  </ItemGroup>

  <ItemGroup Condition="'$(TargetFramework)' == 'netstandard2.0'">
    <PackageReference Include="Microsoft.AspNetCore" Version="2.1.0" />
  </ItemGroup>
</Project>
```

Verwenden `#ifdefs` Sie, um ASP.net Core 3,0-spezifische APIs zu aktivieren:

```csharp
var webRootFileProvider =
#if NETCOREAPP3_0
    GetRequiredService<IWebHostEnvironment>().WebRootFileProvider;
#elif NETSTANDARD2_0
    GetRequiredService<IHostingEnvironment>().WebRootFileProvider;
#else
#error unknown target framework
#endif
```

Weitere Informationen zum Verwenden von ASP.net Core-APIs in einer Klassenbibliothek finden <xref:fundamentals/target-aspnetcore>Sie unter.

## <a name="miscellaneous-changes"></a>Verschiedene Änderungen

Das Validierungssystem in .NET Core 3.0 und höher behandelt Non-Nullable-Parameter oder gebundene Eigenschaften so, als würden sie ein `[Required]`-Attribut aufweisen. Weitere Informationen finden Sie unter [[Required]-Attribut](xref:mvc/models/validation?view=aspnetcore-3.1#required-attribute).

### <a name="publish"></a>Veröffentlichen

Löschen Sie die Ordner " *bin* " und " *obj* " im Projektverzeichnis.

## <a name="testserver"></a>TestServer

Erstellen Sie für apps <xref:Microsoft.AspNetCore.TestHost.TestServer> , die direkt mit dem [generischen Host](xref:fundamentals/host/web-host)verwendet werden <xref:Microsoft.AspNetCore.Hosting.IWebHostBuilder> , <xref:Microsoft.Extensions.Hosting.GenericHostWebHostBuilderExtensions.ConfigureWebHost%2A> `TestServer` auf einem in:

```csharp
[Fact]
public async Task GenericCreateAndStartHost_GetTestServer()
{
    using var host = await new HostBuilder()
        .ConfigureWebHost(webBuilder =>
        {
            webBuilder
                .UseTestServer()
                .Configure(app => { });
        })
    .StartAsync();

    var response = await host.GetTestServer().CreateClient().GetAsync("/");

    Assert.Equal(HttpStatusCode.NotFound, response.StatusCode);
}
```

<a name="break"></a>

## <a name="breaking-api-changes"></a>Wichtige API-Änderungen

Wichtige Änderungen überprüfen:

* [Umfassende Liste der wichtigen Änderungen in der Version ASP.net Core 3,0](https://github.com/aspnet/Announcements/issues?page=1&q=is%3Aissue+is%3Aopen+label%3A%22Breaking+change%22+label%3A3.0.0)
* [Unterbrechen von API-Änderungen in Antifälschung, cors, Diagnose, MVC und Routing](https://github.com/aspnet/Announcements/issues/387). Diese Liste enthält Breaking Changes für Kompatibilitätsoptionen.
* Eine Zusammenfassung 2,2-zu-3,0-Änderungen in .net Core, ASP.net Core und Entity Framework Core finden Sie unter [Breaking Changes for Migration from Version 2,2 to 3,0](/dotnet/core/compatibility/2.2-3.0).

## <a name="endpoint-routing-with-catch-all-parameter"></a>Endpunkt Routing mit Catch-All-Parameter

[!INCLUDE[](~/includes/catchall.md)]

## <a name="net-core-30-on-azure-app-service"></a>.Net Core 3,0 auf Azure App Service

Das Rollout von .net Core auf Azure App Service ist abgeschlossen. .Net Core 3,0 ist in allen Azure App Service Rechenzentren verfügbar.
