---
title: Migration von ASP.net Core 2,2 zu 3,0 Preview
author: rick-anderson
description: Erfahren Sie, wie Sie ein ASP.net Core 2,2-Projekt zu ASP.net Core 3,0 migrieren.
ms.author: riande
ms.custom: mvc
ms.date: 09/06/2019
uid: migration/22-to-30
ms.openlocfilehash: aeaf21b8b2f973946aa469ada1796d67d1b5bba1
ms.sourcegitcommit: 805f625d16d74e77f02f5f37326e5aceafcb78e3
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 09/13/2019
ms.locfileid: "70985586"
---
# <a name="migrate-from-aspnet-core-22-to-30"></a>Migrieren von ASP.net Core 2,2 zu 3,0

Von [Scott Adder](https://github.com/scottaddie) und [Rick Anderson](https://twitter.com/RickAndMSFT)

In diesem Artikel wird erläutert, wie ein vorhandenes ASP.net Core 2,2-Projekt auf ASP.net Core 3,0 aktualisiert wird.

## <a name="prerequisites"></a>Vorraussetzungen

# <a name="visual-studiotabvisual-studio"></a>[Visual Studio](#tab/visual-studio)

[!INCLUDE[](~/includes/net-core-prereqs-vs-3.0.md)]

# <a name="visual-studio-codetabvisual-studio-code"></a>[Visual Studio Code](#tab/visual-studio-code)

[!INCLUDE[](~/includes/net-core-prereqs-vsc-3.0.md)]

# <a name="visual-studio-for-mactabvisual-studio-mac"></a>[Visual Studio für Mac](#tab/visual-studio-mac)

[!INCLUDE[](~/includes/net-core-prereqs-mac-3.0.md)]

---

## <a name="update-the-project-file"></a>Aktualisieren der Projektdatei

* Legen Sie für `netcoreapp3.0`den [zielframeworkmoniker (TFM)](/dotnet/standard/frameworks) Folgendes fest:

  ```xml
  <TargetFramework>netcoreapp3.0</TargetFramework>
  ```

* Entfernen Sie `<PackageReference>` alle in das Metapaket " [Microsoft. aspnetcore. all](xref:fundamentals/metapackage) " oder " [Microsoft. aspnetcore. app](xref:fundamentals/metapackage-app) ".

* Entfernen Sie `<PackageReference>` alle in das Paket [Microsoft. aspnetcore. Razor. Design](https://www.nuget.org/packages/Microsoft.AspNetCore.Razor.Design/) .

* Wenn Ihre Anwendung [API-Analysen](xref:web-api/advanced/analyzers)verwendet, entfernen `<PackageReference>` Sie ein beliebiges-Element für das [Microsoft. aspnetcore. MVC. API. Analysen](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Api.Analyzers/) -Paket. Bearbeiten Sie die Projektdatei, um die im Rahmen des .net Core SDK enthaltene Analyse zu verwenden:

```xml
<PropertyGroup>
 <IncludeOpenAPIAnalyzers>true</IncludeOpenAPIAnalyzers>
</PropertyGroup>
```

* Aktualisieren `Version` `<PackageReference>` Siedas`Microsoft.AspNetCore.*` -Attribut für die restlichen Elemente für Pakete in die aktuelle Vorschau (z. b. ).`3.0.0-preview5-19227-01`

  Wenn keine 3,0-Version eines Pakets vorhanden ist, wurde das Paket möglicherweise in 3,0 als veraltet markiert. Viele dieser Pakete sind Teil von `Microsoft.AspNetCore.App` und sollten nicht einzeln referenziert werden. Eine vorläufige Liste von Paketen, die nicht mehr in 3,0 erstellt werden, finden Sie unter Beendigung der Erstellung von Paketen für freigegebene Frameworkassemblys [in 3,0 (ASPNET/aspnetcore-#3756)](https://github.com/aspnet/AspNetCore/issues/3756). Das frei *gegebene Framework* ist der Satz von Assemblys (*dll* -Dateien), die auf dem Computer installiert `Microsoft.AspNetCore.App`sind und von referenziert werden. Weitere Informationen finden Sie unter [The shared framework](https://natemcmaster.com/blog/2018/08/29/netcore-primitives-2/) (Das freigegebene Framework).

* Die Assemblys für einige relevante Komponenten wurden `Microsoft.AspNetCore.App` aus in 3,0 entfernt. Fügen `<PackageReference>` Sie Elemente hinzu, wenn Sie APIs aus Paketen verwenden, die in Assemblys aufgelistet sind [, die aus Microsoft. aspnetcore. app 3,0 (ASPNET/aspnetcore-#3755) entfernt werden](https://github.com/aspnet/AspNetCore/issues/3755).

  Beispiele für entfernte Komponenten:

  * `Microsoft.AspNet.WebApi.Client`
  * `Microsoft.EntityFrameworkCore`
  * `System.Data.SqlClient`

  Die Liste der in `Microsoft.AspNetCore.App` versandte Assemblys wurde nicht endgültig abgeschlossen und ändert sich vor 3,0 RTM.

  Betrachten Sie folgenden Code:

  ```csharp
  var branches = await response.Content.ReadAsAsync<IEnumerable<GitHubBranch>>();
  ```

  Die `ReadAsAsync` im vorangehenden Code aufgerufene Methode ist in `Microsoft.AspNet.WebApi.Client`enthalten. Installieren Sie das nuget-Paket " [Microsoft. Aspnet. WebAPI. Client](https://www.nuget.org/packages/Microsoft.AspNet.WebApi.Client/) ", um das Kompilierungs Problem in 3,0 zu beheben.

* [JSON.NET-Unterstützung](#jsonnet-support)hinzufügen.

* -Projekte werden standardmäßig in ASP.net Core 3,0 oder höher auf das [in-Process-Hostingmodell](xref:host-and-deploy/aspnet-core-module#in-process-hosting-model) eingestellt. Wenn der Wert lautet `<AspNetCoreHostingModel>` `InProcess`, können Sie optional die-Eigenschaft in der Projektdatei entfernen.

## <a name="jsonnet-support"></a>JSON.NET-Unterstützung

Als Teil der Arbeit zur [Verbesserung der ASP.net Core Shared Framework](https://blogs.msdn.microsoft.com/webdev/2018/10/29/a-first-look-at-changes-coming-in-asp-net-core-3-0/)wurde [JSON.net](https://www.newtonsoft.com/json/help/html/Introduction.htm) aus dem freigegebenen Framework ASP.net Core entfernt. Ihre APP erfordert ggf. diesen Verweis, `Newtonsoft.Json`Wenn Sie das-spezifische Feature verwendet, z. b. jsonpatch oder Konverter, oder wenn Sie spezifische Typen [formatiert](xref:web-api/advanced/formatting) `Newtonsoft.Json`.

So verwenden sie JSON.net in einem ASP.net Core 3,0-Projekt:

* Fügen Sie [Microsoft.AspNetCore.Mvc.NewtonsoftJson](https://nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson) einen Paketverweis hinzu.
* Aktualisieren `Startup.ConfigureServices` , um `AddNewtonsoftJson`aufzurufen.

  ```csharp
  services.AddMvc()
      .AddNewtonsoftJson();
  ```

  `AddNewtonsoftJson`ist mit den neuen Registrierungsmethoden für den MVC-Dienst kompatibel:

  * `AddRazorPages`
  * `AddControllersWithViews`
  * `AddControllers`

  ```csharp
  services.AddControllers()
      .AddNewtonsoftJson();
  ```

  JSON.NET-Einstellungen können im `AddNewtonsoftJson`-Befehl festgelegt werden:

  ```csharp
  services.AddMvc()
      .AddNewtonsoftJson(options =>
             options.SerializerSettings.ContractResolver =
                new CamelCasePropertyNamesContractResolver());
  ```

## <a name="mvc-service-registration"></a>MVC-Dienst Registrierung

In ASP.net Core 3,0 werden neue Optionen zum Registrieren von MVC `Startup.ConfigureServices`-Szenarien in hinzugefügt.

Drei neue Erweiterungs Methoden der obersten Ebene, die sich auf MVC `IServiceCollection` -Szenarios für beziehen, sind verfügbar. Vorlagen verwenden diese neuen Methoden anstelle von `UseMvc`. Verhält sich jedoch weiterhin wie in früheren Versionen. `AddMvc`

Im folgenden Beispiel wird die Unterstützung für Controller und API-Funktionen hinzugefügt, jedoch keine Sichten oder Seiten. Die API-Vorlage verwendet diesen Code:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllers();
}
```

Im folgenden Beispiel werden die Unterstützung für Controller, API-bezogene Features und Sichten, aber keine Seiten hinzugefügt. Die Vorlage Webanwendung (MVC) verwendet folgenden Code:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllersWithViews();
}
```

Im folgenden Beispiel wird Unterstützung für Razor Pages und minimale Controller Unterstützung hinzugefügt. Die Webanwendungsvorlage verwendet diesen Code:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddRazorPages();
}
```

Die neuen Methoden können ebenfalls kombiniert werden. Das folgende Beispiel entspricht dem Aufrufen `AddMvc` von in ASP.net Core 2,2:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllers();
    services.AddRazorPages();
}
```

## <a name="update-routing-startup-code"></a>Aktualisieren des Routing Startcodes

Wenn eine APP oder `UseMvc` `UseSignalR`aufruft, migrieren Sie die APP nach Möglichkeit zum [Endpunkt Routing](xref:fundamentals/routing) . Um die Kompatibilität mit dem Endpunkt Routing mit früheren Versionen von MVC zu verbessern, haben wir einige der Änderungen in der URL-Generierung wieder hergestellt, die in ASP.net Core 2,2 eingeführt wurden. Wenn bei der Verwendung des Endpunkt Routings in 2,2 Probleme auftreten, erwarten Sie Verbesserungen in ASP.net Core 3,0 mit folgenden Ausnahmen:

* Wenn die APP implementiert `IRouter` oder von `Route`erbt, empfiehlt es sich, zu diesem Zeitpunkt die Migration zu vermeiden. Geben Sie Feedback unter [Plan zum Migrieren von irouter-basierten Implementierungen zum Endpunkt Routing](https://github.com/aspnet/AspNetCore/issues/4221)an.

* Wenn die APP direkt in `RouteData.Routers` MVC zugreift, empfiehlt es sich, die Migration zu diesem Zeitpunkt zu vermeiden. Geben Sie Feedback zu [Migrations Leit Fäden für die Verwendung von RouteData. Routers](https://github.com/aspnet/AspNetCore/issues/9148).

Das Endpunkt Routing unterstützt die gleiche Routing Muster Syntax und die Funktionen zum `IRouter`Erstellen von Routen Mustern wie. Das Endpunkt Routing `IRouteConstraint`unterstützt. Das Endpunkt Routing `[Route]`unter `[HttpGet]`stützt, und die anderen MVC-Routing Attribute.

Bei den meisten Anwendungen müssen `Startup` nur Änderungen vorgenommen werden.

### <a name="migrate-startupconfigure"></a>"Startup. configure" Migrieren

Allgemeine Hinweise:

* Fügen `UseRouting`Sie hinzu.
* Wenn die APP aufruft `UseStaticFiles`, platzieren `UseStaticFiles` Sie es **vor** `UseRouting`.
* Wenn die APP Authentifizierungs-/Autorisierungsfeatures `AuthorizePage` wie `[Authorize]`oder verwendet, platzieren Sie `UseAuthentication` den `UseAuthorization` -Befehl nach und **nach** `UseRouting` (und **danach** `UseCors` , wenn cors-Middleware verwendet wird).
* Ersetzen `UseMvc` Sie `UseSignalR` oder durch`UseEndpoints`.
* Wenn die APP [cors](xref:security/cors) `[EnableCors]`-Szenarien (z. b.) verwendet, `UseCors` platzieren Sie den-aufrufvor allen anderen Middlewares, die `UseCors` cors `UseAuthentication`verwenden (z `UseMvc`. b. vor, `UseAuthorization`und).
* Ersetzen `IHostingEnvironment` Sie `IWebHostEnvironment` durch, und `using` fügen Sie eine <xref:Microsoft.Extensions.Hosting?displayProperty=fullName> -Anweisung für den Namespace hinzu.
* Ersetzen `IApplicationLifetime` Sie <xref:Microsoft.Extensions.Hosting.IHostApplicationLifetime> dies<xref:Microsoft.Extensions.Hosting?displayProperty=fullName> durch (-Namespace).
* Ersetzen `EnvironmentName` Sie <xref:Microsoft.Extensions.Hosting.Environments> dies<xref:Microsoft.Extensions.Hosting?displayProperty=fullName> durch (-Namespace).

Im folgenden finden Sie ein Beispiel `Startup.Configure` für eine typische ASP.net Core 2,2-App:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseStaticFiles();

    app.UseAuthentication();

    app.UseSignalR(hubs =>
    {
        hubs.MapHub<ChatHub>("/chat");
    });

    app.UseMvc(routes =>
    {
        routes.MapRoute("default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

Nach dem Aktualisieren des `Startup.Configure` vorherigen Codes:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseStaticFiles();

    app.UseRouting();

    app.UseCors();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>("/chat");
        endpoints.MapControllerRoute("default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

### <a name="security-middleware-guidance"></a>Leitfaden zur Sicherheit von Middleware

Unterstützung für die Autorisierung und cors ist in Bezug auf den [Middleware](xref:fundamentals/middleware/index) -Ansatz einheitlich. Dies ermöglicht die Verwendung derselben Middleware und derselben Funktionalität in diesen Szenarien. In dieser Version wird eine aktualisierte Autorisierungs Middleware bereitgestellt, und die cors-Middleware wird verbessert, sodass Sie die von MVC-Controllern verwendeten Attribute verstehen kann.

#### <a name="cors"></a>CORS

Zuvor war es möglicherweise schwierig, cors zu konfigurieren. Die Middleware wurde zur Verwendung in einigen Anwendungsfällen bereitgestellt, aber MVC-Filter waren in anderen Anwendungsfällen **ohne** die Middleware vorgesehen. Bei ASP.net Core 3,0 wird empfohlen, dass alle apps, die cors benötigen, die cors-Middleware zusammen mit dem Endpunkt Routing verwenden. `UseCors`kann mit einer Standard Richtlinie angegeben werden, und `[EnableCors]` die `[DisableCors]` -und-Attribute können verwendet werden, um die Standard Richtlinie nach Bedarf zu überschreiben.

Im folgenden Beispiel:

* Cors ist für alle Endpunkte mit der `default` benannten Richtlinie aktiviert.
* Die `MyController` -Klasse deaktiviert cors mit dem `[DisableCors]` -Attribut.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseCors("default");

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

[DisableCors]
public class MyController : ControllerBase
{
    ...
}
```

#### <a name="authorization"></a>Autorisierung

In früheren Versionen von ASP.net Core wurde Unterstützung der Autorisierung über `[Authorize]` das-Attribut bereitgestellt. Die Autorisierungs Middleware war nicht verfügbar. In ASP.net Core 3,0 ist die Autorisierungs Middleware erforderlich. Es wird empfohlen, die ASP.net Core Autorisierungs Middleware (`UseAuthorization`) direkt nach `UseAuthentication`zu platzieren. Die Middleware für die Autorisierung kann auch mit einer Standard Richtlinie konfiguriert werden, die überschrieben werden kann.

In ASP.net Core 3,0 oder `UseAuthorization` höher wird in `Startup.Configure`aufgerufen, und für Folgendes `HomeController` ist ein angemeldeter Benutzer erforderlich:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

public class HomeController : ControllerBase
{
    [Authorize]
    public IActionResult BuyWidgets()
    {
        ...
    }
}
```

Wenn die APP `AuthorizeFilter` als globaler Filter in MVC verwendet, empfiehlt es sich, den Code so zu umgestalten, dass er eine Richtlinie `AddAuthorization`im-Befehl bereitstellt.

Das `DefaultPolicy` ist anfänglich so konfiguriert, dass eine Authentifizierung erforderlich ist, sodass keine zusätzliche Konfiguration erforderlich ist. Im folgenden Beispiel werden die MVC-Endpunkte als `RequireAuthorization` markiert, sodass alle Anforderungen auf der `DefaultPolicy`Grundlage von autorisiert werden müssen. Der ermöglicht jedoch `HomeController` den Zugriff, ohne dass der Benutzer sich bei der APP `[AllowAnonymous]`anmeldet. Dies liegt an folgendem:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute().RequireAuthorization();
    });
}

[AllowAnonymous]
public class HomeController : ControllerBase
{
    ...
}
```

Richtlinien können auch angepasst werden. Wenn Sie auf dem vorherigen Beispiel aufbauen `DefaultPolicy` , wird der so konfiguriert, dass eine Authentifizierung und ein bestimmter Bereich erforderlich sind:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    ...

    services.AddAuthorization(options =>
    {
        options.DefaultPolicy = new AuthorizationPolicyBuilder()
          .RequireAuthenticatedUser()
          .RequireScope("MyScope")
          .Build();
    });
}

public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute().RequireAuthorization();
    });
}

[AllowAnonymous]
public class HomeController : ControllerBase
{
    ...
}
```

Alternativ können alle Endpunkte so konfiguriert werden, dass Sie ohne `[Authorize]` oder `RequireAuthorization` durch Konfigurieren von `FallbackPolicy`eine Autorisierung erfordern. Der `FallbackPolicy` unterscheidet sich `DefaultPolicy`vom. `FallbackPolicy` Wird von `[Authorize]` oder`RequireAuthorization`ausgelöst, während das ausgelöst wird, wenn keine andere Richtlinie festgelegt ist. `DefaultPolicy` `FallbackPolicy`ist anfänglich so konfiguriert, dass Anforderungen ohne Autorisierung zugelassen werden.

Das folgende Beispiel ist identisch mit dem vorherigen `DefaultPolicy` Beispiel `FallbackPolicy` , verwendet jedoch, um immer eine Authentifizierung für alle Endpunkte anzufordern, `[AllowAnonymous]` außer wenn angegeben ist:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    ...
    services.AddAuthorization(options =>
    {
        options.FallbackPolicy = new AuthorizationPolicyBuilder()
          .RequireAuthenticatedUser()
          .RequireScope("MyScope")
          .Build();
    });
}

public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

[AllowAnonymous]
public class HomeController : ControllerBase
{
    ...
}
```

Die Autorisierung durch Middleware funktioniert, ohne dass das Framework über bestimmte Kenntnisse der Autorisierung verfügt. Integritäts [Prüfungen](xref:host-and-deploy/health-checks) haben beispielsweise keine spezifischen Kenntnisse der Autorisierung, aber Integritätsprüfungen können eine konfigurierbare Autorisierungs Richtlinie aufweisen, die von der Middleware angewendet wird.

Außerdem kann jeder Endpunkt seine Autorisierungs Anforderungen anpassen. Im folgenden Beispiel `UseAuthorization` wird die Autorisierung mit der `DefaultPolicy`verarbeitet, aber der `/healthz` Integritätsprüfung- `admin` Endpunkt erfordert einen Benutzer:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints
            .MapHealthChecks("/healthz")
            .RequireAuthorization(new AuthorizeAttribute(){ Roles = "admin", });
    });
}
```

Der Schutz wird für einige Szenarien implementiert. `UseEndpoint`Middleware löst eine Ausnahme aus, wenn eine Autorisierungs-oder cors-Richtlinie aufgrund fehlender Middleware übersprungen wird. Analyse Unterstützung, um zusätzliches Feedback zur Fehlkonfiguration bereitzustellen.

### <a name="migrate-signalr"></a>Migrieren von signalr

Die Zuordnung von signalr Hubs erfolgt nun in `UseEndpoints`.

Ordnen Sie jeden Hub `MapHub`mit zu. Wie in früheren Versionen wird jeder Hub explizit aufgelistet.

Im folgenden Beispiel wird die Unterstützung für `ChatHub` den signalr-Hub hinzugefügt:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>();
    });
}
```

Es gibt eine neue Option zum Steuern von Größenbeschränkungen für Nachrichten von Clients. Beispiel: in `Startup.ConfigureServices`:

```csharp
services.AddSignalR(hubOptions =>
{
    hubOptions.MaximumReceiveMessageSize = 32768;
});
```

In ASP.net Core 2,2 konnten Sie die festlegen, `TransportMaxBufferSize` die die maximale Nachrichtengröße effektiv steuern würde. In ASP.net Core 3,0 steuert diese Option jetzt nur die maximale Größe, bevor der Rückdruck festgestellt wird.

### <a name="migrate-mvc-controllers"></a>Migration von MVC-Controllern

Die Zuordnung von Controllern erfolgt nun `UseEndpoints`in.

Fügen `MapControllers` Sie hinzu, wenn die APP Attribut Routing verwendet. Da das Routing Unterstützung für viele Frameworks in ASP.net Core 3,0 oder höher bietet, ist das Hinzufügen von Attribut Weiterleitungs Controllern ein Opt-in.

Ersetzen Sie Folgendes:

* `MapRoute`entspricht`MapControllerRoute`
* `MapAreaRoute`entspricht`MapAreaControllerRoute`

Da das Routing nun die Unterstützung für mehr als nur MVC umfasst, hat sich die Terminologie geändert, damit diese Methoden deutlich erkennen können, was Sie tun. Herkömmliche `MapControllerRoute` Routen wie `MapAreaControllerRoute` werden in / der Reihenfolge angewendet, in der Sie hinzugefügt werden. / `MapDefaultControllerRoute` Platzieren Sie zunächst spezifischere Routen (z. b. Routen für einen Bereich).

Im folgenden Beispiel:

* `MapControllers`Fügt Unterstützung für Attribut Weiterleitungs Controller hinzu.
* `MapAreaControllerRoute`Fügt eine konventionelle Route für Controller in einem Bereich hinzu.
* `MapControllerRoute`Fügt eine konventionelle Route für Controller hinzu.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapControllers();
        endpoints.MapAreaControllerRoute(
            "admin",
            "admin",
            "Admin/{controller=Home}/{action=Index}/{id?}");
        endpoints.MapControllerRoute(
            "default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

### <a name="migrate-razor-pages"></a>Migrieren Razor Pages

Die Zuordnung Razor Pages jetzt innerhalb `UseEndpoints`von stattfinden.

Fügen `MapRazorPages` Sie hinzu, wenn die APP Razor Pages verwendet. Da das Endpunkt Routing Unterstützung für viele Frameworks umfasst, ist das Hinzufügen von Razor Pages jetzt deaktiviert.

Im folgenden Beispiel wird `MapRazorPages` Unterstützung für Razor Pages hinzugefügt:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapRazorPages();
    });
}
```

### <a name="use-mvc-without-endpoint-routing"></a>Verwenden von MVC ohne Endpunkt Routing

Die Verwendung von MVC `UseMvcWithDefaultRoute` über `UseMvc` oder in ASP.net Core 3,0 erfordert ein `Startup.ConfigureServices`explizites Opt-in in. Dies ist erforderlich, da MVC wissen muss, ob es während der Initialisierung auf die Autorisierung und die cors-Middleware zurückgreifen kann. Es wird ein Analyzer bereitgestellt, der warnt, wenn die APP versucht, eine nicht unterstützte Konfiguration zu verwenden.

Wenn die APP Legacy `IRouter` Unterstützung erfordert, deaktivieren `EnableEndpointRouting` Sie die Verwendung der folgenden Ansätze in: `Startup.ConfigureServices`

```csharp
services.AddMvc(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddControllers(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddControllersWithViews(options => options.EnableEndpointRouting = false);

```

```csharp
services.AddRazorPages().AddMvcOptions(options => options.EnableEndpointRouting = false);
```

### <a name="migrate-health-checks"></a>Integritätsprüfungen migrieren

Integritätsprüfungen können als *routerware* mit Endpunkt Routing verwendet werden.

Fügen `MapHealthChecks` Sie hinzu, um Integritätsprüfungen mit Endpunkt Routing zu verwenden. Die `MapHealthChecks` -Methode akzeptiert Argumente `UseHealthChecks`ähnlich wie. Der Vorteil der Verwendung `MapHealthChecks` von `UseHealthChecks` over ist die Fähigkeit, Autorisierung anzuwenden und eine präzisere Kontrolle über die abgleichsrichtlinie zu haben.

Im folgenden Beispiel `MapHealthChecks` wird für einen Integritäts Prüf `/healthz`Punkt aufgerufen:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHealthChecks("/healthz", new HealthCheckOptions() { });
    });
}
```

## <a name="hostbuilder-replaces-webhostbuilder"></a>Der hostbuilder ersetzt webhostbuilder.

In den ASP.net Core 3,0-Vorlagen wird [generischer Host](xref:fundamentals/host/generic-host)verwendet. In früheren Versionen wurde [Webhost](xref:fundamentals/host/web-host)verwendet. Der folgende Code zeigt die von der ASP.net Core 3,0 `Program` -Vorlage generierte Klasse:

[!code-csharp[](22-to-30/samples/Program.cs?name=snippet)]

Der folgende Code zeigt die von der Vorlage generierte `Program` ASP.net Core 2,2-Klasse:

[!code-csharp[](22-to-30/samples/Program2.2.cs?name=snippet)]

<xref:Microsoft.AspNetCore.Hosting.IWebHostBuilder>verbleibt in 3,0 und ist der Typ von `webBuilder` , der im vorangehenden Codebeispiel angezeigt wird. <xref:Microsoft.AspNetCore.Hosting.WebHostBuilder>wird in einer zukünftigen Version als veraltet markiert und durch `HostBuilder`ersetzt.

Die signifikanteste Änderung `WebHostBuilder` von `HostBuilder` in ist die [Abhängigkeitsinjektion (di)](xref:fundamentals/dependency-injection). Wenn Sie `HostBuilder`verwenden, können Sie nur <xref:Microsoft.Extensions.Configuration.IConfiguration> den <xref:Microsoft.AspNetCore.Hosting.IHostingEnvironment> Konstruktor von und in `Startup`einfügen. Die `HostBuilder` di-Einschränkungen:

* Aktivieren Sie den di-Container nur ein einziges Mal.
* Vermeidet die resultierenden Probleme bei der Objekt Lebensdauer wie das Auflösen mehrerer Instanzen von Singletons.

## <a name="addauthorization-moved-to-a-different-assembly"></a>Addauthorization in eine andere Assembly verschoben

Die Methoden ASP.net Core 2,2 und `AddAuthorization` niedriger in *Microsoft. aspnetcore. Authorization. dll*:

* Wurden umbenannt `AddAuthorizationCore`.
* Wurden in " *Microsoft. aspnetcore. Authorization. Policy. dll*" verschoben.

Apps, die sowohl *Microsoft. aspnetcore. Authorization. dll* als auch *Microsoft. aspnetcore. Authorization. Policy. dll* verwenden, sind nicht betroffen.

Apps, die nicht *Microsoft. aspnetcore. Authorization. Policy. dll* verwenden, sollten eine der folgenden Aktionen ausführen:

* Wechseln zu mithilfe von`AddAuthorizationCore`
* Fügen Sie einen Verweis auf *Microsoft. aspnetcore. Authorization. Policy. dll*hinzu.

Weitere Informationen finden Sie unter [Breaking Change in `AddAuthorization(o =>`(Breaking Change in) der Überlastung in einer anderen Assembly #386](https://github.com/aspnet/Announcements/issues/386).

## <a name="update-signalr-code"></a>Aktualisieren von signalr-Code

`System.Text.Json`ist nun das Standardhub Protokoll, das sowohl vom Client als auch vom Server verwendet wird.

In `Startup.ConfigureServices`wird aufgerufen `AddJsonProtocol` , um Serialisierungsoptionen festzulegen.

**Servers**

```csharp
services.AddSignalR(...)
        .AddJsonProtocol(options =>
        {
            options.WriteIndented = false;
        })
```

**Ent**

```csharp
new HubConnectionBuilder()
    .WithUrl("/chatHub")
    .AddJsonProtocol(options =>
    {
        options.WriteIndented = false;
    })
    .Build();
```

### <a name="switch-to-newtonsoftjson"></a>Wechseln Sie zu "newtonsoft. JSON".

Wenn Sie Funktionen von `Newtonsoft.Json` verwenden, die in `System.Text.Json`nicht unterstützt werden, können Sie zurück `Newtonsoft.Json`zu folgenden Aktionen wechseln:

1. Installieren Sie das nuget-Paket [Microsoft. aspnetcore. signalr. Protokolls. newtonsoft JSON](https://www.nuget.org/packages/Microsoft.AspNetCore.SignalR.Protocols.NewtonsoftJson) .
1. Verketten Sie auf dem Client `AddNewtonsoftJsonProtocol` einen Methoden Aufrufder `HubConnectionBuilder` -Instanz:

    ```csharp
    new HubConnectionBuilder()
        .WithUrl("/chatHub")
        .AddNewtonsoftJsonProtocol(...)
        .Build();
    ```

1. Verketten Sie auf dem- `AddNewtonsoftJsonProtocol` Server einen Methodenaufrufe `AddSignalR` des-Methoden `Startup.ConfigureServices`Aufrufes in:

    ```csharp
    services.AddSignalR()
        .AddNewtonsoftJsonProtocol(...);
    ```

## <a name="opt-in-to-runtime-compilation"></a>Abonnieren der Lauf Zeit Kompilierung

In 3,0 ist die Lauf Zeit Kompilierung ein Opt-in-Szenario. Informationen zum Aktivieren der Lauf Zeit https://docs.microsoft.com/aspnet/core/mvc/views/view-compilation?view=aspnetcore-3.0#runtime-compilation Kompilierung finden Sie unter.
