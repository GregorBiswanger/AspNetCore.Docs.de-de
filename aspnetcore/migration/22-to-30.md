---
title: Migrieren von ASP.NET Core 2.2 zu 3.0
author: rick-anderson
description: Erfahren Sie, wie Sie ein ASP.net Core 2.2-Projekt zu ASP.net Core 3,0 migrieren.
ms.author: riande
ms.custom: mvc
ms.date: 01/13/2020
no-loc:
- SignalR
uid: migration/22-to-30
ms.openlocfilehash: 1ebb08178fc72cd80d505a0c9d29718dd67364b1
ms.sourcegitcommit: cbd30479f42cbb3385000ef834d9c7d021fd218d
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 01/16/2020
ms.locfileid: "76146471"
---
# <a name="migrate-from-aspnet-core-22-to-30"></a>Migrieren von ASP.NET Core 2.2 zu 3.0

Von [Scott Adder](https://github.com/scottaddie) und [Rick Anderson](https://twitter.com/RickAndMSFT)

In diesem Artikel wird erläutert, wie ein vorhandenes ASP.net Core 2.2-Projekt auf ASP.net Core 3.0 aktualisiert wird.

## <a name="prerequisites"></a>Erforderliche Komponenten

# <a name="visual-studiotabvisual-studio"></a>[Visual Studio](#tab/visual-studio)

[!INCLUDE[](~/includes/net-core-prereqs-vs-3.0.md)]

# <a name="visual-studio-codetabvisual-studio-code"></a>[Visual Studio Code](#tab/visual-studio-code)

[!INCLUDE[](~/includes/net-core-prereqs-vsc-3.0.md)]

# <a name="visual-studio-for-mactabvisual-studio-mac"></a>[Visual Studio für Mac](#tab/visual-studio-mac)

[!INCLUDE[](~/includes/net-core-prereqs-mac-3.0.md)]

---

## <a name="update-net-core-sdk-version-in-globaljson"></a>Aktualisieren der .NET Core SDK-Version in „global.json“

Wenn Ihre Lösung auf eine [globale. JSON](/dotnet/core/tools/global-json) -Datei basiert, um eine bestimmte .net Core SDK Version zu erreichen, aktualisieren Sie die `version`-Eigenschaft auf die Version 3,0, die auf Ihrem Computer installiert ist:

```json
{
  "sdk": {
    "version": "3.0.100"
  }
}
```

## <a name="update-the-project-file"></a>Aktualisieren der Projektdatei

### <a name="update-the-target-framework"></a>Aktualisieren des Ziel Frameworks

ASP.net Core 3,0 und höher wird nur unter .net Core ausgeführt. Legen Sie den [zielframeworkmoniker (TFM)](/dotnet/standard/frameworks) auf `netcoreapp3.0`fest:

[!code-xml[](22-to-30/samples/Web1.csproj?highlight=4)]

### <a name="remove-obsolete-package-references"></a>Veraltete Paket Verweise entfernen

Eine große Anzahl von nuget-Paketen wird nicht für ASP.net Core 3,0 erstellt. Solche Paket Verweise sollten aus der Projektdatei entfernt werden. Sehen Sie sich die folgende Projektdatei für eine ASP.net Core 2,2-Web-App an:

```xml
<Project Sdk="Microsoft.NET.Sdk.Web">

  <PropertyGroup>
    <TargetFramework>netcoreapp2.2</TargetFramework>
    <AspNetCoreHostingModel>InProcess</AspNetCoreHostingModel>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.AspNetCore.App"/>
    <PackageReference Include="Microsoft.AspNetCore.Razor.Design" Version="2.2.0" PrivateAssets="All" />
  </ItemGroup>

</Project>
```

Die aktualisierte Projektdatei für ASP.net Core 3,0:

[!code-xml[](22-to-30/samples/Web1.csproj?highlight=4)]

Die aktualisierte ASP.net Core 3,0-Projektdatei:

* Gehen Sie im `<PropertyGroup>` folgendermaßen vor:
  * Aktualisiert den TFM auf `netcoreapp3.0`
  * Entfernt das `<AspNetCoreHostingModel>` Element. Weitere Informationen finden Sie unter [in-Process-Hostingmodell](#in-process-hosting-model) in diesem Dokument.

* Gehen Sie im `<ItemGroup>` folgendermaßen vor:
  * `Microsoft.AspNetCore.App` entfernt. Weitere Informationen finden Sie in diesem Dokument in der [frameworkreferenz](#framework-reference) .
  * `Microsoft.AspNetCore.Razor.Design` wird entfernt und in der folgenden Liste von Paketen, die nicht mehr erstellt werden.

Um die vollständige Liste der Pakete anzuzeigen, die nicht mehr erstellt werden, wählen Sie die folgende Erweiterungs Liste aus:

<details>
    <summary>Klicken Sie, um die Liste der Pakete zu erweitern, die nicht mehr erstellt werden</summary>
    <ul>
        <li>Microsoft.AspNetCore</li>
        <li>Microsoft.AspNetCore.All</li>
        <li>Microsoft.AspNetCore.App</li>
        <li>Microsoft.AspNetCore.Antiforgery</li>
        <li>Microsoft.AspNetCore.Authentication</li>
        <li>Microsoft.AspNetCore.Authentication.Abstractions</li>
        <li>Microsoft.AspNetCore.Authentication.Cookies</li>
        <li>Microsoft.AspNetCore.Authentication.Core</li>
        <li>Microsoft.AspNetCore.Authentication.OAuth</li>
        <li>Microsoft.AspNetCore.Authorization.Policy</li>
        <li>Microsoft.AspNetCore.CookiePolicy</li>
        <li>Microsoft.AspNetCore.Cors</li>
        <li>Microsoft.AspNetCore.Diagnostics</li>
        <li>Microsoft.AspNetCore.Diagnostics.HealthChecks</li>
        <li>Microsoft.AspNetCore.HostFiltering</li>
        <li>Microsoft.AspNetCore.Hosting</li>
        <li>Microsoft.AspNetCore.Hosting.Abstractions</li>
        <li>Microsoft.AspNetCore.Hosting.Server.Abstractions</li>
        <li>Microsoft.AspNetCore.Http</li>
        <li>Microsoft.AspNetCore.Http.Abstractions</li>
        <li>Microsoft.AspNetCore.Http.Connections</li>
        <li>Microsoft.AspNetCore.Http.Extensions</li>
        <li>Microsoft.AspNetCore.HttpOverrides</li>
        <li>Microsoft.AspNetCore.HttpsPolicy</li>
        <li>Microsoft.AspNetCore.Identity</li>
        <li>Microsoft.AspNetCore.Localization</li>
        <li>Microsoft.AspNetCore.Localization.Routing</li>
        <li>Microsoft.AspNetCore.Mvc</li>
        <li>Microsoft.AspNetCore.Mvc.Abstractions</li>
        <li>Microsoft.AspNetCore.Mvc.Analyzers</li>
        <li>Microsoft.AspNetCore.Mvc.ApiExplorer</li>
        <li>Microsoft.AspNetCore.Mvc.Api.Analyzers</li>
        <li>Microsoft.AspNetCore.Mvc.Core</li>
        <li>Microsoft.AspNetCore.Mvc.Cors</li>
        <li>Microsoft.AspNetCore.Mvc.DataAnnotations</li>
        <li>Microsoft.AspNetCore.Mvc.Formatters.Json</li>
        <li>Microsoft.AspNetCore.Mvc.Formatters.Xml</li>
        <li>Microsoft.AspNetCore.Mvc.Localization</li>
        <li>Microsoft.AspNetCore.Mvc.Razor</li>
        <li>Microsoft.AspNetCore.Mvc.Razor.ViewCompilation</li>
        <li>Microsoft.AspNetCore.Mvc.RazorPages</li>
        <li>Microsoft.AspNetCore.Mvc.TagHelpers</li>
        <li>Microsoft.AspNetCore.Mvc.ViewFeatures</li>
        <li>Microsoft.AspNetCore.Razor</li>
        <li>Microsoft.AspNetCore.Razor.Runtime</li>
        <li>Microsoft.AspNetCore.Razor.Design</li>
        <li>Microsoft.AspNetCore.ResponseCaching</li>
        <li>Microsoft.AspNetCore.ResponseCaching.Abstractions</li>
        <li>Microsoft.AspNetCore.ResponseCompression</li>
        <li>Microsoft.AspNetCore.Rewrite</li>
        <li>Microsoft.AspNetCore.Routing</li>
        <li>Microsoft.AspNetCore.Routing.Abstractions</li>
        <li>Microsoft.AspNetCore.Server.HttpSys</li>
        <li>Microsoft.AspNetCore.Server.IIS</li>
        <li>Microsoft.AspNetCore.Server.IISIntegration</li>
        <li>Microsoft.AspNetCore.Server.Kestrel</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Core</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Https</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets</li>
        <li>Microsoft.AspNetCore.Session</li>
        <li>Microsoft. aspnetcore.SignalR</li>
        <li>Microsoft.aspnetcore.SignalR.Core</li>
        <li>Microsoft.AspNetCore.StaticFiles</li>
        <li>Microsoft.AspNetCore.WebSockets</li>
        <li>Microsoft.AspNetCore.WebUtilities</li>
        <li>Microsoft.net. http. Headers</li>
    </ul>
</details>

### <a name="review-breaking-changes"></a>Wichtige Änderungen überprüfen

[Wichtige Änderungen überprüfen](#break)

### <a name="framework-reference"></a>Frameworkverweis

Features von ASP.net Core, die über eines der oben aufgeführten Pakete verfügbar waren, sind als Teil des `Microsoft.AspNetCore.App` Shared-Frameworks verfügbar. Das *freigegebene Framework* ist der Satz von Assemblys (*DLL*-Dateien), die auf dem Computer installiert werden und eine Laufzeitkomponente sowie ein Zielpaket enthalten. Weitere Informationen finden Sie unter [The shared framework](https://natemcmaster.com/blog/2018/08/29/netcore-primitives-2/) (Das freigegebene Framework).

* Projekte, die auf das `Microsoft.NET.Sdk.Web` SDK abzielen, verweisen implizit auf das `Microsoft.AspNetCore.App`-Framework.

  Für diese Projekte sind keine weiteren Verweise erforderlich:

  ```xml
  <Project Sdk="Microsoft.NET.Sdk.Web">
    <PropertyGroup>
      <TargetFramework>netcoreapp3.0</TargetFramework>
    </PropertyGroup>
      ...
  </Project>
  ```

* Für Projekte, die auf `Microsoft.NET.Sdk` oder `Microsoft.NET.Sdk.Razor` SDK abzielen, sollte `Microsoft.AspNetCore.App`eine explizite `FrameworkReference` hinzugefügt werden:

  ```xml
  <Project Sdk="Microsoft.NET.Sdk.Razor">
    <PropertyGroup>
      <TargetFramework>netcoreapp3.0</TargetFramework>
    </PropertyGroup>

    <ItemGroup>
      <FrameworkReference Include="Microsoft.AspNetCore.App" />
    </ItemGroup>
      ...
  </Project>
  ```

#### <a name="framework-dependent-builds-using-docker"></a>Framework-abhängige Builds mithilfe von Docker

Framework-abhängige Builds von Konsolen-apps, die ein Paket verwenden, das vom ASP.net Core [Shared Framework](https://natemcmaster.com/blog/2018/08/29/netcore-primitives-2/) abhängt, können den folgenden Laufzeitfehler verursachen:

```console
It was not possible to find any compatible framework version
The specified framework 'Microsoft.AspNetCore.App', version '3.0.0' was not found.
  - No frameworks were found.
```

`Microsoft.AspNetCore.App` ist das freigegebene Framework, das die ASP.net Core Runtime enthält und nur auf dem docker-Image [dotnet/Core/ASPNET](https://hub.docker.com/_/microsoft-dotnet-core-aspnet/) vorhanden ist. Das 3,0 SDK reduziert die Größe von Framework-abhängigen Builds mit ASP.net Core, indem doppelte Kopien von Bibliotheken, die im freigegebenen Framework verfügbar sind, nicht eingeschlossen werden. Dies ist eine potenzielle Einsparung von bis zu 18 MB, aber es ist erforderlich, dass die ASP.net Core-Laufzeit zum Ausführen der app vorhanden bzw. installiert ist.

Überprüfen Sie die *runtimeconfig. JSON* -Datei, die während der Erstellung/Veröffentlichung Ihrer APP generiert wird, um zu bestimmen, ob die APP eine Abhängigkeit (entweder direkt oder indirekt) auf dem ASP.net Core freigegebenen Framework aufweist. Die folgende JSON-Datei zeigt eine Abhängigkeit vom ASP.net Core Shared Framework:

```json
{
  "runtimeOptions": {
    "tfm": "netcoreapp3.0",
    "framework": {
      "name": "Microsoft.AspNetCore.App",
      "version": "3.0.0"
    },
    "configProperties": {
      "System.GC.Server": true
    }
  }
}
```

Wenn Ihre APP docker verwendet, verwenden Sie ein Basis Image, das ASP.net Core 3,0 enthält. Beispielsweise `docker pull mcr.microsoft.com/dotnet/core/aspnet:3.0`.

### <a name="add-package-references-for-removed-assemblies"></a>Paket Verweise für entfernte Assemblys hinzufügen

ASP.net Core 3,0 entfernt einige Assemblys, die zuvor Teil des `Microsoft.AspNetCore.App` Paket Verweises waren. Um zu visualisieren, welche Assemblys entfernt wurden, vergleichen Sie die beiden freigegebenen frameworkordner Beispielsweise ein Vergleich der Versionen 2.2.7 und 3.0.0:

![Vergleich von Shared Framework](22-to-30/_static/assembly-diff.png)

Um die von den entfernten Assemblys bereitgestellten Funktionen weiterhin zu verwenden, verweisen Sie auf die 3,0-Versionen der entsprechenden Pakete:

* Bei einer Vorlagen generierten Web-App mit **einzelnen Benutzerkonten** müssen die folgenden Pakete hinzugefügt werden:

  [!code-xml[](22-to-30/samples/WebFull.csproj?highlight=9-13)]

* [Microsoft. entityframeworkcore](https://www.nuget.org/packages/Microsoft.EntityFrameworkCore)

  Weitere Informationen zum Verweisen auf das Datenbankanbieter spezifische Paket finden Sie unter [Datenbankanbieter](/ef/core/providers/index).

* Identitäts Benutzeroberfläche

  Unterstützung für die [Benutzeroberfläche der Identität](xref:security/authentication/identity) kann durch Verweisen auf das [Microsoft. aspnetcore. Identity. UI](https://www.nuget.org/packages/Microsoft.AspNetCore.Identity.UI) -Paket hinzugefügt werden.

* Spa-Dienste

  * [Microsoft.AspNetCore.SpaServices](https://www.nuget.org/packages/Microsoft.AspNetCore.SpaServices)
  * [Microsoft. aspnetcore. Spaservices. Extensions](https://www.nuget.org/packages/Microsoft.AspNetCore.SpaServices.Extensions)

* Die Unterstützung von Authentifizierungs &ndash; für Authentifizierungs Abläufe von Drittanbietern ist als nuget-Pakete verfügbar:

  * Facebook OAuth ([Microsoft. aspnetcore. Authentication. Facebook](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Facebook))
  * Google OAuth ([Microsoft. aspnetcore. Authentication. Google](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Google))
  * Microsoft-Konto Authentifizierung ([Microsoft. aspnetcore. Authentication. microsoftaccount](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.MicrosoftAccount))
  * OpenID Connect-Authentifizierung ([Microsoft. aspnetcore. Authentication. openidconnect](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.OpenIdConnect))
  * OpenID Connect-bearertoken ([Microsoft. aspnetcore. Authentication. jwtbearertoken](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.JwtBearer))
  * Twitter OAuth ([Microsoft. aspnetcore. Authentication. Twitter](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Twitter))
  * Wsfederation-Authentifizierung ([Microsoft. aspnetcore. Authentication. wsfederation](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.WsFederation))

* Unterstützung von Formatierung und Inhaltsaushandlung für `System.Net.HttpClient` &ndash; das nuget-Paket " [Microsoft. Aspnet. WebAPI. Client](https://www.nuget.org/packages/Microsoft.AspNet.WebApi.Client/) " bietet nützliche Erweiterbarkeit für `System.Net.HttpClient` mit APIs wie `ReadAsAsync` und `PostJsonAsync`.

* Die Kompilierung der Razor-Laufzeit &ndash; Unterstützung für die Lauf Zeit Kompilierung von Razor-Ansichten und-Seiten ist nun Bestandteil von [Microsoft. aspnetcore. MVC. Razor. runtimecompilation](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Razor.RuntimeCompilation).

* MVC-`Newtonsoft.Json` (JSON.net) unterstützt &ndash; Unterstützung für die Verwendung von MVC mit `Newtonsoft.Json` ist nun Bestandteil von [Microsoft. aspnetcore. MVC. newtonsoft JSON](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson).

## <a name="startup-changes"></a>Start Änderungen

Die folgende Abbildung zeigt die gelöschten und geänderten Zeilen in einer ASP.net Core 2,2 Razor Pages Web-App:

![die gelöschten und geänderten Zeilen in einer ASP.net Core Razor-Web-App mit 2,2.](22-to-30/_static/startup2.2.png)

In der vorangehenden Abbildung ist gelöschter Code rot dargestellt. Der gelöschte Code zeigt keinen Code für Cookie-Optionen an, der vor dem Vergleichen der Dateien gelöscht wurde.

Die folgende Abbildung zeigt die hinzugefügten und geänderten Zeilen in einer ASP.net Core 3,0 Razor Pages Web-App:

![die hinzugefügten und geänderten Zeilen in einer ASP.net Core Razor-Web-App mit 3,0.](22-to-30/_static/startup3.0.png)

In der vorangehenden Abbildung ist der hinzugefügte Code grün dargestellt. Weitere Informationen zu den folgenden Änderungen:

* `services.AddMvc` `services.AddRazorPages`finden Sie in diesem Dokument unter [MVC-Dienst Registrierung](#mvc-service-registration) .
* `CompatibilityVersion`finden Sie unter <xref:mvc/compatibility-version>.
* `IHostingEnvironment` `IWebHostEnvironment`finden Sie in [dieser GitHub-Ankündigung](https://github.com/dotnet/AspNetCore/issues/7749).
* `app.UseAuthorization` wurde den Vorlagen hinzugefügt, um anzuzeigen, dass die Middleware für die Bestell Autorisierung hinzugefügt werden muss. Wenn die APP keine Autorisierung verwendet, können Sie den-`app.UseAuthorization`gefahrlos entfernen.
* `app.UseEndpoints`finden Sie unter [Razor Pages](#razor-pages) oder [Migrieren von "Startup. configure](#migrate-startupconfigure) " in diesem Dokument.

### <a name="analyzer-support"></a>Analyse Unterstützung

Projekte, die auf `Microsoft.NET.Sdk.Web` abzielen, verweisen implizit auf Analysen, die zuvor als Teil des Pakets [Microsoft. aspnetcore. MVC. Analysen](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Analyzers/) ausgeliefert wurden. Es sind keine zusätzlichen Verweise erforderlich, um diese zu aktivieren.

Wenn Ihre APP [API-Analysen](xref:web-api/advanced/analyzers) verwendet, die zuvor mit dem Paket [Microsoft. aspnetcore. MVC. API. Analysen](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Api.Analyzers/) ausgeliefert wurden, bearbeiten Sie die Projektdatei so, dass Sie auf die Analysen verweist, die als Teil des .net Core Web SDK ausgeliefert werden:

```xml
<Project Sdk="Microsoft.NET.Sdk.Web">
    <PropertyGroup>
        <TargetFramework>netcoreapp3.0</TargetFramework>
        <IncludeOpenAPIAnalyzers>true</IncludeOpenAPIAnalyzers>
    </PropertyGroup>

    ...
</Project>
```

### <a name="razor-class-library"></a>Razor-Klassenbibliothek

Razor-Klassen Bibliotheks Projekte, die Benutzeroberflächen Komponenten für MVC bereitstellen, müssen die `AddRazorSupportForMvc`-Eigenschaft in der Projektdatei festlegen:

```xml
<PropertyGroup>
  <AddRazorSupportForMvc>true</AddRazorSupportForMvc>
</PropertyGroup>
```

### <a name="in-process-hosting-model"></a>In-Process-Hostingmodell

Projekte werden standardmäßig auf das [In-Process-Hostingmodell](xref:host-and-deploy/aspnet-core-module#in-process-hosting-model) in ASP.NET Core 3.0 oder höher eingestellt. Wenn der Wert `InProcess` lautet, können Sie optional die Eigenschaft `<AspNetCoreHostingModel>` in der Projektdatei entfernen.

## <a name="kestrel"></a>Kestrel

### <a name="configuration"></a>-Konfiguration

Migrieren Sie die Kestrel-Konfiguration zum von `ConfigureWebHostDefaults` bereitgestellten Webhost-Generator (*Program.cs*):

```csharp
public static IHostBuilder CreateHostBuilder(string[] args) =>
    Host.CreateDefaultBuilder(args)
        .ConfigureWebHostDefaults(webBuilder =>
        {
            webBuilder.ConfigureKestrel(serverOptions =>
            {
                // Set properties and call methods on options
            })
            .UseStartup<Startup>();
        });
```

Wenn die APP den Host mit `HostBuilder`manuell erstellt, wenden Sie `UseKestrel` auf dem Webhost-Generator in `ConfigureWebHostDefaults`an:

```csharp
public static void Main(string[] args)
{
    var host = new HostBuilder()
        .UseContentRoot(Directory.GetCurrentDirectory())
        .ConfigureWebHostDefaults(webBuilder =>
        {
            webBuilder.UseKestrel(serverOptions =>
            {
                // Set properties and call methods on options
            })
            .UseIISIntegration()
            .UseStartup<Startup>();
        })
        .Build();

    host.Run();
}
```

### <a name="connection-middleware-replaces-connection-adapters"></a>Verbindungs-Middleware ersetzt Verbindungs Adapter

Verbindungs Adapter (`Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.IConnectionAdapter`) wurden aus Kestrel entfernt. Ersetzen Sie Verbindungs Adapter durch Verbindungs Middleware. Die Verbindungs Middleware ähnelt http-Middleware in der ASP.net Core Pipeline, aber für Verbindungen auf niedrigerer Ebene. HTTPS und Verbindungs Protokollierung:

* Wurden von Verbindungs Adaptern zur Verbindungs Middleware verschoben.
* Diese Erweiterungs Methoden funktionieren wie in früheren Versionen von ASP.net Core. 

Weitere Informationen finden Sie [im Abschnitt "tlsfilterconnectionhandler" im Abschnitt "listenoptions. Protokolls" im Kestrel-Artikel](/aspnet/core/fundamentals/servers/kestrel?view=aspnetcore-3.0#listenoptionsprotocols).

### <a name="transport-abstractions-moved-and-made-public"></a>Transport Abstraktionen verschoben und öffentlich gemacht

Die Kestrel-Transportschicht wurde in `Connections.Abstractions` als öffentliche Schnittstelle verfügbar gemacht. Als Teil dieser Updates:

* `Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions` und zugeordnete Typen wurden entfernt.
* <xref:Microsoft.AspNetCore.Server.Kestrel.KestrelServerOptions.NoDelay> wurde von <xref:Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions> zu den Transport Optionen verschoben.
* `Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions.Internal.SchedulingMode` wurde aus <xref:Microsoft.AspNetCore.Server.Kestrel.KestrelServerOptions>entfernt.

Weitere Informationen finden Sie in den folgenden GitHub-Ressourcen:

* [Client/Server-Netzwerk Abstraktionen (dotnet/aspnetcore-#10308)](https://github.com/dotnet/AspNetCore/issues/10308)
* [Implementieren Sie die neue Fundament-Listener-Abstraktion und REPLAT Kestrel (dotnet/aspnetcore-#10321).](https://github.com/dotnet/AspNetCore/pull/10321)

### <a name="kestrel-request-trailer-headers"></a>Kestrel-Anforderungs Nachspann Header

Für apps, die auf frühere Versionen von ASP.net Core abzielen:

* Kestrel fügt der Auflistung der Anforderungs Header HTTP/1.1-Auflistungs Header hinzu.
* Nach dem Lesen des Anforderungs Texts sind die nach dem Ende des Anforderungs Texts verfügbar.

Dies bewirkt einige Bedenken bezüglich der Mehrdeutigkeit zwischen Headern und nach Spann, sodass die Nachspann in 3,0 in eine neue Sammlung (`RequestTrailerExtensions`) verschoben wurden.

HTTP/2-Anforderungs Nachspann:

* Nicht verfügbar in ASP.net Core 2,2.
* Verfügbar in 3,0 als `RequestTrailerExtensions`.

Für den Zugriff auf diese Nachspann sind neue Anforderungs Erweiterungs Methoden vorhanden. Wie bei HTTP/1.1 sind Nachspann verfügbar, nachdem der Anforderungs Text bis zum Ende gelesen wurde.

Für die Version 3,0 stehen die folgenden `RequestTrailerExtensions` Methoden zur Verfügung:

* `GetDeclaredTrailers` &ndash; Ruft den Anforderungs `Trailer` Header ab, der auflistet, welche Nachspann nach dem Text erwartet werden.
* `SupportsTrailers` &ndash; gibt an, ob die Anforderung das Empfangen von nach Spann Headern unter
* `CheckTrailersAvailable` &ndash; überprüft, ob die Anforderung nach spannenden unterstützt und verfügbar ist, um gelesen zu werden. Bei dieser Überprüfung wird nicht davon ausgegangen, dass zum Lesen von nach spannenden Möglicherweise gibt es keine zu lesenden Nachspann, auch wenn `true` von dieser Methode zurückgegeben wird.
* `GetTrailer` &ndash; den angeforderten nachfolgenden Header aus der Antwort abruft. Überprüfen Sie `SupportsTrailers`, bevor Sie `GetTrailer`aufrufen, oder es kann ein <xref:System.NotSupportedException> auftreten, wenn die Anforderung keine nachfolgenden Header unterstützt.

Weitere Informationen finden Sie unter [Put Request Trailers in a separate Collection (dotnet/aspnetcore-#10410)](https://github.com/dotnet/AspNetCore/pull/10410).

### <a name="allowsynchronousio-disabled"></a>Allowsynchronousio deaktiviert

`AllowSynchronousIO` aktiviert oder deaktiviert synchrone e/a-APIs, z. b. `HttpRequest.Body.Read`, `HttpResponse.Body.Write`und `Stream.Flush`. Diese APIs sind eine Quelle der Thread Hungersnot, die zu app-Abstürzen führt. In 3.0 ist `AllowSynchronousIO` standardmäßig deaktiviert. Weitere Informationen finden Sie im Abschnitt "Synchrone e/a" [im Kestrel-Artikel](/aspnet/core/fundamentals/servers/kestrel?view=aspnetcore-3.0#synchronous-io).

Wenn synchrone e/a benötigt wird, kann es aktiviert werden, indem die `AllowSynchronousIO`-Option auf dem verwendeten Server konfiguriert wird (z. b. `ConfigureKestrel`bei Verwendung von Kestrel). Beachten Sie, dass Server (Kestrel, httpsys, Testserver usw.) über eine eigene `AllowSynchronousIO` Option verfügen, die sich nicht auf andere Server auswirkt. Synchrone e/a-Vorgänge können mithilfe der Option `IHttpBodyControlFeature.AllowSynchronousIO` für alle Server auf Anforderungs Basis aktiviert werden:

```csharp
var syncIOFeature = HttpContext.Features.Get<IHttpBodyControlFeature>();

if (syncIOFeature != null)
{
    syncIOFeature.AllowSynchronousIO = true;
}
```

Wenn Sie Probleme mit <xref:System.IO.TextWriter>-Implementierungen oder anderen Streams haben, die synchrone [APIs in verwerfen](/dotnet/standard/garbage-collection/implementing-dispose)aufzurufen, müssen Sie stattdessen die neue <xref:System.IO.Stream.DisposeAsync*>-API aufzurufen.

Weitere Informationen finden Sie unter [[Ankündigung] allowsynchronousio deaktiviert auf allen Servern (dotnet/aspnetcore-#7644)](https://github.com/dotnet/AspNetCore/issues/7644).

### <a name="microsoftaspnetcoreserverkestrelhttps-assembly-removed"></a>Die Assembly "Microsoft. aspnetcore. Server. Kestrel. https" wurde entfernt.

In ASP.net Core 2,1 wurde der Inhalt von " *Microsoft. aspnetcore. Server. Kestrel. HTTPS. dll* " in " *Microsoft. aspnetcore. Server. Kestrel. Core. dll*" verschoben. Dabei handelt es sich um ein nicht Erbrechtes Update mit `TypeForwardedTo` Attributen. Bei 3,0 wurden die leere *Microsoft. aspnetcore. Server. Kestrel. HTTPS. dll* -Assembly und das nuget-Paket entfernt.

Bibliotheken, die auf [Microsoft. aspnetcore. Server. Kestrel. HTTPS](https://www.nuget.org/packages/Microsoft.AspNetCore.Server.Kestrel.Https) verweisen, sollten ASP.net Core Abhängigkeiten auf 2,1 oder höher aktualisieren.

Apps und Bibliotheken, die auf ASP.net Core 2,1 oder höher abzielen, sollten alle direkten Verweise auf das Paket [Microsoft. aspnetcore. Server. Kestrel. HTTPS](https://www.nuget.org/packages/Microsoft.AspNetCore.Server.Kestrel.Https) entfernen.

<a id="jsonnet-support"></a>

## <a name="newtonsoftjson-jsonnet-support"></a>Unterstützung von "newtonsoft. JSON" (JSON.net)

Im Rahmen der Arbeit zur [Verbesserung der ASP.net Core freigegebenen Frameworks](https://blogs.msdn.microsoft.com/webdev/2018/10/29/a-first-look-at-changes-coming-in-asp-net-core-3-0/)wurde " [newtonsoft. JSON" (JSON.net)](https://www.newtonsoft.com/json/help/html/Introduction.htm) aus dem ASP.net Core Shared Framework entfernt.

Das standardmäßige JSON-Serialisierungsprogramm für ASP.net Core ist nun <xref:System.Text.Json>, das neu in .net Core 3,0 ist. Verwenden Sie nach Möglichkeit `System.Text.Json`. Dies ist eine hohe Leistung und erfordert keine zusätzliche Bibliotheks Abhängigkeit. Da `System.Text.Json` jedoch neu ist, fehlen möglicherweise derzeit die Features, die Ihre APP benötigt. Weitere Informationen finden Sie unter [Migrieren von "newtonsoft. JSON" zu "System. Text. JSON](/dotnet/standard/serialization/system-text-json-migrate-from-newtonsoft-how-to)".

### <a name="use-newtonsoftjson-in-an-aspnet-core-30-opno-locsignalr-project"></a>Verwenden von "newtonsoft. JSON" in einem 3,0 ASP.net Core SignalR-Projekt

* Installieren Sie [Microsoft.aspnetcore.SignalR.Das nuget-Paket "Protokolls. newtonsoft JSON](https://www.nuget.org/packages/Microsoft.AspNetCore.SignalR.Protocols.NewtonsoftJson) ".

* Verketten Sie auf dem Client einen `AddNewtonsoftJsonProtocol` Methodenaufrufe an die `HubConnectionBuilder` Instanz:

  ```csharp
  new HubConnectionBuilder()
      .WithUrl("/chatHub")
      .AddNewtonsoftJsonProtocol(...)
      .Build();
  ```

* Verketten Sie auf dem-Server einen `AddNewtonsoftJsonProtocol` Methodenaufrufe des `AddSignalR`-Methoden Aufrufes in `Startup.ConfigureServices`:

  ```csharp
  services.AddSignalR()
      .AddNewtonsoftJsonProtocol(...);
  ```

### <a name="use-newtonsoftjson-in-an-aspnet-core-30-mvc-project"></a>Verwenden von "newtonsoft. JSON" in einem ASP.net Core 3,0-MVC-Projekt

* Installieren Sie das Paket [Microsoft. aspnetcore. MVC. newtonsoft JSON](https://nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson) .

* Aktualisieren Sie `Startup.ConfigureServices`, um `AddNewtonsoftJson`aufzurufen.

  ```csharp
  services.AddMvc()
      .AddNewtonsoftJson();
  ```

  `AddNewtonsoftJson` ist mit den neuen Registrierungsmethoden für den MVC-Dienst kompatibel:

  * `AddRazorPages`
  * `AddControllersWithViews`
  * `AddControllers`

  ```csharp
  services.AddControllers()
      .AddNewtonsoftJson();
  ```

  `Newtonsoft.Json` Einstellungen können im `AddNewtonsoftJson`aufgerufen werden:

  ```csharp
  services.AddMvc()
      .AddNewtonsoftJson(options =>
             options.SerializerSettings.ContractResolver =
                new CamelCasePropertyNamesContractResolver());
  ```

**Hinweis:** Wenn die `AddNewtonsoftJson`-Methode nicht verfügbar ist, stellen Sie sicher, dass Sie das Paket [Microsoft. aspnetcore. MVC. newtonsoftware](https://nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson) installiert haben. Ein häufiger Fehler ist die Installation des Pakets " [newtonsoft. JSON](https://www.nuget.org/packages/Newtonsoft.Json/) " anstelle des Pakets " [Microsoft. aspnetcore. MVC. newtonsoftjson](https://nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson) ".

## <a name="mvc-service-registration"></a>MVC-Dienst Registrierung

In ASP.NET Core 3.0 werden neue Optionen zum Registrieren von MVC-Szenarios in `Startup.ConfigureServices` hinzugefügt.

Drei neue Erweiterungs Methoden auf oberster Ebene, die sich auf MVC-Szenarien auf `IServiceCollection` beziehen, sind verfügbar. Vorlagen verwenden diese neuen Methoden anstelle von `AddMvc`. `AddMvc` Verhalten sich jedoch weiterhin wie in früheren Versionen.

Im folgenden Beispiel wird die Unterstützung für Controller und API-Funktionen hinzugefügt, jedoch keine Sichten oder Seiten. Die API-Vorlage verwendet diesen Code:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllers();
}
```

Im folgenden Beispiel werden die Unterstützung für Controller, API-bezogene Features und Sichten, aber keine Seiten hinzugefügt. Die Vorlage Webanwendung (MVC) verwendet folgenden Code:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllersWithViews();
}
```

Im folgenden Beispiel wird Unterstützung für Razor Pages und minimale Controller Unterstützung hinzugefügt. Die Webanwendungsvorlage verwendet diesen Code:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddRazorPages();
}
```

Die neuen Methoden können ebenfalls kombiniert werden. Das folgende Beispiel entspricht dem Aufrufen von `AddMvc` in ASP.NET Core 2.2:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllersWithViews();
    services.AddRazorPages();
}
```

## <a name="routing-startup-code"></a>Routing Startcode

Wenn eine App UseMvc oder UseSignalR aufruft, migrieren Sie die App wenn möglich zum Endpunktrouting. Zur Verbesserung der Endpunktroutingkompatibilität mit vorherigen MVC-Versionen wurden einige Änderungen erneut bei der URL-Generierung in ASP.NET Core 2.2 eingeführt. Wenn Sie Probleme mit dem Endpunktrouting in Version 2.2 haben, können Sie sich auf Verbesserungen in ASP.NET Core 3.0 freuen. Es gelten dabei folgende Ausnahmen:

* Wenn die APP `IRouter` implementiert oder von `Route`erbt, verwenden Sie [dynamicroutevaluestransex](https://github.com/dotnet/AspNetCore.Docs/issues/12997) als Ersatz.

* Wenn die APP direkt auf `RouteData.Routers` in MVC zugreift, um URLs zu analysieren, können Sie dies durch `LinkParser.ParsePathByEndpointName`ersetzen. 
 * Hiermit wird die Route mit einem Routennamen definiert.
 * Verwenden Sie `LinkParser.ParsePathByEndpointName`, und übergeben Sie den gewünschten Routennamen.

Das Endpunkt Routing unterstützt die gleiche Routing Muster Syntax und die Funktionen zum Erstellen von Routen Mustern wie `IRouter`. Das Endpunkt Routing unterstützt `IRouteConstraint`. Das Endpunkt Routing unterstützt `[Route]`, `[HttpGet]`und die anderen MVC-Routing Attribute.

Bei den meisten Anwendungen müssen nur `Startup` Änderungen vornehmen.

### <a name="migrate-startupconfigure"></a>"Startup. configure" Migrieren

Allgemeine Hinweise:

* Fügen Sie `UseRouting`hinzu.
* Wenn die APP `UseStaticFiles`aufruft, platzieren Sie `UseStaticFiles` **vor** `UseRouting`.
* Wenn die APP Authentifizierungs-/Autorisierungsfeatures wie `AuthorizePage` oder `[Authorize]`verwendet, platzieren Sie den-Befehl `UseAuthentication` und `UseAuthorization`: **after**, `UseRouting` und `UseCors`, aber vor `UseEndpoints`:

  ```csharp
  public void Configure(IApplicationBuilder app)
  {
    ...

    app.UseStaticFiles();

    app.UseRouting();
    app.UseCors();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints => {
       endpoints.MapControllers();
    });
  ```

* Ersetzen Sie `UseMvc` oder `UseSignalR` durch `UseEndpoints`.
* Wenn die APP [cors](xref:security/cors) -Szenarien verwendet, wie z. b. `[EnableCors]`, platzieren Sie den `UseCors` vor allen anderen Middleware, die cors verwenden (z. b. platzieren `UseCors` vor `UseAuthentication`, `UseAuthorization`und `UseEndpoints`).
* Ersetzen Sie `IHostingEnvironment` durch `IWebHostEnvironment`, und fügen Sie eine `using`-Anweisung für den <xref:Microsoft.Extensions.Hosting?displayProperty=fullName>-Namespace hinzu.
* Ersetzen Sie `IApplicationLifetime` durch <xref:Microsoft.Extensions.Hosting.IHostApplicationLifetime> (<xref:Microsoft.Extensions.Hosting?displayProperty=fullName> Namespace).
* Ersetzen Sie `EnvironmentName` durch <xref:Microsoft.Extensions.Hosting.Environments> (<xref:Microsoft.Extensions.Hosting?displayProperty=fullName> Namespace).

Der folgende Code ist ein Beispiel für `Startup.Configure` in einer typischen ASP.net Core 2,2-App:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseStaticFiles();

    app.UseAuthentication();

    app.UseSignalR(hubs =>
    {
        hubs.MapHub<ChatHub>("/chat");
    });

    app.UseMvc(routes =>
    {
        routes.MapRoute("default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

Nach dem Aktualisieren des vorherigen `Startup.Configure` Codes:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseStaticFiles();

    app.UseRouting();

    app.UseCors();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>("/chat");
        endpoints.MapControllerRoute("default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

> [!WARNING]
> Bei den meisten apps müssen Aufrufe von `UseAuthentication`, `UseAuthorization`und `UseCors` zwischen den Aufrufen von `UseRouting` und `UseEndpoints` werden, damit Sie wirksam werden.

### <a name="health-checks"></a>Integritätsprüfungen

Integritätsprüfungen verwenden das Endpunktrouting mit dem generischen Host. Rufen Sie in `Startup.Configure` auf der Endpunkterstellung mit der Endpunkt-URL oder dem relativen Pfad `MapHealthChecks` auf:

```csharp
app.UseEndpoints(endpoints =>
{
    endpoints.MapHealthChecks("/health");
});
```

Für Endpunkte für Integritätsprüfungen gilt Folgendes:

* Sie geben mindestens einen zugelassenen Host oder Port an.
* Sie erfordern Autorisierung.
* Sie erfordern CORS.

Weitere Informationen finden Sie unter <xref:host-and-deploy/health-checks>.

### <a name="security-middleware-guidance"></a>Leitfaden zur Sicherheit von Middleware

Unterstützung für die Autorisierung und cors ist in Bezug auf den [Middleware](xref:fundamentals/middleware/index) -Ansatz einheitlich. Dies ermöglicht die Verwendung derselben Middleware und derselben Funktionalität in diesen Szenarien. In dieser Version wird eine aktualisierte Autorisierungs Middleware bereitgestellt, und die cors-Middleware wird verbessert, sodass Sie die von MVC-Controllern verwendeten Attribute verstehen kann.

#### <a name="cors"></a>CORS

Zuvor war es möglicherweise schwierig, CORS zu konfigurieren. Die Middleware wurde für einige Anwendungsfälle bereitgestellt, aber MVC-Filter waren in anderen Anwendungsfällen ohne die Middleware vorgesehen. Bei ASP.NET Core 3.0 wird empfohlen, dass alle Apps, die CORS benötigen, die CORS-Middleware zusammen mit dem Endpunktrouting verwenden. `UseCors`kann mit einer Standardrichtlinie angegeben werden, und die Attribute `[EnableCors]` und `[DisableCors]` können verwendet werden, um die Standardrichtlinie ggf. zu überschreiben.

Im folgenden Beispiel:

* Cors ist für alle Endpunkte mit der `default` benannten Richtlinie aktiviert.
* Die `MyController`-Klasse deaktiviert cors mit dem `[DisableCors]`-Attribut.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseCors("default");

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

[DisableCors]
public class MyController : ControllerBase
{
    ...
}
```

#### <a name="authorization"></a>Autorisierung

In früheren Versionen von ASP.NET Core wurde die Unterstützung für die Autorisierung über das Attribut `[Authorize]` bereitgestellt. Die Autorisierungsmiddleware war nicht verfügbar. In ASP.NET Core 3.0 ist die Autorisierungsmiddleware erforderlich. Es wird empfohlen, die ASP.NET Core-Autorisierungsmiddleware (`UseAuthorization`) direkt nach `UseAuthentication` zu platzieren. Die Middleware für die Autorisierung kann auch mit einer Standardrichtlinie konfiguriert werden, die überschrieben werden kann.

In ASP.NET Core 3.0 oder höher wird `UseAuthorization` in `Startup.Configure`aufgerufen, und für folgende `HomeController`-Klasse ist ein angemeldeter Benutzer erforderlich:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

public class HomeController : Controller
{
    [Authorize]
    public IActionResult BuyWidgets()
    {
        ...
    }
}
```

Wenn Sie das Endpunkt Routing verwenden, wird empfohlen, `<xref:Microsoft.AspNetCore.Mvc.Authorization.AuthorizeFilter>` zu konfigurieren und stattdessen die Autorisierungs Middleware zu verwenden.  Wenn die APP eine `AuthorizeFilter` als globaler Filter in MVC verwendet, empfiehlt es sich, den Code so zu umgestalten, dass eine Richtlinie im `AddAuthorization`aufgerufen wird.

Der `DefaultPolicy` ist anfänglich so konfiguriert, dass eine Authentifizierung erforderlich ist, sodass keine zusätzliche Konfiguration erforderlich ist. Im folgenden Beispiel werden MVC-Endpunkte als `RequireAuthorization` gekennzeichnet, sodass alle Anforderungen auf der Grundlage der `DefaultPolicy`autorisiert werden müssen. Der `HomeController` ermöglicht jedoch den Zugriff, ohne dass sich der Benutzer aufgrund `[AllowAnonymous]`an der App anmeldet:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute().RequireAuthorization();
    });
}

[AllowAnonymous]
public class HomeController : Controller
{
    ...
}
```

### <a name="authorization-for-specific-endpoints"></a>Autorisierung für bestimmte Endpunkte

Die Autorisierung kann auch für bestimmte Klassen von Endpunkten konfiguriert werden. Der folgende Code ist ein Beispiel für die Umstellung einer MVC-APP, die eine globale `AuthorizeFilter` konfiguriert hat, in eine APP mit einer bestimmten Richtlinie, die eine Autorisierung erfordert

[!code-csharp[](22-to-30/samples/Startup.cs?name=snippet&highlight=8-9,21-22,26-27,53-54)]

Richtlinien können auch angepasst werden. Der `DefaultPolicy` ist so konfiguriert, dass eine Authentifizierung erforderlich ist:

[!code-csharp[](22-to-30/samples/Startup2.cs?name=snippet&highlight=21-26,52)]

[!code-csharp[](22-to-30/samples/HomeController.cs?name=snippet)]

Alternativ können alle Endpunkte so konfiguriert werden, dass eine Autorisierung ohne `[Authorize]` oder `RequireAuthorization` erforderlich ist, indem ein `FallbackPolicy`konfiguriert wird. Der `FallbackPolicy` unterscheidet sich vom `DefaultPolicy`. Die `DefaultPolicy` wird durch `[Authorize]` oder `RequireAuthorization`ausgelöst, während die `FallbackPolicy` ausgelöst wird, wenn keine andere Richtlinie festgelegt ist. `FallbackPolicy` ist anfänglich so konfiguriert, dass Anforderungen ohne Autorisierung zugelassen werden.

Das folgende Beispiel ist identisch mit dem vorangehenden `DefaultPolicy` Beispiel, verwendet jedoch die `FallbackPolicy`, um immer eine Authentifizierung für alle Endpunkte anzufordern, außer wenn `[AllowAnonymous]` angegeben ist:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    ...

    services.AddAuthorization(options =>
    {
        options.FallbackPolicy = new AuthorizationPolicyBuilder()
          .RequireAuthenticatedUser()
          .Build();
    });
}

public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

[AllowAnonymous]
public class HomeController : Controller
{
    ...
}
```

Die Autorisierung durch Middleware funktioniert, ohne dass das Framework über bestimmte Kenntnisse der Autorisierung verfügt. Integritäts [Prüfungen](xref:host-and-deploy/health-checks) haben beispielsweise keine spezifischen Kenntnisse der Autorisierung, aber Integritätsprüfungen können eine konfigurierbare Autorisierungs Richtlinie aufweisen, die von der Middleware angewendet wird.

Außerdem kann jeder Endpunkt seine Autorisierungs Anforderungen anpassen. Im folgenden Beispiel wird die Autorisierung mit dem `DefaultPolicy``UseAuthorization` verarbeitet, aber der Endpunkt der `/healthz` Integritätsprüfung erfordert einen `admin` Benutzer:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints
            .MapHealthChecks("/healthz")
            .RequireAuthorization(new AuthorizeAttribute(){ Roles = "admin", });
    });
}
```

Der Schutz wird für einige Szenarien implementiert. Die Middleware für Endpunkte löst eine Ausnahme aus, wenn eine Autorisierungs-oder cors-Richtlinie aufgrund fehlender Middleware übersprungen wird. Analyse Unterstützung, um zusätzliches Feedback zur Fehlkonfiguration bereitzustellen.

#### <a name="custom-authorization-handlers"></a>Benutzerdefinierte Autorisierungs Handler

Wenn die APP benutzerdefinierte [Autorisierungs Handler](xref:security/authorization/policies#authorization-handlers)verwendet, übergibt das Endpunkt Routing einen anderen Ressourcentyp an Handler als MVC. Handler, die erwarten, dass die Kontext Ressource des Autorisierungs Handler vom Typ <xref:Microsoft.AspNetCore.Mvc.Filters.AuthorizationFilterContext> ist (der Ressourcentyp, der [von MVC-Filtern bereitgestellt](xref:security/authorization/policies#accessing-mvc-request-context-in-handlers)wird), muss aktualisiert werden, um Ressourcen vom Typ <xref:Microsoft.AspNetCore.Routing.RouteEndpoint> zu verarbeiten (der Ressourcentyp, der den Autorisierungs Handlern durch das Endpunkt Routing

Da MVC weiterhin `AuthorizationFilterContext` Ressourcen verwendet, ist es möglicherweise erforderlich, beide Arten von Ressourcen zu verarbeiten, wenn die APP MVC-Autorisierungs Filter zusammen mit der Endpunkt Weiterleitungs Autorisierung verwendet.

### SignalR

Die Zuordnung von SignalR Hubs erfolgt nun in `UseEndpoints`.

Ordnen Sie jeden Hub `MapHub`zu. Wie in früheren Versionen wird jeder Hub explizit aufgelistet.

Im folgenden Beispiel wird die Unterstützung für den `ChatHub` SignalR Hub hinzugefügt:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>();
    });
}
```

Es gibt eine neue Option zum Steuern von Größenbeschränkungen für Nachrichten von Clients. Gehen Sie beispielsweise in `Startup.ConfigureServices` folgendermaßen vor:

```csharp
services.AddSignalR(hubOptions =>
{
    hubOptions.MaximumReceiveMessageSize = 32768;
});
```

In ASP.net Core 2.2 konnten Sie die `TransportMaxBufferSize` festlegen, wodurch die maximale Nachrichtengröße effektiv gesteuert werden kann. In ASP.NET Core 3.0 steuert diese Option jetzt nur die maximale Größe, bevor der Rückstau festgestellt wird.

### <a name="mvc-controllers"></a>MVC-Controller

Die Zuordnung von Controllern findet nun in `UseEndpoints`statt.

Fügen Sie `MapControllers` hinzu, wenn die App Attributrouting verwendet. Da das Routing Unterstützung für viele Frameworks in ASP.NET Core 3.0 oder höher bietet, ist das Hinzufügen von Controllern mit Attributrouting eine Option.

Ersetzen Sie die folgenden Werte:

* `MapRoute` mit `MapControllerRoute`
* `MapAreaRoute` mit `MapAreaControllerRoute`

Da das Routing nun die Unterstützung für mehr als nur MVC umfasst, hat sich die Terminologie geändert, damit diese Methoden deutlich erkennen können, was Sie tun. Herkömmliche Routen wie `MapControllerRoute`/`MapAreaControllerRoute`/`MapDefaultControllerRoute` werden in der Reihenfolge angewendet, in der Sie hinzugefügt werden. Platzieren Sie zunächst spezifischere Routen (z. b. Routen für einen Bereich).

Im folgenden Beispiel:

* `MapControllers` fügt Unterstützung für Attribut Weiterleitungs Controller hinzu.
* `MapAreaControllerRoute` fügt eine konventionelle Route für Controller in einem Bereich hinzu.
* `MapControllerRoute` fügt eine konventionelle Route für Controller hinzu.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapControllers();
        endpoints.MapAreaControllerRoute(
            "admin",
            "admin",
            "Admin/{controller=Home}/{action=Index}/{id?}");
        endpoints.MapControllerRoute(
            "default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

#### <a name="async-suffix-removal-from-controller-action-names"></a>Asynchrones Suffix aus Controller-Aktions Namen entfernen

In ASP.net Core 3,0 entfernt ASP.net Core MVC das `Async`-Suffix aus den Controller Aktions Namen. Das Routing und die Verknüpfungs Generierung sind von dieser neuen Standardeinstellung betroffen. Beispiel:

```csharp
public class ProductsController : Controller
{
    public async Task<IActionResult> ListAsync()
    {
        var model = await _dbContext.Products.ToListAsync();
        return View(model);
    }
}
```

Vor ASP.net Core 3,0:

* Auf die vorherige Aktion kann auf der Route " *Products/listasync* " zugegriffen werden.
* Die Link Generierung erforderte die Angabe des `Async` Suffix. Beispiel:

    ```cshtml
    <a asp-controller="Products" asp-action="ListAsync">List</a>
    ```

In ASP.net Core 3,0:

* Auf die vorangehende Aktion kann auf der Route " *Products/List* " zugegriffen werden.
* Bei der Link Generierung muss das `Async` Suffix nicht angegeben werden. Beispiel:

    ```cshtml
    <a asp-controller="Products" asp-action="List">List</a>
    ```

Diese Änderung hat keine Auswirkungen auf die Namen, die mit dem [`[ActionName]`](/dotnet/api/microsoft.aspnetcore.mvc.actionnameattribute) -Attribut angegeben Das Standardverhalten kann mit dem folgenden Code in `Startup.ConfigureServices`deaktiviert werden:

```csharp
services.AddMvc(options =>
    options.SuppressAsyncSuffixInActionNames = false);
```

#### <a name="changes-to-link-generation"></a>Änderungen an der Link Generierung

Wie in der Dokumentation zu den [unterschieden aus früheren Versionen des Routings](xref:fundamentals/routing#differences-from-earlier-versions-of-routing)erläutert, gibt es einige Unterschiede bei der Link Generierung (z. b. mit `Url.Link` und ähnlichen APIs). Dazu gehören:

* Wenn Sie das Endpunkt Routing verwenden, wird die Groß-/Kleinschreibung von Routen Parametern in generierten URIs standardmäßig nicht zwangsläufig beibehalten. Dieses Verhalten kann mit der `IOutboundParameterTransformer`-Schnittstelle gesteuert werden.
* Wenn Sie einen URI für eine ungültige Route generieren (ein Controller, eine Aktion oder eine Seite, die nicht vorhanden ist), wird unter Endpunkt Routing eine leere Zeichenfolge erstellt, anstatt einen ungültigen URI zu erzeugen.
* Ambient-Werte (Routen Parameter aus dem aktuellen Kontext) werden bei der Link Generierung mit dem Endpunkt Routing nicht automatisch verwendet. Zuvor wurden bei der Erstellung eines Links zu einer anderen Aktion (oder Seite) nicht angegebene Routen Werte von den *aktuellen* Routen Werten abgeleitet. Bei Verwendung des Endpunkt Routings müssen alle Routen Parameter während der Link Generierung explizit angegeben werden.

### <a name="razor-pages"></a>Razor Pages

Die Zuordnung Razor Pages jetzt in `UseEndpoints`stattfinden.

Fügen Sie `MapRazorPages` hinzu, wenn die APP Razor Pages verwendet. Da das Endpunkt Routing Unterstützung für viele Frameworks umfasst, ist das Hinzufügen von Razor Pages jetzt deaktiviert.

In der folgenden `Startup.Configure` Methode fügt `MapRazorPages` Unterstützung für Razor Pages hinzu:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapRazorPages();
    });
}
```

### <a name="use-mvc-without-endpoint-routing"></a>Verwenden von MVC ohne Endpunkt Routing

Die Verwendung von MVC über`UseMvc` oder`UseMvcWithDefaultRoute` in ASP.NET Core 3.0 erfordert ein explizites Opt-in in `Startup.ConfigureServices`. Dies ist erforderlich, da MVC wissen muss, ob während der Initialisierung auf die Autorisierung und die CORS-Middleware zurückgegriffen werden kann. Es wird ein Analyzer bereitgestellt, der warnt, wenn die App versucht, eine nicht unterstützte Konfiguration zu verwenden.

Wenn für die APP Legacy `IRouter` Unterstützung erforderlich ist, deaktivieren Sie `EnableEndpointRouting` mithilfe der folgenden Vorgehensweisen in `Startup.ConfigureServices`:

```csharp
services.AddMvc(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddControllers(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddControllersWithViews(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddRazorPages().AddMvcOptions(options => options.EnableEndpointRouting = false);
```

### <a name="health-checks"></a>Integritätsprüfungen

Integritätsprüfungen können als *routerware* mit Endpunkt Routing verwendet werden.

Fügen Sie `MapHealthChecks` hinzu, um Integritätsprüfungen mit Endpunkt Routing zu verwenden. Die `MapHealthChecks`-Methode akzeptiert Argumente ähnlich `UseHealthChecks`. Der Vorteil der Verwendung von `MapHealthChecks` über `UseHealthChecks` ist die Fähigkeit, Autorisierung anzuwenden und eine präzisere Kontrolle über die abgleichsrichtlinie zu haben.

Im folgenden Beispiel wird `MapHealthChecks` für einen Integritäts Prüf Punkt bei `/healthz`aufgerufen:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHealthChecks("/healthz", new HealthCheckOptions() { });
    });
}
```

## <a name="hostbuilder-replaces-webhostbuilder"></a>Der hostbuilder ersetzt webhostbuilder.

Die ASP.NET Core 3.0-Vorlagen verwenden den [generischen Host](xref:fundamentals/host/generic-host). In früheren Versionen wurde der [Webhost](xref:fundamentals/host/web-host) verwendet. Der folgende Code zeigt die von der ASP.NET Core 3.0 generierte `Program`-Klasse:

[!code-csharp[](22-to-30/samples/Program.cs?name=snippet)]

Der folgende Code zeigt die von der Vorlage generierte `Program`-Klasse für ASP.NET Core 2.2:

[!code-csharp[](22-to-30/samples/Program2.2.cs?name=snippet)]

<xref:Microsoft.AspNetCore.Hosting.IWebHostBuilder> verbleibt in Version 3.0 und ist der Typ von `webBuilder`, der im vorangehenden Codebeispiel dargestellt ist. <xref:Microsoft.AspNetCore.Hosting.WebHostBuilder> wird in einer zukünftigen Version als veraltet markiert und durch `HostBuilder`ersetzt.

Die signifikanteste Änderung von `WebHostBuilder` in `HostBuilder` ist die [Abhängigkeitsinjektion (di)](xref:fundamentals/dependency-injection). Wenn Sie `HostBuilder`verwenden, können Sie nur Folgendes in `Startup`Konstruktor einfügen:

* <xref:Microsoft.Extensions.Configuration.IConfiguration>
* <xref:Microsoft.Extensions.Hosting.IHostEnvironment>
* <xref:Microsoft.AspNetCore.Hosting.IWebHostEnvironment>

Die `HostBuilder` di-Einschränkungen:

* Aktivieren Sie den di-Container nur ein einziges Mal.
* Vermeidet die resultierenden Probleme bei der Objekt Lebensdauer wie das Auflösen mehrerer Instanzen von Singletons.

Weitere Informationen finden Sie unter [vermeiden der Start Dienst Injektion in ASP.net Core 3](https://andrewlock.net/avoiding-startup-service-injection-in-asp-net-core-3/).

## <a name="addauthorization-moved-to-a-different-assembly"></a>Addauthorization in eine andere Assembly verschoben

Die `AddAuthorization`-Methoden für ASP.NET 2.2 und niedriger in *Microsoft.AspNetCore.Authorization.dll*:

* Wurden umbenannt `AddAuthorizationCore`.
* Wurden in " *Microsoft. aspnetcore. Authorization. Policy. dll*" verschoben.

Apps, die sowohl *Microsoft. aspnetcore. Authorization. dll* als auch *Microsoft. aspnetcore. Authorization. Policy. dll* verwenden, sind nicht betroffen.

Apps, die nicht *Microsoft. aspnetcore. Authorization. Policy. dll* verwenden, sollten eine der folgenden Aktionen ausführen:

* Fügen Sie einen Verweis auf *Microsoft. aspnetcore. Authorization. Policy. dll*hinzu. Diese Vorgehensweise funktioniert für die meisten apps und ist alles, was erforderlich ist.
* Wechseln Sie zu `AddAuthorizationCore`

Weitere Informationen finden Sie unter [Breaking Change in `AddAuthorization(o =>`) Überlastung in einer anderen Assembly #386](https://github.com/aspnet/Announcements/issues/386).

## <a name="identity-ui"></a>Identitäts Benutzeroberfläche

Identity UI Updates for ASP.net Core 3,0:

* Fügen Sie einen Paket Verweis auf [Microsoft. aspnetcore. Identity. UI](https://nuget.org/packages/Microsoft.AspNetCore.Identity.UI)hinzu.
* Apps, die Razor Pages nicht verwenden, müssen `MapRazorPages`aufgerufen werden. Weitere Informationen finden Sie unter [Razor Pages](#razor-pages) in diesem Dokument.
* Bootstrap 4 ist das Standard Framework für die Benutzeroberfläche. Legen Sie eine `IdentityUIFrameworkVersion` Projekt Eigenschaft fest, um die Standardeinstellung zu ändern. Weitere Informationen finden Sie in [dieser GitHub-Ankündigung](https://github.com/aspnet/Announcements/issues/380).

## SignalR

Der SignalR JavaScript-Client wurde von `@aspnet/signalr` in `@microsoft/signalr`geändert. Um auf diese Änderung zu reagieren, ändern Sie die Verweise in den Dateien " *Package. JSON* ", "`require`-Anweisungen" und "ECMAScript `import`".

### <a name="systemtextjson-is-the-default-protocol"></a>"System. Text. JSON" ist das Standardprotokoll.

`System.Text.Json` ist nun das Standardhub Protokoll, das sowohl vom Client als auch vom Server verwendet wird.

`AddJsonProtocol` in `Startup.ConfigureServices`die Optionen für Serialisierungsprogramme.

**Servers**

```csharp
services.AddSignalR(...)
        .AddJsonProtocol(options =>
        {
            options.PayloadSerializerOptions.WriteIndented = false;
        })
```

**Client:**

```csharp
new HubConnectionBuilder()
    .WithUrl("/chatHub")
    .AddJsonProtocol(options =>
    {
        options.PayloadSerializerOptions.WriteIndented = false;
    })
    .Build();
```

### <a name="switch-to-newtonsoftjson"></a>Wechseln Sie zu "newtonsoft. JSON".

Wenn Sie [die Funktionen von "newtonsoft. JSON" verwenden, die in "System. Text. JSON" nicht unterstützt](/dotnet/standard/serialization/system-text-json-migrate-from-newtonsoft-how-to)werden, können Sie zu `Newtonsoft.Json`zurück wechseln. Weitere Informationen finden Sie weiter oben in diesem Artikel [unter Verwenden von "newtonsoft. JSON" in einem ASP.net Core 3,0 SignalR Projekt](#use-newtonsoftjson-in-an-aspnet-core-30-signalr-project) .

## <a name="opt-in-to-runtime-compilation"></a>Abonnieren der Lauf Zeit Kompilierung

Vor ASP.net Core 3,0 war die Lauf Zeit Kompilierung von Sichten eine implizite Funktion des Frameworks. Die Lauf Zeit Kompilierung ergänzt die Kompilierung der Erstellung von Sichten. Sie ermöglicht es dem Framework, Razor-Ansichten und-Seiten (*cshtml* -Dateien) zu kompilieren, wenn die Dateien geändert werden, ohne die gesamte APP neu erstellen zu müssen. Diese Funktion unterstützt das Szenario der schnellen Bearbeitung in der IDE und das Aktualisieren des Browsers, um die Änderungen anzuzeigen.

In ASP.net Core 3,0 ist die Lauf Zeit Kompilierung ein Opt-in-Szenario. Die Kompilierzeit Kompilierung ist der einzige Mechanismus zum Anzeigen der Kompilierung, der standardmäßig aktiviert ist. Die Laufzeit basiert auf Visual Studio oder [dotnet-Watch](xref:tutorials/dotnet-watch) in Visual Studio Code, um das Projekt neu zu erstellen, wenn Änderungen an *cshtml* -Dateien erkannt werden. In Visual Studio werden Änderungen an *den CS*- *, cshtml*-oder *Razor* -Dateien im Projekt, das ausgeführt wird (<kbd>STRG + F5</kbd>), aber nicht debuggt (<kbd>F5</kbd>), die Neukompilierung des Projekts auslöst.

So aktivieren Sie die Lauf Zeit Kompilierung in Ihrem ASP.net Core 3,0-Projekt:

1. das NuGet-Paket [Microsoft.AspNetCore.Mvc.Razor.RuntimeCompilation](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Razor.RuntimeCompilation) installieren.
1. Aktualisieren Sie `Startup.ConfigureServices`, um `AddRazorRuntimeCompilation`aufzurufen:

    Verwenden Sie für ASP.net Core MVC den folgenden Code:

    ```csharp
    services.AddControllersWithViews()
        .AddRazorRuntimeCompilation(...);
    ```
 
    Verwenden Sie für ASP.net Core Razor Pages den folgenden Code:
 
    ```csharp
    services.AddRazorPages()
        .AddRazorRuntimeCompilation(...);
    ```
 
Das Beispiel unter https://github.com/aspnet/samples/tree/master/samples/aspnetcore/mvc/runtimecompilation zeigt ein Beispiel für die bedingte Aktivierung der Lauf Zeit Kompilierung in Entwicklungsumgebungen.

Weitere Informationen zur Kompilierung von Razor-Dateien finden Sie unter <xref:mvc/views/view-compilation>.

## <a name="migrate-libraries-via-multi-targeting"></a>Migrieren von Bibliotheken mithilfe der Zielplattform

Bibliotheken müssen häufig mehrere Versionen von ASP.net Core unterstützen. Die meisten Bibliotheken, die für frühere Versionen von ASP.net Core kompiliert wurden, sollten ohne Probleme weiterhin funktionieren. Die folgenden Bedingungen erfordern eine Kreuz Kompilierung der APP:

* Die Bibliothek basiert auf einer Funktion, die über eine binäre [Breaking Change](#breaking-api-changes)verfügt.
* Die Bibliothek möchte die neuen Features in ASP.net Core 3,0 nutzen. 

Beispiel:

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFrameworks>netcoreapp3.0;netstandard2.0</TargetFrameworks>
  </PropertyGroup>

  <ItemGroup Condition="'$(TargetFramework)' == 'netcoreapp3.0'">
    <FrameworkReference Include="Microsoft.AspNetCore.App" />
  </ItemGroup>

  <ItemGroup Condition="'$(TargetFramework)' == 'netstandard2.0'">
    <PackageReference Include="Microsoft.AspNetCore" Version="2.1.0" />
  </ItemGroup>
</Project>
```

Verwenden Sie `#ifdefs`, um ASP.net Core 3,0-spezifische APIs zu aktivieren:

```csharp
var webRootFileProvider =
#if NETCOREAPP3_0
    GetRequiredService<IWebHostEnvironment>().WebRootFileProvider;
#elif NETSTANDARD2_0
    GetRequiredService<IHostingEnvironment>().WebRootFileProvider;
#else
#error unknown target framework
#endif
```

Weitere Informationen zum Verwenden von ASP.net Core-APIs in einer Klassenbibliothek finden Sie unter <xref:fundamentals/target-aspnetcore>.

### <a name="publish"></a>Veröffentlichungs

Löschen Sie die Ordner " *bin* " und " *obj* " im Projektverzeichnis.

## <a name="testserver"></a>TestServer

Erstellen Sie für apps, die <xref:Microsoft.AspNetCore.TestHost.TestServer> direkt mit dem [generischen Host](xref:fundamentals/host/web-host)verwenden, die `TestServer` auf einem <xref:Microsoft.AspNetCore.Hosting.IWebHostBuilder> in <xref:Microsoft.Extensions.Hosting.GenericHostWebHostBuilderExtensions.ConfigureWebHost%2A>:

```csharp
[Fact]
public async Task GenericCreateAndStartHost_GetTestServer()
{
    using var host = await new HostBuilder()
        .ConfigureWebHost(webBuilder =>
        {
            webBuilder
                .UseTestServer()
                .Configure(app => { });
        })
    .StartAsync();

    var response = await host.GetTestServer().CreateClient().GetAsync("/");

    Assert.Equal(HttpStatusCode.NotFound, response.StatusCode);
}
```

<a name="break"></a>

## <a name="breaking-api-changes"></a>Wichtige API-Änderungen

Wichtige Änderungen überprüfen:

* [Umfassende Liste der wichtigen Änderungen in der Version ASP.net Core 3,0](https://github.com/aspnet/Announcements/issues?page=1&q=is%3Aissue+is%3Aopen+label%3A%22Breaking+change%22+label%3A3.0.0)
* [Unterbrechen von API-Änderungen in Antifälschung, cors, Diagnose, MVC und Routing](https://github.com/aspnet/Announcements/issues/387). Diese Liste enthält Breaking Changes für Kompatibilitätsoptionen.
* Eine Zusammenfassung 2,2-zu-3,0-Änderungen in .net Core, ASP.net Core und Entity Framework Core finden Sie unter [Breaking Changes for Migration from Version 2,2 to 3,0](/dotnet/core/compatibility/2.2-3.0).

## <a name="net-core-30-on-azure-app-service"></a>.Net Core 3,0 auf Azure App Service

Informationen zum Fortschritt beim Rollout von .net Core auf Azure App Service finden Sie auf der offiziellen Website [von .net Core auf App Service](https://aspnetcoreon.azurewebsites.net/) . Bis .net Core 3,0 auf Azure App Service verfügbar ist, befolgen Sie die Anweisungen unter Bereitstellen [ASP.net Core Vorschauversion Azure App Service](xref:host-and-deploy/azure-apps/index#deploy-aspnet-core-preview-release-to-azure-app-service).
