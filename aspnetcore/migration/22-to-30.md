---
title: Migrieren von ASP.net Core 2,2 zu 3,0
author: rick-anderson
description: Erfahren Sie, wie Sie ein ASP.net Core 2,2-Projekt zu ASP.net Core 3,0 migrieren.
ms.author: riande
ms.custom: mvc
ms.date: 10/15/2019
uid: migration/22-to-30
ms.openlocfilehash: 89f9f86cf0550c84ed51e7f36c7bc76a4623e7ae
ms.sourcegitcommit: dd026eceee79e943bd6b4a37b144803b50617583
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 10/15/2019
ms.locfileid: "72378789"
---
# <a name="migrate-from-aspnet-core-22-to-30"></a>Migrieren von ASP.net Core 2,2 zu 3,0

Von [Scott Adder](https://github.com/scottaddie) und [Rick Anderson](https://twitter.com/RickAndMSFT)

In diesem Artikel wird erläutert, wie ein vorhandenes ASP.net Core 2,2-Projekt auf ASP.net Core 3,0 aktualisiert wird.

## <a name="prerequisites"></a>Erforderliche Voraussetzungen

# <a name="visual-studiotabvisual-studio"></a>[Visual Studio](#tab/visual-studio)

[!INCLUDE[](~/includes/net-core-prereqs-vs-3.0.md)]

# <a name="visual-studio-codetabvisual-studio-code"></a>[Visual Studio Code](#tab/visual-studio-code)

[!INCLUDE[](~/includes/net-core-prereqs-vsc-3.0.md)]

# <a name="visual-studio-for-mactabvisual-studio-mac"></a>[Visual Studio für Mac](#tab/visual-studio-mac)

[!INCLUDE[](~/includes/net-core-prereqs-mac-3.0.md)]

---

## <a name="update-net-core-sdk-version-in-globaljson"></a>Aktualisieren der .NET Core SDK-Version in „global.json“

Wenn Ihre Lösung für eine bestimmte .net Core SDK Version auf eine [Global. JSON](/dotnet/core/tools/global-json) -Datei basiert, aktualisieren Sie die `version`-Eigenschaft auf die Version 3,0, die auf Ihrem Computer installiert ist:

```json
{
  "sdk": {
    "version": "3.0.100"
  }
}
```

## <a name="update-the-project-file"></a>Aktualisieren der Projektdatei

### <a name="update-the-target-framework"></a>Aktualisieren des Ziel Frameworks

ASP.net Core 3,0 und höher wird nur unter .net Core ausgeführt. Legen Sie den [zielframeworkmoniker (TFM)](/dotnet/standard/frameworks) auf `netcoreapp3.0` fest:

[!code-xml[](22-to-30/samples/Web1.csproj?highlight=4)]

### <a name="remove-obsolete-package-references"></a>Veraltete Paket Verweise entfernen

ASP.net Core erzeugt keine große Anzahl von Features für nuget-Pakete mehr. Diese Paket Verweise sollten aus der Projektdatei entfernt werden. Beispielsweise die Vorlagen generierte Projektdatei für eine ASP.net Core 2,2-Web-App:

```xml
<Project Sdk="Microsoft.NET.Sdk.Web">

  <PropertyGroup>
    <TargetFramework>netcoreapp2.2</TargetFramework>
    <AspNetCoreHostingModel>InProcess</AspNetCoreHostingModel>
  </PropertyGroup>


  <ItemGroup>
    <PackageReference Include="Microsoft.AspNetCore.App"/>
    <PackageReference Include="Microsoft.AspNetCore.Razor.Design" Version="2.2.0" PrivateAssets="All" />
  </ItemGroup>

</Project>
```

Die aktualisierte ASP.net Core 3,0-Projektdatei:

[!code-xml[](22-to-30/samples/Web1.csproj?highlight=4)]

Die aktualisierte ASP.net Core 3,0-Projektdatei:

* In der `<PropertyGroup>`:

  * Aktualisiert den TFM auf `netcoreapp3.0`
  * Entfernt das `<AspNetCoreHostingModel>`-Element. Weitere Informationen finden Sie unter [in-Process-Hostingmodell](#in-process-hosting-model) in diesem Dokument.

* In der `<ItemGroup>`:

  * `Microsoft.AspNetCore.App` wird entfernt. Weitere Informationen finden Sie in diesem Dokument in der [frameworkreferenz](#framework-reference) .
  * `Microsoft.AspNetCore.Razor.Design` wird entfernt und in der folgenden Liste von Paketen, die nicht mehr erstellt werden.

Um die vollständige Liste der Pakete anzuzeigen, die nicht mehr erstellt werden, wählen Sie die folgende Erweiterungs Liste aus:

<details>
    <summary>Klicken Sie hier, um die Liste der Pakete zu erweitern, die nicht mehr erstellt werden.</summary>
    <ul>
        <li>Microsoft.AspNetCore</li>
        <li>Microsoft.AspNetCore.All</li>
        <li>Microsoft.AspNetCore.App</li>
        <li>Microsoft.AspNetCore.Antiforgery</li>
        <li>Microsoft.AspNetCore.Authentication</li>
        <li>Microsoft.AspNetCore.Authentication.Abstractions</li>
        <li>Microsoft.AspNetCore.Authentication.Cookies</li>
        <li>Microsoft.AspNetCore.Authentication.Core</li>
        <li>Microsoft.AspNetCore.Authentication.JwtBearer</li>
        <li>Microsoft.AspNetCore.Authentication.OAuth</li>
        <li>Microsoft.AspNetCore.Authentication.OpenIdConnect</li>
        <li>Microsoft.AspNetCore.Authorization</li>
        <li>Microsoft.AspNetCore.Authorization.Policy</li>
        <li>Microsoft.AspNetCore.CookiePolicy</li>
        <li>Microsoft.AspNetCore.Cors</li>
        <li>Microsoft.AspNetCore.Cryptography.Internal</li>
        <li>Microsoft.AspNetCore.Cryptography.KeyDerivation</li>
        <li>Microsoft.AspNetCore.DataProtection</li>
        <li>Microsoft.AspNetCore.DataProtection.Abstractions</li>
        <li>Microsoft.AspNetCore.DataProtection.Extensions</li>
        <li>Microsoft.AspNetCore.Diagnostics</li>
        <li>Microsoft.AspNetCore.Diagnostics.HealthChecks</li>
        <li>Microsoft.AspNetCore.HostFiltering</li>
        <li>Microsoft.AspNetCore.Hosting</li>
        <li>Microsoft.AspNetCore.Hosting.Abstractions</li>
        <li>Microsoft.AspNetCore.Hosting.Server.Abstractions</li>
        <li>Microsoft.AspNetCore.Http</li>
        <li>Microsoft.AspNetCore.Http.Abstractions</li>
        <li>Microsoft.AspNetCore.Http.Connections</li>
        <li>Microsoft.AspNetCore.Http.Extensions</li>
        <li>Microsoft.AspNetCore.Http.Features</li>
        <li>Microsoft.AspNetCore.HttpOverrides</li>
        <li>Microsoft.AspNetCore.HttpsPolicy</li>
        <li>Microsoft.AspNetCore.Identity</li>
        <li>Microsoft.AspNetCore.Localization</li>
        <li>Microsoft.AspNetCore.Localization.Routing</li>
        <li>Microsoft.AspNetCore.MiddlewareAnalysis</li>
        <li>Microsoft.AspNetCore.Mvc</li>
        <li>Microsoft.AspNetCore.Mvc.Abstractions</li>
        <li>Microsoft.AspNetCore.Mvc.Analyzers</li>
        <li>Microsoft.AspNetCore.Mvc.ApiExplorer</li>
        <li>Microsoft.AspNetCore.Mvc.Api.Analyzers</li>
        <li>Microsoft.AspNetCore.Mvc.Core</li>
        <li>Microsoft.AspNetCore.Mvc.Cors</li>
        <li>Microsoft.AspNetCore.Mvc.DataAnnotations</li>
        <li>Microsoft.AspNetCore.Mvc.Formatters.Json</li>
        <li>Microsoft.AspNetCore.Mvc.Formatters.Xml</li>
        <li>Microsoft.AspNetCore.Mvc.Localization</li>
        <li>Microsoft.AspNetCore.Mvc.Razor</li>
        <li>Microsoft.AspNetCore.Mvc.Razor.Extensions</li>
        <li>Microsoft.AspNetCore.Mvc.Razor.ViewCompilation</li>
        <li>Microsoft.AspNetCore.Mvc.RazorPages</li>
        <li>Microsoft.AspNetCore.Mvc.TagHelpers</li>
        <li>Microsoft.AspNetCore.Mvc.ViewFeatures</li>
        <li>Microsoft.AspNetCore.Razor</li>
        <li>Microsoft.AspNetCore.Razor.Runtime</li>
        <li>Microsoft.AspNetCore.Razor.Design</li>
        <li>Microsoft.AspNetCore.ResponseCaching</li>
        <li>Microsoft.AspNetCore.ResponseCaching.Abstractions</li>
        <li>Microsoft.AspNetCore.ResponseCompression</li>
        <li>Microsoft.AspNetCore.Rewrite</li>
        <li>Microsoft.AspNetCore.Routing</li>
        <li>Microsoft.AspNetCore.Routing.Abstractions</li>
        <li>Microsoft.AspNetCore.Server.HttpSys</li>
        <li>Microsoft.AspNetCore.Server.IIS</li>
        <li>Microsoft.AspNetCore.Server.IISIntegration</li>
        <li>Microsoft.AspNetCore.Server.Kestrel</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Core</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Https</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets</li>
        <li>Microsoft.AspNetCore.Session</li>
        <li>Microsoft.AspNetCore.SignalR</li>
        <li>Microsoft.AspNetCore.SignalR.Core</li>
        <li>Microsoft.AspNetCore.StaticFiles</li>
        <li>Microsoft.AspNetCore.WebSockets</li>
        <li>Microsoft.AspNetCore.WebUtilities</li>
        <li>Microsoft.net. http. Headers</li>
    </ul>
</details>

### <a name="review-breaking-changes"></a>Wichtige Änderungen überprüfen

[Wichtige Änderungen überprüfen](#break)

### <a name="framework-reference"></a>Frameworkverweis

Features von ASP.net Core, die über eines der oben aufgeführten Pakete verfügbar waren, sind als Teil des freigegebenen Frameworks `Microsoft.AspNetCore.App` verfügbar. Das frei *gegebene Framework* ist der Satz von Assemblys (*dll* -Dateien), die auf dem Computer installiert sind und eine Laufzeitkomponente und ein Ziel Paket enthalten. Weitere Informationen finden Sie unter [The shared framework](https://natemcmaster.com/blog/2018/08/29/netcore-primitives-2/) (Das freigegebene Framework).

* Projekte, die auf das `Microsoft.NET.Sdk.Web` SDK abzielen, verweisen implizit auf das `Microsoft.AspNetCore.App`-Framework.

Für diese Projekte sind keine weiteren Verweise erforderlich:

```xml
<Project Sdk="Microsoft.NET.Sdk.Web">
  <PropertyGroup>
    <TargetFramework>netcoreapp3.0</TargetFramework>
  </PropertyGroup>
    ...
</Project>
```

* Projekte, die `Microsoft.NET.Sdk`-oder `Microsoft.NET.Sdk.Razor` SDK als Ziel haben, sollten eine explizite `FrameworkReference` zu `Microsoft.AspNetCore.App` hinzufügen:

```xml
<Project Sdk="Microsoft.NET.Sdk.Razor">
  <PropertyGroup>
    <TargetFramework>netcoreapp3.0</TargetFramework>
  </PropertyGroup>

  <ItemGroup>
    <FrameworkReference Include="Microsoft.AspNetCore.App" />
  </ItemGroup>
    ...
</Project>
```

#### <a name="framework-dependent-builds-using-docker"></a>Framework-abhängige Builds mithilfe von Docker

Framework-abhängige Builds von Konsolen-apps, die ein Paket verwenden, das vom ASP.net Core [Shared Framework](https://natemcmaster.com/blog/2018/08/29/netcore-primitives-2/) abhängt, können den folgenden Laufzeitfehler verursachen:

```console
It was not possible to find any compatible framework version
The specified framework 'Microsoft.AspNetCore.App', version '3.0.0' was not found.
  - No frameworks were found.
```

`Microsoft.AspNetCore.App` ist das freigegebene Framework, das die ASP.net Core Runtime enthält und nur auf dem docker-Image [dotnet/Core/ASPNET](https://hub.docker.com/_/microsoft-dotnet-core-aspnet/) vorhanden ist.  Das 3,0 SDK reduziert die Größe von Framework-abhängigen Builds mithilfe von ASP.net Core, indem keine doppelten Kopien von Bibliotheken eingeschlossen werden, die im freigegebenen Framework verfügbar sind.  Dies ist eine potenzielle Einsparung von bis zu 18 MB, erfordert jedoch, dass die ASP.net Core-Laufzeit zum Ausführen der app vorhanden bzw. installiert sein muss.

Überprüfen Sie die *runtimeconfig. JSON* -Datei, die während der Erstellung/Veröffentlichung Ihrer APP generiert wird, um zu bestimmen, ob die APP eine Abhängigkeit (entweder direkt oder indirekt) auf dem ASP.net Core freigegebenen Framework aufweist. Die folgende JSON-Datei zeigt eine Abhängigkeit vom ASP.net Core Shared Framework:

```json
{
  "runtimeOptions": {
    "tfm": "netcoreapp3.0",
    "framework": {
      "name": "Microsoft.AspNetCore.App",
      "version": "3.0.0"
    },
    "configProperties": {
      "System.GC.Server": true
    }
  }
}
```

Wenn Ihre APP docker verwendet, verwenden Sie ein Basis Image, das ASP.net Core 3,0 enthält. Beispielsweise `docker pull mcr.microsoft.com/dotnet/core/aspnet:3.0`.

### <a name="add-package-references-for-removed-assemblies"></a>Paket Verweise für entfernte Assemblys hinzufügen

ASP.net Core 3,0 entfernt einige Assemblys, die zuvor Teil des `Microsoft.AspNetCore.App`-Paket Verweises waren. Um die von diesen Assemblys bereitgestellten Funktionen weiterhin zu verwenden, verweisen Sie auf die 3,0-Versionen der entsprechenden Pakete:

* Bei einer Vorlagen generierten Web-App mit **einzelnen Benutzerkonten** müssen die folgenden Pakete hinzugefügt werden:

  [!code-xml[](22-to-30/samples/WebFull.csproj?highlight=9-13)]

* [Microsoft. entityframeworkcore](https://www.nuget.org/packages/Microsoft.EntityFrameworkCore)

  Weitere Informationen zum Verweisen auf das Datenbankanbieter spezifische Paket finden Sie unter [Datenbankanbieter](/ef/core/providers/index).

* Identitäts Benutzeroberfläche

  Unterstützung für die [Benutzeroberfläche der Identität](xref:security/authentication/identity) kann durch Verweisen auf das [Microsoft. aspnetcore. Identity. UI](https://www.nuget.org/packages/Microsoft.AspNetCore.Identity.UI) -Paket hinzugefügt werden.

* Spa-Dienste

  * [Microsoft. aspnetcore. Spaservices](https://www.nuget.org/packages/Microsoft.AspNetCore.SpaServices)
  * [Microsoft. aspnetcore. Spaservices. Extensions](https://www.nuget.org/packages/Microsoft.AspNetCore.SpaServices.Extensions)

* Die Authentifizierung &ndash;-Unterstützung für Authentifizierungs Abläufe von Drittanbietern ist als nuget-Pakete verfügbar:

  * Facebook OAuth ([Microsoft. aspnetcore. Authentication. Facebook](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Facebook))
  * Google OAuth ([Microsoft. aspnetcore. Authentication. Google](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Google))
  * OpenID Connect-bearertoken ([Microsoft. aspnetcore. Authentication. jwtbearertoken](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.JwtBearer))
  * Microsoft-Konto Authentifizierung ([Microsoft. aspnetcore. Authentication. microsoftaccount](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.MicrosoftAccount))
  * OpenID Connect-Authentifizierung ([Microsoft. aspnetcore. Authentication. openidconnect](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.OpenIdConnect))
  * Twitter OAuth ([Microsoft. aspnetcore. Authentication. Twitter](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Twitter))
  * Wsfederation-Authentifizierung ([Microsoft. aspnetcore. Authentication. wsfederation](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.WsFederation))

* Unterstützung von Formatierung und Inhaltsaushandlung für `System.Net.HttpClient` &ndash; das nuget-Paket " [Microsoft. Aspnet. WebAPI. Client](https://www.nuget.org/packages/Microsoft.AspNet.WebApi.Client/) " bietet nützliche Erweiterbarkeit für `System.Net.HttpClient` mit APIs wie `ReadAsAsync`, `PostJsonAsync` usw.

* Razor-Runtime-Kompilierung &ndash;-Unterstützung für die Lauf Zeit Kompilierung von Razor-Ansichten und-Seiten ist nun Bestandteil von [Microsoft. aspnetcore. MVC. Razor. runtimecompilation](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Razor.RuntimeCompilation).

* MVC `Newtonsoft.Json` unterstützt &ndash;-Unterstützung für die Verwendung von MVC mit `Newtonsoft.Json` ist nun Bestandteil von [Microsoft. aspnetcore. MVC. newtonsoftware](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson).

## <a name="startup-changes"></a>Start Änderungen

Die folgende Abbildung zeigt die gelöschten und geänderten Zeilen in einer ASP.net Core 2,2 Razor Pages Web-App:

![die gelöschten und geänderten Zeilen in einer ASP.net Core Razor-Web-App mit 2,2.](22-to-30/_static/startup2.2.png)

In der vorangehenden Abbildung ist gelöschter Code rot dargestellt. Der gelöschte Code zeigt keinen Code für Cookie-Optionen an, der vor dem Vergleichen der Dateien gelöscht wurde.

Die folgende Abbildung zeigt die hinzugefügten und geänderten Zeilen in einer ASP.net Core 3,0 Razor Pages Web-App:

![die hinzugefügten und geänderten Zeilen in einer ASP.net Core Razor-Web-App mit 3,0.](22-to-30/_static/startup3.0.png)

In der vorangehenden Abbildung ist der hinzugefügte Code grün dargestellt. Weitere Informationen zu den folgenden Änderungen:

* `services.AddMvc` bis `services.AddRazorPages` finden Sie in diesem Dokument unter [MVC-Dienst Registrierung](#mvc-service-registration) .
* `CompatibilityVersion`, siehe <xref:mvc/compatibility-version>.
* `IHostingEnvironment` bis `IWebHostEnvironment` finden Sie in [dieser GitHub-Ankündigung](https://github.com/aspnet/AspNetCore/issues/7749).
* `app.UseAuthorization` wurde den Vorlagen hinzugefügt, um anzuzeigen, dass die Middleware für die Bestell Autorisierung hinzugefügt werden muss. Wenn die APP keine Autorisierung verwendet, können Sie den `app.UseAuthorization`-aufrufswert problemlos entfernen.
* `app.UseEndpoints` finden Sie unter [Razor Pages](#razor-pages) oder [Migrieren von "Startup. configure](#migrate-startupconfigure) " in diesem Dokument.

### <a name="analyzer-support"></a>Analyse Unterstützung

Projekte, die `Microsoft.NET.Sdk.Web` als Ziel haben, verweisen implizit auf Analysen, die zuvor als Teil des Pakets [Microsoft. aspnetcore. MVC. Analysen](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Analyzers/) ausgeliefert wurden. Es sind keine zusätzlichen Verweise erforderlich, um diese zu aktivieren.

Wenn Ihre APP [API-Analysen](xref:web-api/advanced/analyzers) verwendet, die zuvor mit dem Paket [Microsoft. aspnetcore. MVC. API. Analysen](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Api.Analyzers/) ausgeliefert wurden, bearbeiten Sie die Projektdatei so, dass Sie auf die Analysen verweist, die als Teil des .net Core Web SDK ausgeliefert werden:

```xml
<Project Sdk="Microsoft.NET.Sdk.Web">
    <PropertyGroup>
        <TargetFramework>netcoreapp3.0</TargetFramework>
        <IncludeOpenAPIAnalyzers>true</IncludeOpenAPIAnalyzers>
    </PropertyGroup>

    ...
</Project>
```

### <a name="razor-class-library"></a>Razor-Klassenbibliothek

Razor-Klassen Bibliotheks Projekte, die Benutzeroberflächen Komponenten für MVC bereitstellen, müssen die `AddRazorSupportForMvc`-Eigenschaft in der Projektdatei festlegen:

```xml
<PropertyGroup>
  <AddRazorSupportForMvc>true</AddRazorSupportForMvc>
</PropertyGroup>
```

### <a name="in-process-hosting-model"></a>In-Process-Hostingmodell

-Projekte werden standardmäßig in ASP.net Core 3,0 oder höher auf das [in-Process-Hostingmodell](xref:host-and-deploy/aspnet-core-module#in-process-hosting-model) eingestellt. Sie können optional die `<AspNetCoreHostingModel>`-Eigenschaft in der Projektdatei entfernen, wenn der Wert `InProcess` ist.

## <a name="kestrel"></a>Kestrel

### <a name="configuration"></a>Konfiguration

Migrieren Sie die Kestrel-Konfiguration zum Webhost-Generator, der von `ConfigureWebHostDefaults` (*Program.cs*) bereitgestellt wird:

```csharp
public static IHostBuilder CreateHostBuilder(string[] args) =>
    Host.CreateDefaultBuilder(args)
        .ConfigureWebHostDefaults(webBuilder =>
        {
            webBuilder.ConfigureKestrel(serverOptions =>
            {
                // Set properties and call methods on options
            })
            .UseStartup<Startup>();
        });
```

Wenn die APP den Host mit `HostBuilder` manuell erstellt, wenden Sie `UseKestrel` auf dem Webhost-Generator in `ConfigureWebHostDefaults` an:

```csharp
public static void Main(string[] args)
{
    var host = new HostBuilder()
        .UseContentRoot(Directory.GetCurrentDirectory())
        .ConfigureWebHostDefaults(webBuilder =>
        {
            webBuilder.UseKestrel(serverOptions =>
            {
                // Set properties and call methods on options
            })
            .UseIISIntegration()
            .UseStartup<Startup>();
        })
        .Build();

    host.Run();
}
```

### <a name="connection-middleware-replaces-connection-adapters"></a>Verbindungs-Middleware ersetzt Verbindungs Adapter

Verbindungs Adapter (`Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.IConnectionAdapter`) wurden aus Kestrel entfernt. Ersetzen Sie Verbindungs Adapter durch Verbindungs Middleware. Die Verbindungs Middleware ähnelt http-Middleware in der ASP.net Core Pipeline, aber für Verbindungen auf niedrigerer Ebene. HTTPS und Verbindungs Protokollierung:

* Wurden von Verbindungs Adaptern zur Verbindungs Middleware verschoben.
* Diese Erweiterungs Methoden funktionieren wie in früheren Versionen von ASP.net Core. 

Weitere Informationen finden Sie [im Abschnitt "tlsfilterconnectionhandler" im Abschnitt "listenoptions. Protokolls" im Kestrel-Artikel](/aspnet/core/fundamentals/servers/kestrel?view=aspnetcore-3.0#listenoptionsprotocols).

### <a name="transport-abstractions-moved-and-made-public"></a>Transport Abstraktionen verschoben und öffentlich gemacht

Die Kestrel-Transportschicht wurde in `Connections.Abstractions` als öffentliche Schnittstelle verfügbar gemacht. Als Teil dieser Updates:

* `Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions` und zugeordnete Typen wurden entfernt.
* <xref:Microsoft.AspNetCore.Server.Kestrel.KestrelServerOptions.NoDelay> wurde von <xref:Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions> in die Transport Optionen verschoben.
* `Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions.Internal.SchedulingMode` wurde aus <xref:Microsoft.AspNetCore.Server.Kestrel.KestrelServerOptions> entfernt.

Weitere Informationen finden Sie in den folgenden GitHub-Ressourcen:

* [Client/Server-Netzwerk Abstraktionen (ASPNET/aspnetcore-#10308)](https://github.com/aspnet/AspNetCore/issues/10308)
* [Implementieren Sie die neue Fundament-Listener-Abstraktion, und setzen Sie Kestrel im oberen Bereich (ASPNET/aspnetcore-#10321).](https://github.com/aspnet/AspNetCore/pull/10321)

### <a name="kestrel-request-trailer-headers"></a>Kestrel-Anforderungs Nachspann Header

Für apps, die auf frühere Versionen von ASP.net Core abzielen:

* Kestrel fügt der Auflistung der Anforderungs Header HTTP/1.1-Auflistungs Header hinzu.
* Nach dem Lesen des Anforderungs Texts sind die nach dem Ende des Anforderungs Texts verfügbar.

Dies bewirkt einige Bedenken bezüglich der Mehrdeutigkeit zwischen Headern und nach Spann, sodass die Nachspann in eine neue Sammlung (`RequestTrailerExtensions`) in 3,0 verschoben wurden.

HTTP/2-Anforderungs Nachspann:

* Nicht verfügbar in ASP.net Core 2,2.
* Verfügbar in 3,0 als `RequestTrailerExtensions`.

Für den Zugriff auf diese Nachspann sind neue Anforderungs Erweiterungs Methoden vorhanden. Wie bei HTTP/1.1 sind Nachspann verfügbar, nachdem der Anforderungs Text bis zum Ende gelesen wurde.

Für die 3,0-Version sind die folgenden `RequestTrailerExtensions`-Methoden verfügbar:

* `GetDeclaredTrailers` &ndash; Ruft den Request `Trailer`-Header ab, der auflistet, welche Nachspann nach dem Text erwartet werden.
* `SupportsTrailers` &ndash; gibt an, ob die Anforderung das Empfangen von nach Spann Headern unterstützt.
* `CheckTrailersAvailable` &ndash; überprüft, ob die Anforderung Nachspann unterstützt und ob Sie gelesen werden können. Bei dieser Überprüfung wird nicht davon ausgegangen, dass zum Lesen von nach spannenden Möglicherweise gibt es keine zu lesenden Nachspann, auch wenn `true` von dieser Methode zurückgegeben wird.
* `GetTrailer` &ndash; Ruft den angeforderten nachfolgenden Header aus der Antwort ab. Aktivieren Sie `SupportsTrailers`, bevor Sie `GetTrailer` aufrufen, oder es kann ein <xref:System.NotSupportedException> auftreten, wenn die Anforderung keine nachfolgenden Header unterstützt.

Weitere Informationen finden Sie unter [Put Request Trailers in a separate Collection (ASPNET/aspnetcore-#10410)](https://github.com/aspnet/AspNetCore/pull/10410).

### <a name="allowsynchronousio-disabled"></a>Allowsynchronousio deaktiviert

`AllowSynchronousIO` aktiviert oder deaktiviert synchrone e/a-APIs, z. b. `HttpRequest.Body.Read`, `HttpResponse.Body.Write` und `Stream.Flush`. Diese APIs sind eine Quelle der Thread Hungersnot, die zu app-Abstürzen führt. In 3.0 ist `AllowSynchronousIO` standardmäßig deaktiviert. Weitere Informationen finden Sie im Abschnitt "Synchrone e/a" [im Kestrel-Artikel](/aspnet/core/fundamentals/servers/kestrel?view=aspnetcore-3.0#synchronous-io).

Zusätzlich zum Aktivieren von `AllowSynchronousIO` mit den Optionen von `ConfigureKestrel` kann die synchrone e/a auch auf Anforderungs Basis als vorübergehende Entschärfung überschrieben werden:

```csharp
var syncIOFeature = HttpContext.Features.Get<IHttpBodyControlFeature>();

if (syncIOFeature != null)
{
    syncIOFeature.AllowSynchronousIO = true;
}
```

Wenn Sie Probleme mit <xref:System.IO.TextWriter>-Implementierungen oder anderen Streams haben, die synchrone [APIs in verwerfen](/dotnet/standard/garbage-collection/implementing-dispose)aufzurufen, müssen Sie stattdessen die neue <xref:System.IO.Stream.DisposeAsync*>-API aufzurufen.

Weitere Informationen finden Sie unter [[Ankündigung] allowsynchronousio deaktiviert auf allen Servern (ASPNET/aspnetcore-#7644)](https://github.com/aspnet/AspNetCore/issues/7644).

### <a name="microsoftaspnetcoreserverkestrelhttps-assembly-removed"></a>Die Assembly "Microsoft. aspnetcore. Server. Kestrel. https" wurde entfernt.

In ASP.net Core 2,1 wurde der Inhalt von " *Microsoft. aspnetcore. Server. Kestrel. HTTPS. dll* " in " *Microsoft. aspnetcore. Server. Kestrel. Core. dll*" verschoben. Dabei handelt es sich um ein nicht Erbrechtes Update mit `TypeForwardedTo`-Attributen. Bei 3,0 wurden die leere *Microsoft. aspnetcore. Server. Kestrel. HTTPS. dll* -Assembly und das nuget-Paket entfernt.

Bibliotheken, die auf [Microsoft. aspnetcore. Server. Kestrel. HTTPS](https://www.nuget.org/packages/Microsoft.AspNetCore.Server.Kestrel.Https) verweisen, sollten ASP.net Core Abhängigkeiten auf 2,1 oder höher aktualisieren.

Apps und Bibliotheken, die auf ASP.net Core 2,1 oder höher abzielen, sollten alle direkten Verweise auf das Paket [Microsoft. aspnetcore. Server. Kestrel. HTTPS](https://www.nuget.org/packages/Microsoft.AspNetCore.Server.Kestrel.Https) entfernen.

## <a name="jsonnet-support"></a>JSON.NET-Unterstützung

Als Teil der Arbeit zur [Verbesserung der ASP.net Core Shared Framework](https://blogs.msdn.microsoft.com/webdev/2018/10/29/a-first-look-at-changes-coming-in-asp-net-core-3-0/)wurde [JSON.net](https://www.newtonsoft.com/json/help/html/Introduction.htm) aus dem freigegebenen Framework ASP.net Core entfernt.

Der Standardwert für ASP.net Core ist jetzt [System. Text. JSON](/dotnet/api/system.text.json?view=netcore-3.0), das in .net Core 3,0 neu ist. Verwenden Sie nach Möglichkeit `System.Text.Json`. Dies ist eine hohe Leistung und erfordert keine zusätzliche Bibliotheks Abhängigkeit. Da `System.Text.Json` jedoch neu ist, sind möglicherweise derzeit keine Features vorhanden, die Ihre APP benötigt.

Ihre APP erfordert möglicherweise `Newtonsoft.Json`-Integration, wenn Sie @no__t -1-spezifische Funktion wie jsonpatch oder Konverter verwendet oder @no__t -3-spezifische Typen [formatiert](xref:web-api/advanced/formatting) .

Informationen zum Verwenden von JSON.net in einem 3,0 ASP.net Core signalr-Projekt finden Sie unter [Wechseln zu "newtonsoft. JSON](#switch-to-newtonsoftjson) " in diesem Dokument.

So verwenden sie JSON.net in einem ASP.net Core 3,0-Projekt:

* Fügen Sie [Microsoft.AspNetCore.Mvc.NewtonsoftJson](https://nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson) einen Paketverweis hinzu.
* Aktualisieren Sie `Startup.ConfigureServices`, um `AddNewtonsoftJson` aufzurufen.

  ```csharp
  services.AddMvc()
      .AddNewtonsoftJson();
  ```

  `AddNewtonsoftJson` ist mit den neuen Registrierungsmethoden für den MVC-Dienst kompatibel:

  * `AddRazorPages`
  * `AddControllersWithViews`
  * `AddControllers`

  ```csharp
  services.AddControllers()
      .AddNewtonsoftJson();
  ```

  JSON.NET-Einstellungen können im `AddNewtonsoftJson`-aufrufswert festgelegt werden:

  ```csharp
  services.AddMvc()
      .AddNewtonsoftJson(options =>
             options.SerializerSettings.ContractResolver =
                new CamelCasePropertyNamesContractResolver());
  ```

## <a name="mvc-service-registration"></a>MVC-Dienst Registrierung

ASP.net Core 3,0 fügt neue Optionen zum Registrieren von MVC-Szenarien in `Startup.ConfigureServices` hinzu.

Drei neue Erweiterungs Methoden der obersten Ebene im Zusammenhang mit MVC-Szenarien auf `IServiceCollection` sind verfügbar. Vorlagen verwenden diese neuen Methoden anstelle von `AddMvc`. @No__t-0 verhält sich jedoch weiterhin wie in früheren Versionen.

Im folgenden Beispiel wird die Unterstützung für Controller und API-Funktionen hinzugefügt, jedoch keine Sichten oder Seiten. Die API-Vorlage verwendet diesen Code:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllers();
}
```

Im folgenden Beispiel werden die Unterstützung für Controller, API-bezogene Features und Sichten, aber keine Seiten hinzugefügt. Die Vorlage Webanwendung (MVC) verwendet folgenden Code:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllersWithViews();
}
```

Im folgenden Beispiel wird Unterstützung für Razor Pages und minimale Controller Unterstützung hinzugefügt. Die Webanwendungsvorlage verwendet diesen Code:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddRazorPages();
}
```

Die neuen Methoden können ebenfalls kombiniert werden. Das folgende Beispiel entspricht dem Aufrufen von `AddMvc` in ASP.net Core 2,2:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllersWithViews();
    services.AddRazorPages();
}
```

## <a name="routing-startup-code"></a>Routing Startcode

Wenn eine APP `UseMvc` oder `UseSignalR` aufruft, migrieren Sie die APP nach Möglichkeit zum [Endpunkt Routing](xref:fundamentals/routing) . Um die Kompatibilität mit dem Endpunkt Routing mit früheren Versionen von MVC zu verbessern, haben wir einige der Änderungen in der URL-Generierung wieder hergestellt, die in ASP.net Core 2,2 eingeführt wurden. Wenn bei der Verwendung des Endpunkt Routings in 2,2 Probleme auftreten, erwarten Sie Verbesserungen in ASP.net Core 3,0 mit folgenden Ausnahmen:

* Wenn die APP `IRouter` implementiert oder von `Route` erbt, verwenden Sie [dynamicroutevaluestransex](https://github.com/aspnet/AspNetCore.Docs/issues/12997) als Ersatz.

* Wenn die APP direkt auf `RouteData.Routers` innerhalb von MVC zugreift, um URLs zu analysieren, können Sie dies durch die Verwendung von `LinkParser.ParsePathByEndpointName` ersetzen. 
 * Hiermit wird die Route mit einem Routennamen definiert.
 * Verwenden Sie `LinkParser.ParsePathByEndpointName`, und übergeben Sie den gewünschten Routennamen.

Das Endpunkt Routing unterstützt die gleiche Routing Muster Syntax und die Funktionen zum Erstellen von Routen Mustern wie `IRouter`. Das Endpunkt Routing unterstützt `IRouteConstraint`. Das Endpunkt Routing unterstützt die Attribute "`[Route]`", "`[HttpGet]`" und "MVC-Routing".

Bei den meisten Anwendungen müssen nur `Startup` geändert werden.

### <a name="migrate-startupconfigure"></a>"Startup. configure" Migrieren

Allgemeine Hinweise:

* Fügen Sie `UseRouting` hinzu.
* Wenn die APP `UseStaticFiles` aufruft, platzieren Sie `UseStaticFiles` **vor** `UseRouting`.
* Wenn die APP Authentifizierungs-/Autorisierungsfeatures wie `AuthorizePage` oder `[Authorize]` verwendet, platzieren Sie den-Befehl `UseAuthentication` und `UseAuthorization`: **after**, `UseRouting` und `UseCors`, aber vor `UseEndpoints`:

  ```csharp
  public void Configure(IApplicationBuilder app)
  {
    ...

    app.UseStaticFiles();

    app.UseRouting();
    app.UseCors();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints => {
       endpoints.MapControllers();
    });
  ```

* Ersetzen Sie `UseMvc` oder `UseSignalR` durch `UseEndpoints`.
* Wenn die APP [cors](xref:security/cors) -Szenarien verwendet, wie z. b. `[EnableCors]`, platzieren Sie `UseCors` vor allen anderen Middleware, die cors verwenden (z. b. Platzieren Sie `UseCors` vor `UseAuthentication`, `UseAuthorization` und `UseEndpoints`).
* Ersetzen Sie `IHostingEnvironment` durch `IWebHostEnvironment`, und fügen Sie eine `using`-Anweisung für den <xref:Microsoft.Extensions.Hosting?displayProperty=fullName>-Namespace hinzu.
* Ersetzen Sie `IApplicationLifetime` durch <xref:Microsoft.Extensions.Hosting.IHostApplicationLifetime> (<xref:Microsoft.Extensions.Hosting?displayProperty=fullName>-Namespace).
* Ersetzen Sie `EnvironmentName` durch <xref:Microsoft.Extensions.Hosting.Environments> (<xref:Microsoft.Extensions.Hosting?displayProperty=fullName>-Namespace).

Der folgende Code ist ein Beispiel für `Startup.Configure` in einer typischen ASP.net Core 2,2-App:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseStaticFiles();

    app.UseAuthentication();

    app.UseSignalR(hubs =>
    {
        hubs.MapHub<ChatHub>("/chat");
    });

    app.UseMvc(routes =>
    {
        routes.MapRoute("default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

Nach dem Aktualisieren des vorherigen `Startup.Configure`-Codes:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseStaticFiles();

    app.UseRouting();

    app.UseCors();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>("/chat");
        endpoints.MapControllerRoute("default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

> [!WARNING]
> Bei den meisten apps müssen Aufrufe von `UseAuthentication`, `UseAuthorization` und `UseCors` zwischen den Aufrufen von `UseRouting` und `UseEndpoints` angezeigt werden, damit Sie wirksam werden.

### <a name="health-checks"></a>Integritätsprüfungen

Integritätsprüfungen verwenden das Endpunktrouting mit dem generischen Host. Rufen Sie in `Startup.Configure` auf der Endpunkterstellung mit der Endpunkt-URL oder dem relativen Pfad `MapHealthChecks` auf:

```csharp
app.UseEndpoints(endpoints =>
{
    endpoints.MapHealthChecks("/health");
});
```

Für Endpunkte für Integritätsprüfungen gilt Folgendes:

* Sie geben mindestens einen zugelassenen Host oder Port an.
* Sie erfordern Autorisierung.
* Sie erfordern CORS.

Weitere Informationen finden Sie unter <xref:host-and-deploy/health-checks>.

### <a name="security-middleware-guidance"></a>Leitfaden zur Sicherheit von Middleware

Unterstützung für die Autorisierung und cors ist in Bezug auf den [Middleware](xref:fundamentals/middleware/index) -Ansatz einheitlich. Dies ermöglicht die Verwendung derselben Middleware und derselben Funktionalität in diesen Szenarien. In dieser Version wird eine aktualisierte Autorisierungs Middleware bereitgestellt, und die cors-Middleware wird verbessert, sodass Sie die von MVC-Controllern verwendeten Attribute verstehen kann.

#### <a name="cors"></a>CORS

Zuvor war es möglicherweise schwierig, cors zu konfigurieren. Die Middleware wurde zur Verwendung in einigen Anwendungsfällen bereitgestellt, aber MVC-Filter waren in anderen Anwendungsfällen **ohne** die Middleware vorgesehen. Bei ASP.net Core 3,0 wird empfohlen, dass alle apps, die cors benötigen, die cors-Middleware zusammen mit dem Endpunkt Routing verwenden. `UseCors` kann mit einer Standard Richtlinie angegeben werden, @no__t und die Attribute "-1" und "`[DisableCors]`" können verwendet werden, um die Standard Richtlinie nach Bedarf zu überschreiben.

Im folgenden Beispiel:

* Cors ist für alle Endpunkte mit der benannten Richtlinie "`default`" aktiviert.
* Die `MyController`-Klasse deaktiviert cors mit dem `[DisableCors]`-Attribut.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseCors("default");

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

[DisableCors]
public class MyController : ControllerBase
{
    ...
}
```

#### <a name="authorization"></a>Autorisierung

In früheren Versionen von ASP.net Core wurde Unterstützung der Autorisierung über das `[Authorize]`-Attribut bereitgestellt. Die Autorisierungs Middleware war nicht verfügbar. In ASP.net Core 3,0 ist die Autorisierungs Middleware erforderlich. Es wird empfohlen, die ASP.net Core Autorisierungs Middleware (`UseAuthorization`) unmittelbar nach `UseAuthentication` zu platzieren. Die Middleware für die Autorisierung kann auch mit einer Standard Richtlinie konfiguriert werden, die überschrieben werden kann.

In ASP.net Core 3,0 oder höher wird `UseAuthorization` in `Startup.Configure` aufgerufen, und für die folgenden `HomeController` ist ein angemeldeter Benutzer erforderlich:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

public class HomeController : ControllerBase
{
    [Authorize]
    public IActionResult BuyWidgets()
    {
        ...
    }
}
```

Wenn die APP eine `AuthorizeFilter` als globalen Filter in MVC verwendet, empfiehlt es sich, den Code so zu umgestalten, dass er eine Richtlinie im-Befehl `AddAuthorization` bereitstellt.

Der `DefaultPolicy` ist anfänglich so konfiguriert, dass eine Authentifizierung erforderlich ist, sodass keine zusätzliche Konfiguration erforderlich ist. Im folgenden Beispiel werden MVC-Endpunkte als `RequireAuthorization` gekennzeichnet, sodass alle Anforderungen auf der Grundlage des `DefaultPolicy` autorisiert werden müssen. Der `HomeController` ermöglicht jedoch den Zugriff, ohne dass der Benutzer sich bei der App anmeldet, da `[AllowAnonymous]`:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute().RequireAuthorization();
    });
}

[AllowAnonymous]
public class HomeController : ControllerBase
{
    ...
}
```

Richtlinien können auch angepasst werden. Im vorherigen Beispiel wird die `DefaultPolicy` so konfiguriert, dass Authentifizierung und ein bestimmter Bereich erforderlich sind:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    ...

    services.AddAuthorization(options =>
    {
        options.DefaultPolicy = new AuthorizationPolicyBuilder()
          .RequireAuthenticatedUser()
          .Build();
    });
}

public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute().RequireAuthorization();
    });
}

[AllowAnonymous]
public class HomeController : ControllerBase
{
    ...
}
```

Alternativ können alle Endpunkte so konfiguriert werden, dass eine Autorisierung ohne `[Authorize]` oder `RequireAuthorization` erforderlich ist, indem ein `FallbackPolicy` konfiguriert wird. Der `FallbackPolicy` unterscheidet sich vom `DefaultPolicy`. Der `DefaultPolicy` wird durch `[Authorize]` oder `RequireAuthorization` ausgelöst, während das `FallbackPolicy` ausgelöst wird, wenn keine andere Richtlinie festgelegt ist. `FallbackPolicy` ist anfänglich so konfiguriert, dass Anforderungen ohne Autorisierung zugelassen werden.

Das folgende Beispiel ist identisch mit dem vorangehenden `DefaultPolicy`-Beispiel, verwendet jedoch die `FallbackPolicy`, um immer eine Authentifizierung für alle Endpunkte anzufordern, außer wenn `[AllowAnonymous]` angegeben ist:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    ...

    services.AddAuthorization(options =>
    {
        options.FallbackPolicy = new AuthorizationPolicyBuilder()
          .RequireAuthenticatedUser()
          .Build();
    });
}

public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

[AllowAnonymous]
public class HomeController : ControllerBase
{
    ...
}
```

Die Autorisierung durch Middleware funktioniert, ohne dass das Framework über bestimmte Kenntnisse der Autorisierung verfügt. Integritäts [Prüfungen](xref:host-and-deploy/health-checks) haben beispielsweise keine spezifischen Kenntnisse der Autorisierung, aber Integritätsprüfungen können eine konfigurierbare Autorisierungs Richtlinie aufweisen, die von der Middleware angewendet wird.

Außerdem kann jeder Endpunkt seine Autorisierungs Anforderungen anpassen. Im folgenden Beispiel wird die Autorisierung mit der `DefaultPolicy` von `UseAuthorization` verarbeitet, aber für den Endpunkt der `/healthz`-Integritäts Überprüfung ist ein `admin`-Benutzer erforderlich:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints
            .MapHealthChecks("/healthz")
            .RequireAuthorization(new AuthorizeAttribute(){ Roles = "admin", });
    });
}
```

Der Schutz wird für einige Szenarien implementiert. Die Middleware für Endpunkte löst eine Ausnahme aus, wenn eine Autorisierungs-oder cors-Richtlinie aufgrund fehlender Middleware übersprungen wird. Analyse Unterstützung, um zusätzliches Feedback zur Fehlkonfiguration bereitzustellen.

### <a name="signalr"></a>SignalR

Die Zuordnung von signalr Hubs erfolgt nun in `UseEndpoints`.

Ordnen Sie jeden Hub `MapHub` zu. Wie in früheren Versionen wird jeder Hub explizit aufgelistet.

Im folgenden Beispiel wird die Unterstützung für den signalr-Hub "`ChatHub`" hinzugefügt:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>();
    });
}
```

Es gibt eine neue Option zum Steuern von Größenbeschränkungen für Nachrichten von Clients. Beispielsweise in `Startup.ConfigureServices`:

```csharp
services.AddSignalR(hubOptions =>
{
    hubOptions.MaximumReceiveMessageSize = 32768;
});
```

In ASP.net Core 2,2 können Sie die `TransportMaxBufferSize` festlegen und die maximale Nachrichtengröße effektiv steuern. In ASP.net Core 3,0 steuert diese Option jetzt nur die maximale Größe, bevor der Rückdruck festgestellt wird.

### <a name="mvc-controllers"></a>MVC-Controller

Die Zuordnung von Controllern erfolgt nun in `UseEndpoints`.

Fügen Sie `MapControllers` hinzu, wenn die APP Attribut Routing verwendet. Da das Routing Unterstützung für viele Frameworks in ASP.net Core 3,0 oder höher bietet, ist das Hinzufügen von Attribut Weiterleitungs Controllern ein Opt-in.

Ersetzen Sie Folgendes:

* `MapRoute` mit `MapControllerRoute`
* `MapAreaRoute` mit `MapAreaControllerRoute`

Da das Routing nun die Unterstützung für mehr als nur MVC umfasst, hat sich die Terminologie geändert, damit diese Methoden deutlich erkennen können, was Sie tun. Herkömmliche Routen wie `MapControllerRoute` @ no__t-1 @ no__t-2 @ no__t-3 @ no__t-4 werden in der Reihenfolge angewendet, in der Sie hinzugefügt werden. Platzieren Sie zunächst spezifischere Routen (z. b. Routen für einen Bereich).

Im folgenden Beispiel:

* `MapControllers` fügt Unterstützung für Attribut Weiterleitungs Controller hinzu.
* `MapAreaControllerRoute` fügt eine konventionelle Route für Controller in einem Bereich hinzu.
* `MapControllerRoute` fügt eine konventionelle Route für Controller hinzu.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapControllers();
        endpoints.MapAreaControllerRoute(
            "admin",
            "admin",
            "Admin/{controller=Home}/{action=Index}/{id?}");
        endpoints.MapControllerRoute(
            "default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

#### <a name="async-suffix-removal-from-controller-action-names"></a>Asynchrones Suffix aus Controller-Aktions Namen entfernen

In ASP.net Core 3,0 entfernt ASP.net Core MVC das Suffix `Async` aus Controller Aktions Namen. Das Routing und die Verknüpfungs Generierung sind von dieser neuen Standardeinstellung betroffen. Beispiel:

```csharp
public class ProductsController : Controller
{
    public async Task<IActionResult> ListAsync()
    {
        var model = await _dbContext.Products.ToListAsync();
        return View(model);
    }
}
```

Vor ASP.net Core 3,0:

* Auf die vorherige Aktion kann auf der Route " *Products/listasync* " zugegriffen werden.
* Die Link Generierung erforderte die Angabe des `Async`-Suffixes. Beispiel:

    ```cshtml
    <a asp-controller="Products" asp-action="ListAsync">List</a>
    ```

In ASP.net Core 3,0:

* Auf die vorangehende Aktion kann auf der Route " *Products/List* " zugegriffen werden.
* Bei der Link Generierung muss das Suffix "`Async`" nicht angegeben werden. Beispiel:

    ```cshtml
    <a asp-controller="Products" asp-action="List">List</a>
    ```

Diese Änderung hat keine Auswirkungen auf die Namen, die mit dem [[Aktionsname]](/dotnet/api/microsoft.aspnetcore.mvc.actionnameattribute) -Attribut angegeben werden Das Standardverhalten kann mit dem folgenden Code in `Startup.ConfigureServices` deaktiviert werden:

```csharp
services.AddMvc(options =>
    options.SuppressAsyncSuffixInActionNames = false);
```

### <a name="razor-pages"></a>Razor Pages

Die Zuordnung Razor Pages jetzt in `UseEndpoints` stattfinden.

Fügen Sie `MapRazorPages` hinzu, wenn die APP Razor Pages verwendet. Da das Endpunkt Routing Unterstützung für viele Frameworks umfasst, ist das Hinzufügen von Razor Pages jetzt deaktiviert.

In der folgenden `Startup.Configure`-Methode wird von `MapRazorPages` Unterstützung für Razor Pages hinzugefügt:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapRazorPages();
    });
}
```

### <a name="use-mvc-without-endpoint-routing"></a>Verwenden von MVC ohne Endpunkt Routing

Die Verwendung von MVC über `UseMvc` oder `UseMvcWithDefaultRoute` in ASP.net Core 3,0 erfordert ein explizites Opt-in in `Startup.ConfigureServices`. Dies ist erforderlich, da MVC wissen muss, ob es während der Initialisierung auf die Autorisierung und die cors-Middleware zurückgreifen kann. Es wird ein Analyzer bereitgestellt, der warnt, wenn die APP versucht, eine nicht unterstützte Konfiguration zu verwenden.

Wenn die APP ältere `IRouter`-Unterstützung erfordert, deaktivieren Sie `EnableEndpointRouting` mithilfe der folgenden Vorgehensweisen in `Startup.ConfigureServices`:

```csharp
services.AddMvc(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddControllers(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddControllersWithViews(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddRazorPages().AddMvcOptions(options => options.EnableEndpointRouting = false);
```

### <a name="health-checks"></a>Integritätsprüfungen

Integritätsprüfungen können als *routerware* mit Endpunkt Routing verwendet werden.

Fügen Sie `MapHealthChecks` hinzu, um Integritätsprüfungen mit dem Endpunkt Routing zu verwenden. Die `MapHealthChecks`-Methode akzeptiert Argumente ähnlich `UseHealthChecks`. Der Vorteil der Verwendung von `MapHealthChecks` gegenüber `UseHealthChecks` ist die Fähigkeit, Autorisierung anzuwenden und eine präzisere Kontrolle über die abgleichsrichtlinie zu haben.

Im folgenden Beispiel wird `MapHealthChecks` für einen Integritäts Prüf Punkt bei `/healthz` aufgerufen:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHealthChecks("/healthz", new HealthCheckOptions() { });
    });
}
```

## <a name="hostbuilder-replaces-webhostbuilder"></a>Der hostbuilder ersetzt webhostbuilder.

In den ASP.net Core 3,0-Vorlagen wird [generischer Host](xref:fundamentals/host/generic-host)verwendet. In früheren Versionen wurde [Webhost](xref:fundamentals/host/web-host)verwendet. Der folgende Code zeigt die ASP.net Core 3,0-Vorlage, die `Program`-Klasse generiert wurde:

[!code-csharp[](22-to-30/samples/Program.cs?name=snippet)]

Der folgende Code zeigt den ASP.net Core 2,2-Vorlagen generierten `Program`-Klasse:

[!code-csharp[](22-to-30/samples/Program2.2.cs?name=snippet)]

<xref:Microsoft.AspNetCore.Hosting.IWebHostBuilder> verbleibt in 3,0 und ist der Typ des `webBuilder`, das im vorangehenden Codebeispiel angezeigt wurde. <xref:Microsoft.AspNetCore.Hosting.WebHostBuilder> wird in einer zukünftigen Version als veraltet eingestuft und durch `HostBuilder` ersetzt.

Die signifikanteste Änderung von `WebHostBuilder` bis `HostBuilder` ist die [Abhängigkeitsinjektion (di)](xref:fundamentals/dependency-injection). Wenn Sie `HostBuilder` verwenden, können Sie nur <xref:Microsoft.Extensions.Configuration.IConfiguration> und <xref:Microsoft.AspNetCore.Hosting.IHostingEnvironment> in `Startup`-Konstruktor einfügen. Die `HostBuilder` di-Einschränkungen:

* Aktivieren Sie den di-Container nur ein einziges Mal.
* Vermeidet die resultierenden Probleme bei der Objekt Lebensdauer wie das Auflösen mehrerer Instanzen von Singletons.

## <a name="addauthorization-moved-to-a-different-assembly"></a>Addauthorization in eine andere Assembly verschoben

Die ASP.net Core 2,2 und niedriger `AddAuthorization`-Methoden in *Microsoft. aspnetcore. Authorization. dll*:

* Wurden umbenannt `AddAuthorizationCore`.
* Wurden in " *Microsoft. aspnetcore. Authorization. Policy. dll*" verschoben.

Apps, die sowohl *Microsoft. aspnetcore. Authorization. dll* als auch *Microsoft. aspnetcore. Authorization. Policy. dll* verwenden, sind nicht betroffen.

Apps, die nicht *Microsoft. aspnetcore. Authorization. Policy. dll* verwenden, sollten eine der folgenden Aktionen ausführen:

* Wechseln Sie zu `AddAuthorizationCore`
* Fügen Sie einen Verweis auf *Microsoft. aspnetcore. Authorization. Policy. dll*hinzu.

Weitere Informationen finden Sie unter [Breaking Change in `AddAuthorization(o =>`) über Ladungen Leben in einer anderen Assembly #386](https://github.com/aspnet/Announcements/issues/386).

## <a name="signalr"></a>SignalR

Der signalr-JavaScript-Client wurde von `@aspnet/signalr` in `@microsoft/signalr` geändert. Um auf diese Änderung zu reagieren, ändern Sie die Verweise in den Dateien " *Package. JSON* ", "`require`" und "ECMAScript `import`".

### <a name="systemtextjson-is-the-default-protocol"></a>"System. Text. JSON" ist das Standardprotokoll.

`System.Text.Json` ist nun das Standardhub Protokoll, das sowohl vom Client als auch vom Server verwendet wird.

In `Startup.ConfigureServices` wird `AddJsonProtocol` aufgerufen, um Serialisierungsoptionen festzulegen.

**Servers**

```csharp
services.AddSignalR(...)
        .AddJsonProtocol(options =>
        {
            options.PayloadSerializerOptions.WriteIndented = false;
        })
```

**Ent**

```csharp
new HubConnectionBuilder()
    .WithUrl("/chatHub")
    .AddJsonProtocol(options =>
    {
        options.PayloadSerializerOptions.WriteIndented = false;
    })
    .Build();
```

### <a name="switch-to-newtonsoftjson"></a>Wechseln Sie zu "newtonsoft. JSON".

Wenn Sie Features von `Newtonsoft.Json` verwenden, die in `System.Text.Json` nicht unterstützt werden, können Sie zurück zu `Newtonsoft.Json` wechseln:

1. Installieren Sie das nuget-Paket [Microsoft. aspnetcore. signalr. Protokolls. newtonsoft JSON](https://www.nuget.org/packages/Microsoft.AspNetCore.SignalR.Protocols.NewtonsoftJson) .
1. Verketten Sie auf dem Client einen `AddNewtonsoftJsonProtocol`-Methodenaufrufe an die `HubConnectionBuilder`-Instanz:

    ```csharp
    new HubConnectionBuilder()
        .WithUrl("/chatHub")
        .AddNewtonsoftJsonProtocol(...)
        .Build();
    ```

1. Verketten Sie auf dem-Server einen `AddNewtonsoftJsonProtocol`-Methodenaufrufe an den `AddSignalR`-Methoden aufrufin `Startup.ConfigureServices`:

    ```csharp
    services.AddSignalR()
        .AddNewtonsoftJsonProtocol(...);
    ```

## <a name="opt-in-to-runtime-compilation"></a>Abonnieren der Lauf Zeit Kompilierung

Vor ASP.net Core 3,0 war die Lauf Zeit Kompilierung von Sichten eine implizite Funktion des Frameworks. Die Lauf Zeit Kompilierung ergänzt die Kompilierung der Erstellung von Sichten. Sie ermöglicht es dem Framework, Razor-Ansichten und-Seiten (*cshtml* -Dateien) zu kompilieren, wenn die Dateien geändert werden, ohne die gesamte APP neu erstellen zu müssen. Diese Funktion unterstützt das Szenario der schnellen Bearbeitung in der IDE und das Aktualisieren des Browsers, um die Änderungen anzuzeigen.

In ASP.net Core 3,0 ist die Lauf Zeit Kompilierung ein Opt-in-Szenario. Die Kompilierzeit Kompilierung ist der einzige Mechanismus zum Anzeigen der Kompilierung, der standardmäßig aktiviert ist. Die Laufzeit basiert auf Visual Studio oder [dotnet-Watch](xref:tutorials/dotnet-watch) in Visual Studio Code, um das Projekt neu zu erstellen, wenn Änderungen an *cshtml* -Dateien erkannt werden. In Visual Studio werden Änderungen an *den CS*- *, cshtml*-oder *Razor* -Dateien im Projekt, das ausgeführt wird (<kbd>STRG + F5</kbd>), aber nicht debuggt (<kbd>F5</kbd>), die Neukompilierung des Projekts auslöst.

So aktivieren Sie die Lauf Zeit Kompilierung in Ihrem ASP.net Core 3,0-Projekt:

1. das NuGet-Paket [Microsoft.AspNetCore.Mvc.Razor.RuntimeCompilation](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Razor.RuntimeCompilation) installieren.
1. Aktualisieren Sie `Startup.ConfigureServices`, um `AddRazorRuntimeCompilation` aufzurufen:

    Verwenden Sie für ASP.net Core MVC den folgenden Code:

    ```csharp
    services.AddControllersWithViews()
        .AddRazorRuntimeCompilation(...);
    ```
 
    Verwenden Sie für ASP.net Core Razor Pages den folgenden Code:
 
    ```csharp
    services.AddRazorPages()
        .AddRazorRuntimeCompilation(...);
    ```
 
Das Beispiel in https://github.com/aspnet/samples/tree/master/samples/aspnetcore/mvc/runtimecompilation zeigt ein Beispiel für die bedingte Aktivierung der Lauf Zeit Kompilierung in Entwicklungsumgebungen.

Weitere Informationen zur Kompilierung von Razor-Dateien finden Sie unter <xref:mvc/views/view-compilation>.

## <a name="migrate-libraries-via-multi-targeting"></a>Migrieren von Bibliotheken mithilfe der Zielplattform

Bibliotheken müssen häufig mehrere Versionen von ASP.net Core unterstützen. Die meisten Bibliotheken, die für frühere Versionen von ASP.net Core kompiliert wurden, sollten ohne Probleme weiterhin funktionieren. Die folgenden Bedingungen erfordern eine Kreuz Kompilierung der APP:

* Die Bibliothek basiert auf einer Funktion, die über eine binäre [Breaking Change](#breaking-api-changes)verfügt.
* Die Bibliothek möchte die neuen Features in ASP.net Core 3,0 nutzen. 

Beispiel:

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFrameworks>netcoreapp3.0;netstandard2.0</TargetFrameworks>
  </PropertyGroup>

  <ItemGroup Condition="'$(TargetFramework)' == 'netcoreapp3.0'">
    <FrameworkReference Include="Microsoft.AspNetCore.App" />
  </ItemGroup>

  <ItemGroup Condition="'$(TargetFramework)' == 'netstandard2.0'">
    <PackageReference Include="Microsoft.AspNetCore" Version="2.1.0" />
  </ItemGroup>
</Project>
```

Verwenden Sie `#ifdefs`, um ASP.net Core 3,0-spezifische APIs zu aktivieren:

```csharp
var webRootFileProvider =
#if NETCOREAPP3_0
    GetRequiredService<IWebHostEnvironment>().WebRootFileProvider;
#elif NETSTANDARD2_0
    GetRequiredService<IHostingEnvironment>().WebRootFileProvider;
#else
#error unknown target framework
#endif
```

### <a name="publish"></a>Veröffentlichen

Löschen Sie die Ordner " *bin* " und " *obj* " im Projektverzeichnis.

<a name="break"></a>

## <a name="breaking-api-changes"></a>Wichtige API-Änderungen

Wichtige Änderungen überprüfen:

* [Umfassende Liste der wichtigen Änderungen in der Version ASP.net Core 3,0](https://github.com/aspnet/Announcements/issues?page=2&q=is%3Aissue+is%3Aopen+label%3A%22Breaking+change%22+label%3A3.0.0)
* [Unterbrechen von API-Änderungen in Antifälschung, cors, Diagnose, MVC und Routing](https://github.com/aspnet/Announcements/issues/387). Diese Liste enthält Breaking Changes für Kompatibilitätsoptionen.
* Eine Zusammenfassung 2,2-zu-3,0-Änderungen in .net Core, ASP.net Core und Entity Framework Core finden Sie unter [Breaking Changes for Migration from Version 2,2 to 3,0](/dotnet/core/compatibility/2.2-3.0).

## <a name="aspnet-core-30-not-currently-available-for-azure-app-service"></a>ASP.net Core 3,0 ist zurzeit für Azure App Service nicht verfügbar.

Wir hoffen, dies bald zur Verfügung zu stellen. Bis ASP.net Core 3,0 auf Azure App Service verfügbar ist, befolgen Sie die Anweisungen unter Bereitstellen [ASP.net Core Vorschauversion Azure App Service](xref:host-and-deploy/azure-apps/index#deploy-aspnet-core-preview-release-to-azure-app-service).

## <a name="mysqldataentityframeworkcore-not-currently-supported-on-aspnet-core-30"></a>MySQL. Data. entityframeworkcore wird derzeit auf ASP.net Core 3,0 nicht unterstützt.

Weitere Informationen finden Sie in [diesem GitHub-Issue](https://github.com/aspnet/EntityFrameworkCore/issues/17788).
